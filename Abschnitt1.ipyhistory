{
 "checkpoints": [
  {
   "timestamp": 1616494114891,
   "notebook": 0,
   "targetCells": [
    {
     "cell": "c.0.0",
     "changeType": "added",
     "index": 0
    }
   ]
  },
  {
   "timestamp": 1616498720192,
   "notebook": 1,
   "targetCells": [
    {
     "cell": "m.0.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "c.1.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.1.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "c.2.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "m.2.0",
     "changeType": "added",
     "index": 4
    },
    {
     "cell": "c.3.0",
     "changeType": "added",
     "index": 5
    },
    {
     "cell": "m.3.0",
     "changeType": "added",
     "index": 6
    },
    {
     "cell": "c.4.0",
     "changeType": "added",
     "index": 7
    },
    {
     "cell": "m.4.0",
     "changeType": "added",
     "index": 8
    },
    {
     "cell": "c.5.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "m.5.0",
     "changeType": "added",
     "index": 10
    },
    {
     "cell": "c.6.0",
     "changeType": "added",
     "index": 11
    },
    {
     "cell": "m.6.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "c.7.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "c.8.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "c.9.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "c.10.0",
     "changeType": "added",
     "index": 16
    }
   ]
  },
  {
   "timestamp": 1616498746783,
   "notebook": 2,
   "targetCells": [
    {
     "cell": "c.2.0",
     "changeType": "removed",
     "index": 3
    }
   ]
  },
  {
   "timestamp": 1616498750386,
   "notebook": 3,
   "targetCells": [
    {
     "cell": "c.11.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "m.1.1",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499297669,
   "notebook": 4,
   "targetCells": [
    {
     "cell": "m.1.2",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499338360,
   "notebook": 5,
   "targetCells": [
    {
     "cell": "m.1.3",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499351465,
   "notebook": 6,
   "targetCells": [
    {
     "cell": "m.1.4",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499363054,
   "notebook": 7,
   "targetCells": [
    {
     "cell": "m.1.5",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499535627,
   "notebook": 8,
   "targetCells": [
    {
     "cell": "m.1.6",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499708833,
   "notebook": 9,
   "targetCells": [
    {
     "cell": "m.1.7",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499721636,
   "notebook": 10,
   "targetCells": [
    {
     "cell": "m.1.8",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499741207,
   "notebook": 11,
   "targetCells": [
    {
     "cell": "m.1.9",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499753498,
   "notebook": 12,
   "targetCells": [
    {
     "cell": "m.1.10",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499759459,
   "notebook": 13,
   "targetCells": [
    {
     "cell": "m.1.11",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499788013,
   "notebook": 14,
   "targetCells": [
    {
     "cell": "m.1.12",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499833466,
   "notebook": 15,
   "targetCells": [
    {
     "cell": "m.1.13",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499841067,
   "notebook": 16,
   "targetCells": [
    {
     "cell": "m.1.14",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499849985,
   "notebook": 17,
   "targetCells": [
    {
     "cell": "m.1.15",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499858509,
   "notebook": 18,
   "targetCells": [
    {
     "cell": "m.1.16",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616499890349,
   "notebook": 19,
   "targetCells": [
    {
     "cell": "m.1.17",
     "changeType": "edited",
     "index": 2
    },
    {
     "cell": "c.12.0",
     "changeType": "added",
     "index": 4
    },
    {
     "cell": "c.11.1",
     "changeType": "edited",
     "output": [],
     "index": 3
    }
   ]
  },
  {
   "timestamp": 1616499917417,
   "notebook": 20,
   "targetCells": [
    {
     "cell": "c.11.2",
     "changeType": "edited",
     "output": [
      "o.1.0"
     ],
     "index": 3
    }
   ]
  },
  {
   "timestamp": 1616499923231,
   "notebook": 21,
   "targetCells": [
    {
     "cell": "c.11.3",
     "changeType": "edited",
     "output": [],
     "index": 3
    },
    {
     "cell": "c.13.0",
     "changeType": "added",
     "index": 4
    }
   ]
  },
  {
   "timestamp": 1616499976555,
   "notebook": 22,
   "targetCells": [
    {
     "cell": "c.13.1",
     "changeType": "edited",
     "output": [
      "o.2.0"
     ],
     "index": 4
    },
    {
     "cell": "c.11.4",
     "changeType": "edited",
     "output": [],
     "index": 3
    }
   ]
  },
  {
   "timestamp": 1616499993393,
   "notebook": 23,
   "targetCells": [
    {
     "cell": "c.11.5",
     "changeType": "edited",
     "output": [],
     "index": 3
    },
    {
     "cell": "c.13.1",
     "changeType": "output changed",
     "output": [
      "o.2.1"
     ],
     "index": 4
    }
   ]
  },
  {
   "timestamp": 1616500415041,
   "notebook": 24,
   "targetCells": [
    {
     "cell": "c.14.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.7.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "c.15.0",
     "changeType": "added",
     "index": 5
    },
    {
     "cell": "c.16.0",
     "changeType": "added",
     "index": 7
    },
    {
     "cell": "c.17.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "c.18.0",
     "changeType": "added",
     "index": 11
    },
    {
     "cell": "c.19.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "c.20.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "c.21.0",
     "changeType": "added",
     "index": 16
    },
    {
     "cell": "c.22.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "c.23.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "c.11.6",
     "changeType": "edited",
     "output": [],
     "index": 3
    },
    {
     "cell": "c.13.1",
     "changeType": "output changed",
     "output": [
      "o.2.2"
     ],
     "index": 4
    }
   ]
  },
  {
   "timestamp": 1616506614841,
   "notebook": 25,
   "targetCells": [
    {
     "cell": "c.24.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.8.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "c.25.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "m.9.0",
     "changeType": "added",
     "index": 5
    },
    {
     "cell": "c.26.0",
     "changeType": "added",
     "index": 6
    },
    {
     "cell": "m.10.0",
     "changeType": "added",
     "index": 7
    },
    {
     "cell": "c.27.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "c.28.0",
     "changeType": "added",
     "index": 11
    },
    {
     "cell": "c.29.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "c.30.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "c.31.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "c.32.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "c.33.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "c.34.0",
     "changeType": "added",
     "index": 20
    }
   ]
  },
  {
   "timestamp": 1616506989218,
   "notebook": 26,
   "targetCells": [
    {
     "cell": "m.2.1",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1616506999849,
   "notebook": 27,
   "targetCells": [
    {
     "cell": "m.2.2",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1616507058313,
   "notebook": 28,
   "targetCells": [
    {
     "cell": "m.2.3",
     "changeType": "edited",
     "index": 8
    },
    {
     "cell": "c.27.1",
     "changeType": "edited",
     "output": [],
     "index": 9
    }
   ]
  },
  {
   "timestamp": 1616507159625,
   "notebook": 29,
   "targetCells": [
    {
     "cell": "c.27.2",
     "changeType": "edited",
     "output": [
      "o.4.0"
     ],
     "index": 9
    }
   ]
  },
  {
   "timestamp": 1616585203580,
   "notebook": 30,
   "targetCells": [
    {
     "cell": "c.35.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.11.0",
     "changeType": "added",
     "index": 8
    },
    {
     "cell": "c.36.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "m.12.0",
     "changeType": "added",
     "index": 10
    },
    {
     "cell": "c.37.0",
     "changeType": "added",
     "index": 11
    },
    {
     "cell": "m.13.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "c.38.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "m.14.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "m.15.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "c.39.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "c.40.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "c.41.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "c.42.0",
     "changeType": "added",
     "index": 23
    },
    {
     "cell": "c.43.0",
     "changeType": "added",
     "index": 24
    },
    {
     "cell": "c.44.0",
     "changeType": "added",
     "index": 25
    },
    {
     "cell": "c.45.0",
     "changeType": "added",
     "index": 26
    }
   ]
  },
  {
   "timestamp": 1616585226477,
   "notebook": 31,
   "targetCells": [
    {
     "cell": "m.14.1",
     "changeType": "edited",
     "index": 14
    },
    {
     "cell": "c.39.0",
     "changeType": "output changed",
     "output": [
      "o.8.1"
     ],
     "index": 17
    },
    {
     "cell": "c.13.1",
     "changeType": "output changed",
     "output": [
      "o.2.3"
     ],
     "index": 4
    },
    {
     "cell": "c.38.0",
     "changeType": "output changed",
     "output": [
      "o.7.1"
     ],
     "index": 13
    }
   ]
  },
  {
   "timestamp": 1616585354080,
   "notebook": 32,
   "targetCells": [
    {
     "cell": "m.14.2",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585364359,
   "notebook": 33,
   "targetCells": [
    {
     "cell": "m.14.3",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585371315,
   "notebook": 34,
   "targetCells": [
    {
     "cell": "m.14.4",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585377369,
   "notebook": 35,
   "targetCells": [
    {
     "cell": "m.14.5",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585399297,
   "notebook": 36,
   "targetCells": [
    {
     "cell": "m.14.6",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585434963,
   "notebook": 37,
   "targetCells": [
    {
     "cell": "m.14.7",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585502579,
   "notebook": 38,
   "targetCells": [
    {
     "cell": "m.14.8",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585508540,
   "notebook": 39,
   "targetCells": [
    {
     "cell": "m.14.9",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585527352,
   "notebook": 40,
   "targetCells": [
    {
     "cell": "m.14.10",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585537972,
   "notebook": 41,
   "targetCells": [
    {
     "cell": "m.14.11",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585543966,
   "notebook": 42,
   "targetCells": [
    {
     "cell": "m.14.12",
     "changeType": "edited",
     "index": 14
    }
   ]
  },
  {
   "timestamp": 1616585916649,
   "notebook": 43,
   "targetCells": [
    {
     "cell": "m.12.1",
     "changeType": "edited",
     "index": 10
    },
    {
     "cell": "m.15.1",
     "changeType": "edited",
     "index": 15
    }
   ]
  },
  {
   "timestamp": 1616586162282,
   "notebook": 44,
   "targetCells": [
    {
     "cell": "m.15.2",
     "changeType": "edited",
     "index": 15
    },
    {
     "cell": "c.46.0",
     "changeType": "added",
     "index": 16
    }
   ]
  },
  {
   "timestamp": 1616586218316,
   "notebook": 45,
   "targetCells": [
    {
     "cell": "m.15.3",
     "changeType": "edited",
     "index": 15
    }
   ]
  },
  {
   "timestamp": 1616586254771,
   "notebook": 46,
   "targetCells": [
    {
     "cell": "m.15.4",
     "changeType": "edited",
     "index": 15
    },
    {
     "cell": "c.46.1",
     "changeType": "edited",
     "output": [
      "o.9.0"
     ],
     "index": 16
    }
   ]
  },
  {
   "timestamp": 1616586320819,
   "notebook": 47,
   "targetCells": [
    {
     "cell": "c.46.2",
     "changeType": "edited",
     "output": [
      "o.10.0"
     ],
     "index": 16
    }
   ]
  },
  {
   "timestamp": 1616586339268,
   "notebook": 48,
   "targetCells": [
    {
     "cell": "c.46.3",
     "changeType": "edited",
     "output": [
      "o.11.0"
     ],
     "index": 16
    },
    {
     "cell": "m.15.5",
     "changeType": "edited",
     "index": 15
    }
   ]
  },
  {
   "timestamp": 1616586523308,
   "notebook": 49,
   "targetCells": [
    {
     "cell": "m.15.6",
     "changeType": "edited",
     "index": 15
    }
   ]
  },
  {
   "timestamp": 1616591319024,
   "notebook": 50,
   "targetCells": [
    {
     "cell": "m.3.1",
     "changeType": "edited",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1616591680074,
   "notebook": 51,
   "targetCells": [
    {
     "cell": "m.3.2",
     "changeType": "edited",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1616591687488,
   "notebook": 52,
   "targetCells": [
    {
     "cell": "m.3.3",
     "changeType": "edited",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1616591708423,
   "notebook": 53,
   "targetCells": [
    {
     "cell": "m.3.4",
     "changeType": "edited",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1616591715143,
   "notebook": 54,
   "targetCells": [
    {
     "cell": "m.3.5",
     "changeType": "edited",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1616591723947,
   "notebook": 55,
   "targetCells": [
    {
     "cell": "m.3.6",
     "changeType": "edited",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1616591732014,
   "notebook": 56,
   "targetCells": [
    {
     "cell": "m.3.7",
     "changeType": "edited",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1616591886115,
   "notebook": 57,
   "targetCells": [
    {
     "cell": "m.3.8",
     "changeType": "edited",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1616763894011,
   "notebook": 58,
   "targetCells": [
    {
     "cell": "c.47.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.16.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "c.48.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "c.49.0",
     "changeType": "added",
     "index": 16
    },
    {
     "cell": "m.17.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "m.18.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "c.50.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "m.19.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "c.51.0",
     "changeType": "added",
     "index": 22
    },
    {
     "cell": "m.20.0",
     "changeType": "added",
     "index": 23
    },
    {
     "cell": "c.52.0",
     "changeType": "added",
     "index": 24
    },
    {
     "cell": "m.21.0",
     "changeType": "added",
     "index": 25
    },
    {
     "cell": "c.53.0",
     "changeType": "added",
     "index": 26
    },
    {
     "cell": "m.22.0",
     "changeType": "added",
     "index": 27
    },
    {
     "cell": "m.23.0",
     "changeType": "added",
     "index": 28
    },
    {
     "cell": "c.54.0",
     "changeType": "added",
     "index": 29
    },
    {
     "cell": "m.24.0",
     "changeType": "added",
     "index": 30
    },
    {
     "cell": "c.55.0",
     "changeType": "added",
     "index": 31
    },
    {
     "cell": "m.25.0",
     "changeType": "added",
     "index": 32
    },
    {
     "cell": "c.56.0",
     "changeType": "added",
     "index": 33
    },
    {
     "cell": "m.26.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "c.57.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "m.27.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "c.58.0",
     "changeType": "added",
     "index": 37
    },
    {
     "cell": "m.28.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "c.59.0",
     "changeType": "added",
     "index": 39
    },
    {
     "cell": "m.29.0",
     "changeType": "added",
     "index": 40
    },
    {
     "cell": "c.60.0",
     "changeType": "added",
     "index": 41
    },
    {
     "cell": "m.30.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "c.61.0",
     "changeType": "added",
     "index": 43
    },
    {
     "cell": "c.62.0",
     "changeType": "added",
     "index": 44
    },
    {
     "cell": "m.31.0",
     "changeType": "added",
     "index": 45
    },
    {
     "cell": "c.63.0",
     "changeType": "added",
     "index": 46
    },
    {
     "cell": "m.32.0",
     "changeType": "added",
     "index": 47
    },
    {
     "cell": "c.64.0",
     "changeType": "added",
     "index": 48
    },
    {
     "cell": "m.33.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "c.65.0",
     "changeType": "added",
     "index": 50
    },
    {
     "cell": "m.34.0",
     "changeType": "added",
     "index": 51
    },
    {
     "cell": "c.66.0",
     "changeType": "added",
     "index": 52
    },
    {
     "cell": "c.67.0",
     "changeType": "added",
     "index": 54
    },
    {
     "cell": "c.68.0",
     "changeType": "added",
     "index": 56
    },
    {
     "cell": "c.69.0",
     "changeType": "added",
     "index": 57
    },
    {
     "cell": "c.70.0",
     "changeType": "added",
     "index": 58
    },
    {
     "cell": "c.71.0",
     "changeType": "added",
     "index": 59
    }
   ]
  },
  {
   "timestamp": 1616764358932,
   "notebook": 59,
   "targetCells": [
    {
     "cell": "c.72.0",
     "changeType": "added",
     "index": 55
    }
   ]
  },
  {
   "timestamp": 1616856887897,
   "notebook": 60,
   "targetCells": [
    {
     "cell": "c.73.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.35.0",
     "changeType": "added",
     "index": 7
    },
    {
     "cell": "c.74.0",
     "changeType": "added",
     "index": 8
    },
    {
     "cell": "m.36.0",
     "changeType": "added",
     "index": 54
    },
    {
     "cell": "c.75.0",
     "changeType": "added",
     "index": 55
    },
    {
     "cell": "m.37.0",
     "changeType": "added",
     "index": 56
    },
    {
     "cell": "m.38.0",
     "changeType": "added",
     "index": 57
    },
    {
     "cell": "c.76.0",
     "changeType": "added",
     "index": 58
    },
    {
     "cell": "c.77.0",
     "changeType": "added",
     "index": 59
    },
    {
     "cell": "m.39.0",
     "changeType": "added",
     "index": 60
    },
    {
     "cell": "m.40.0",
     "changeType": "added",
     "index": 61
    },
    {
     "cell": "c.78.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "c.79.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "m.41.0",
     "changeType": "added",
     "index": 64
    },
    {
     "cell": "c.80.0",
     "changeType": "added",
     "index": 65
    },
    {
     "cell": "m.42.0",
     "changeType": "added",
     "index": 66
    },
    {
     "cell": "c.81.0",
     "changeType": "added",
     "index": 67
    },
    {
     "cell": "c.82.0",
     "changeType": "added",
     "index": 68
    },
    {
     "cell": "m.43.0",
     "changeType": "added",
     "index": 69
    },
    {
     "cell": "m.44.0",
     "changeType": "added",
     "index": 70
    },
    {
     "cell": "m.45.0",
     "changeType": "added",
     "index": 71
    },
    {
     "cell": "c.83.0",
     "changeType": "added",
     "index": 72
    },
    {
     "cell": "m.46.0",
     "changeType": "added",
     "index": 73
    },
    {
     "cell": "m.47.0",
     "changeType": "added",
     "index": 74
    },
    {
     "cell": "c.84.0",
     "changeType": "added",
     "index": 75
    },
    {
     "cell": "m.48.0",
     "changeType": "added",
     "index": 76
    },
    {
     "cell": "c.85.0",
     "changeType": "added",
     "index": 77
    },
    {
     "cell": "m.49.0",
     "changeType": "added",
     "index": 78
    },
    {
     "cell": "c.86.0",
     "changeType": "added",
     "index": 79
    },
    {
     "cell": "m.50.0",
     "changeType": "added",
     "index": 80
    },
    {
     "cell": "c.87.0",
     "changeType": "added",
     "index": 81
    },
    {
     "cell": "m.51.0",
     "changeType": "added",
     "index": 82
    },
    {
     "cell": "c.88.0",
     "changeType": "added",
     "index": 83
    },
    {
     "cell": "m.52.0",
     "changeType": "added",
     "index": 84
    },
    {
     "cell": "c.89.0",
     "changeType": "added",
     "index": 85
    },
    {
     "cell": "m.53.0",
     "changeType": "added",
     "index": 86
    },
    {
     "cell": "c.90.0",
     "changeType": "added",
     "index": 87
    },
    {
     "cell": "m.54.0",
     "changeType": "added",
     "index": 88
    },
    {
     "cell": "c.91.0",
     "changeType": "added",
     "index": 89
    },
    {
     "cell": "m.55.0",
     "changeType": "added",
     "index": 90
    },
    {
     "cell": "c.92.0",
     "changeType": "added",
     "index": 91
    },
    {
     "cell": "m.56.0",
     "changeType": "added",
     "index": 92
    },
    {
     "cell": "c.93.0",
     "changeType": "added",
     "index": 93
    },
    {
     "cell": "m.57.0",
     "changeType": "added",
     "index": 94
    },
    {
     "cell": "c.94.0",
     "changeType": "added",
     "index": 95
    },
    {
     "cell": "m.58.0",
     "changeType": "added",
     "index": 96
    },
    {
     "cell": "c.95.0",
     "changeType": "added",
     "index": 97
    },
    {
     "cell": "m.59.0",
     "changeType": "added",
     "index": 98
    },
    {
     "cell": "c.96.0",
     "changeType": "added",
     "index": 99
    }
   ]
  },
  {
   "timestamp": 1616857853381,
   "notebook": 61,
   "targetCells": [
    {
     "cell": "m.0.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.73.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.8.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.25.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.13.1",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.9.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.26.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.35.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.74.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.11.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.36.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.12.1",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.37.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.13.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.38.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.16.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.48.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.49.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.17.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.46.3",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.18.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.50.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.19.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.51.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.20.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.52.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.21.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.53.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.22.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.23.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.54.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.24.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.55.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.25.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.56.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.26.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.57.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.27.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.58.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.28.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.59.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.29.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.60.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.30.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.61.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.62.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.31.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.63.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.32.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.64.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.33.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.65.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.34.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.66.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.36.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.75.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.37.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.38.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.76.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.77.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.39.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.40.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.78.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.79.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.41.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.80.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.42.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.81.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.82.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.43.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.44.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.45.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.83.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.46.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.47.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.84.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.48.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.85.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.49.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.86.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.50.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.87.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.51.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.88.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.52.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.89.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.53.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.90.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.54.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.91.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.55.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.92.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.56.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.93.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.57.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.94.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.58.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.95.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.59.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.96.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.60.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "c.97.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.61.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "m.62.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "m.63.0",
     "changeType": "added",
     "index": 4
    },
    {
     "cell": "m.64.0",
     "changeType": "added",
     "index": 5
    },
    {
     "cell": "m.65.0",
     "changeType": "added",
     "index": 6
    },
    {
     "cell": "m.66.0",
     "changeType": "added",
     "index": 7
    },
    {
     "cell": "m.67.0",
     "changeType": "added",
     "index": 8
    },
    {
     "cell": "m.68.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "m.69.0",
     "changeType": "added",
     "index": 10
    },
    {
     "cell": "m.70.0",
     "changeType": "added",
     "index": 11
    },
    {
     "cell": "m.71.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "m.72.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "m.73.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "m.74.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "m.75.0",
     "changeType": "added",
     "index": 16
    },
    {
     "cell": "m.76.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "m.77.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "m.78.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "m.79.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "m.80.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "m.81.0",
     "changeType": "added",
     "index": 22
    },
    {
     "cell": "m.82.0",
     "changeType": "added",
     "index": 23
    },
    {
     "cell": "m.83.0",
     "changeType": "added",
     "index": 24
    },
    {
     "cell": "m.84.0",
     "changeType": "added",
     "index": 25
    },
    {
     "cell": "m.85.0",
     "changeType": "added",
     "index": 26
    },
    {
     "cell": "m.86.0",
     "changeType": "added",
     "index": 27
    },
    {
     "cell": "m.87.0",
     "changeType": "added",
     "index": 28
    },
    {
     "cell": "m.88.0",
     "changeType": "added",
     "index": 29
    },
    {
     "cell": "m.89.0",
     "changeType": "added",
     "index": 30
    },
    {
     "cell": "m.90.0",
     "changeType": "added",
     "index": 31
    },
    {
     "cell": "m.91.0",
     "changeType": "added",
     "index": 32
    },
    {
     "cell": "m.92.0",
     "changeType": "added",
     "index": 33
    },
    {
     "cell": "m.93.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "m.94.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "m.95.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "m.96.0",
     "changeType": "added",
     "index": 37
    },
    {
     "cell": "m.97.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "m.98.0",
     "changeType": "added",
     "index": 39
    },
    {
     "cell": "m.99.0",
     "changeType": "added",
     "index": 40
    },
    {
     "cell": "m.100.0",
     "changeType": "added",
     "index": 41
    },
    {
     "cell": "m.101.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "m.102.0",
     "changeType": "added",
     "index": 43
    },
    {
     "cell": "m.103.0",
     "changeType": "added",
     "index": 44
    },
    {
     "cell": "m.104.0",
     "changeType": "added",
     "index": 45
    },
    {
     "cell": "m.105.0",
     "changeType": "added",
     "index": 46
    },
    {
     "cell": "m.106.0",
     "changeType": "added",
     "index": 47
    },
    {
     "cell": "m.107.0",
     "changeType": "added",
     "index": 48
    },
    {
     "cell": "m.108.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "m.109.0",
     "changeType": "added",
     "index": 50
    },
    {
     "cell": "c.98.0",
     "changeType": "added",
     "index": 51
    }
   ]
  },
  {
   "timestamp": 1616857853619,
   "notebook": 62,
   "targetCells": [
    {
     "cell": "c.99.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "c.100.0",
     "changeType": "added",
     "index": 4
    },
    {
     "cell": "c.101.0",
     "changeType": "added",
     "index": 6
    },
    {
     "cell": "c.102.0",
     "changeType": "added",
     "index": 8
    },
    {
     "cell": "c.103.0",
     "changeType": "added",
     "index": 10
    },
    {
     "cell": "c.104.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "c.105.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "c.106.0",
     "changeType": "added",
     "index": 16
    },
    {
     "cell": "c.107.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "c.108.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "c.109.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "c.110.0",
     "changeType": "added",
     "index": 23
    },
    {
     "cell": "c.111.0",
     "changeType": "added",
     "index": 25
    },
    {
     "cell": "c.112.0",
     "changeType": "added",
     "index": 27
    },
    {
     "cell": "c.113.0",
     "changeType": "added",
     "index": 30
    },
    {
     "cell": "c.114.0",
     "changeType": "added",
     "index": 32
    },
    {
     "cell": "c.115.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "c.116.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "c.117.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "c.118.0",
     "changeType": "added",
     "index": 40
    },
    {
     "cell": "c.119.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "c.120.0",
     "changeType": "added",
     "index": 44
    },
    {
     "cell": "c.121.0",
     "changeType": "added",
     "index": 45
    },
    {
     "cell": "c.122.0",
     "changeType": "added",
     "index": 47
    },
    {
     "cell": "c.123.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "c.124.0",
     "changeType": "added",
     "index": 51
    },
    {
     "cell": "c.125.0",
     "changeType": "added",
     "index": 53
    },
    {
     "cell": "c.126.0",
     "changeType": "added",
     "index": 55
    },
    {
     "cell": "c.127.0",
     "changeType": "added",
     "index": 58
    },
    {
     "cell": "c.128.0",
     "changeType": "added",
     "index": 59
    },
    {
     "cell": "c.129.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "c.130.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "c.131.0",
     "changeType": "added",
     "index": 65
    },
    {
     "cell": "c.132.0",
     "changeType": "added",
     "index": 67
    },
    {
     "cell": "c.133.0",
     "changeType": "added",
     "index": 68
    },
    {
     "cell": "c.134.0",
     "changeType": "added",
     "index": 72
    },
    {
     "cell": "c.135.0",
     "changeType": "added",
     "index": 75
    },
    {
     "cell": "c.136.0",
     "changeType": "added",
     "index": 77
    },
    {
     "cell": "c.137.0",
     "changeType": "added",
     "index": 79
    },
    {
     "cell": "c.138.0",
     "changeType": "added",
     "index": 81
    },
    {
     "cell": "c.139.0",
     "changeType": "added",
     "index": 83
    },
    {
     "cell": "c.140.0",
     "changeType": "added",
     "index": 85
    },
    {
     "cell": "c.141.0",
     "changeType": "added",
     "index": 87
    },
    {
     "cell": "c.142.0",
     "changeType": "added",
     "index": 89
    },
    {
     "cell": "c.143.0",
     "changeType": "added",
     "index": 91
    },
    {
     "cell": "c.144.0",
     "changeType": "added",
     "index": 93
    },
    {
     "cell": "c.145.0",
     "changeType": "added",
     "index": 95
    },
    {
     "cell": "c.146.0",
     "changeType": "added",
     "index": 97
    },
    {
     "cell": "m.71.1",
     "changeType": "edited",
     "index": 24
    }
   ]
  },
  {
   "timestamp": 1616857990572,
   "notebook": 63,
   "targetCells": [
    {
     "cell": "m.71.2",
     "changeType": "edited",
     "index": 24
    }
   ]
  },
  {
   "timestamp": 1616858001954,
   "notebook": 64,
   "targetCells": [
    {
     "cell": "m.71.3",
     "changeType": "edited",
     "index": -1
    },
    {
     "cell": "m.71.4",
     "changeType": "edited",
     "index": 24
    }
   ]
  },
  {
   "timestamp": 1616858010596,
   "notebook": 65,
   "targetCells": [
    {
     "cell": "m.71.5",
     "changeType": "edited",
     "index": -1
    },
    {
     "cell": "m.71.6",
     "changeType": "edited",
     "index": 24
    }
   ]
  },
  {
   "timestamp": 1616858354622,
   "notebook": 66,
   "targetCells": [
    {
     "cell": "m.60.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.97.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.61.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.99.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.100.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.62.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.101.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.63.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.102.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.64.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.103.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.65.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.104.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.66.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.105.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.67.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.106.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.107.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.68.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.108.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.69.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.109.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.70.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.110.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.71.6",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.111.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.72.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.112.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.73.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.74.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.113.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.75.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.114.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.76.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.115.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.77.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.116.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.78.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.117.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.79.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.118.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.80.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.119.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.81.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.120.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.121.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.82.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.122.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.83.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.123.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.84.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.124.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.85.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.125.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.86.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.126.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.87.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.88.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.127.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.128.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.89.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.90.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.129.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.130.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.91.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.131.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.92.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.132.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.133.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.93.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.94.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.95.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.134.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.96.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.97.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.135.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.98.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.136.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.99.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.137.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.100.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.138.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.101.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.139.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.102.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.140.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.103.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.141.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.104.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.142.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.105.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.143.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.106.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.144.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.107.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.145.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.108.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.146.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.109.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "c.98.0",
     "changeType": "removed",
     "index": 0
    },
    {
     "cell": "m.110.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "c.147.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.111.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "m.112.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "m.113.0",
     "changeType": "added",
     "index": 4
    },
    {
     "cell": "m.114.0",
     "changeType": "added",
     "index": 5
    },
    {
     "cell": "m.115.0",
     "changeType": "added",
     "index": 6
    },
    {
     "cell": "m.116.0",
     "changeType": "added",
     "index": 7
    },
    {
     "cell": "m.117.0",
     "changeType": "added",
     "index": 8
    },
    {
     "cell": "m.118.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "m.119.0",
     "changeType": "added",
     "index": 10
    },
    {
     "cell": "m.120.0",
     "changeType": "added",
     "index": 11
    },
    {
     "cell": "m.121.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "m.122.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "m.123.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "m.124.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "m.125.0",
     "changeType": "added",
     "index": 16
    },
    {
     "cell": "m.126.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "m.127.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "m.128.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "m.129.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "m.130.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "m.131.0",
     "changeType": "added",
     "index": 22
    },
    {
     "cell": "m.132.0",
     "changeType": "added",
     "index": 23
    },
    {
     "cell": "m.133.0",
     "changeType": "added",
     "index": 24
    },
    {
     "cell": "m.134.0",
     "changeType": "added",
     "index": 25
    },
    {
     "cell": "m.135.0",
     "changeType": "added",
     "index": 26
    },
    {
     "cell": "m.136.0",
     "changeType": "added",
     "index": 27
    },
    {
     "cell": "m.137.0",
     "changeType": "added",
     "index": 28
    },
    {
     "cell": "m.138.0",
     "changeType": "added",
     "index": 29
    },
    {
     "cell": "m.139.0",
     "changeType": "added",
     "index": 30
    },
    {
     "cell": "m.140.0",
     "changeType": "added",
     "index": 31
    },
    {
     "cell": "m.141.0",
     "changeType": "added",
     "index": 32
    },
    {
     "cell": "m.142.0",
     "changeType": "added",
     "index": 33
    },
    {
     "cell": "m.143.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "m.144.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "m.145.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "m.146.0",
     "changeType": "added",
     "index": 37
    },
    {
     "cell": "m.147.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "m.148.0",
     "changeType": "added",
     "index": 39
    },
    {
     "cell": "m.149.0",
     "changeType": "added",
     "index": 40
    },
    {
     "cell": "m.150.0",
     "changeType": "added",
     "index": 41
    },
    {
     "cell": "m.151.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "m.152.0",
     "changeType": "added",
     "index": 43
    },
    {
     "cell": "m.153.0",
     "changeType": "added",
     "index": 44
    },
    {
     "cell": "m.154.0",
     "changeType": "added",
     "index": 45
    },
    {
     "cell": "m.155.0",
     "changeType": "added",
     "index": 46
    },
    {
     "cell": "m.156.0",
     "changeType": "added",
     "index": 47
    },
    {
     "cell": "m.157.0",
     "changeType": "added",
     "index": 48
    },
    {
     "cell": "m.158.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "m.159.0",
     "changeType": "added",
     "index": 50
    },
    {
     "cell": "c.148.0",
     "changeType": "added",
     "index": 51
    }
   ]
  },
  {
   "timestamp": 1616859134396,
   "notebook": 67,
   "targetCells": [
    {
     "cell": "c.197.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "c.198.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "c.199.0",
     "changeType": "added",
     "index": 4
    },
    {
     "cell": "c.200.0",
     "changeType": "added",
     "index": 6
    },
    {
     "cell": "c.201.0",
     "changeType": "added",
     "index": 8
    },
    {
     "cell": "c.202.0",
     "changeType": "added",
     "index": 10
    },
    {
     "cell": "c.203.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "c.204.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "c.205.0",
     "changeType": "added",
     "index": 16
    },
    {
     "cell": "c.206.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "c.207.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "c.208.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "c.209.0",
     "changeType": "added",
     "index": 23
    },
    {
     "cell": "c.210.0",
     "changeType": "added",
     "index": 25
    },
    {
     "cell": "c.211.0",
     "changeType": "added",
     "index": 27
    },
    {
     "cell": "c.212.0",
     "changeType": "added",
     "index": 30
    },
    {
     "cell": "c.213.0",
     "changeType": "added",
     "index": 32
    },
    {
     "cell": "c.214.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "c.215.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "c.216.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "c.217.0",
     "changeType": "added",
     "index": 40
    },
    {
     "cell": "c.218.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "c.219.0",
     "changeType": "added",
     "index": 44
    },
    {
     "cell": "c.220.0",
     "changeType": "added",
     "index": 45
    },
    {
     "cell": "c.221.0",
     "changeType": "added",
     "index": 47
    },
    {
     "cell": "c.222.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "c.223.0",
     "changeType": "added",
     "index": 51
    },
    {
     "cell": "c.224.0",
     "changeType": "added",
     "index": 53
    },
    {
     "cell": "c.225.0",
     "changeType": "added",
     "index": 55
    },
    {
     "cell": "c.226.0",
     "changeType": "added",
     "index": 58
    },
    {
     "cell": "c.227.0",
     "changeType": "added",
     "index": 59
    },
    {
     "cell": "c.228.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "c.229.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "c.230.0",
     "changeType": "added",
     "index": 65
    },
    {
     "cell": "c.231.0",
     "changeType": "added",
     "index": 67
    },
    {
     "cell": "c.232.0",
     "changeType": "added",
     "index": 68
    },
    {
     "cell": "c.233.0",
     "changeType": "added",
     "index": 72
    },
    {
     "cell": "c.234.0",
     "changeType": "added",
     "index": 75
    },
    {
     "cell": "c.235.0",
     "changeType": "added",
     "index": 77
    },
    {
     "cell": "c.236.0",
     "changeType": "added",
     "index": 79
    },
    {
     "cell": "c.237.0",
     "changeType": "added",
     "index": 81
    },
    {
     "cell": "c.238.0",
     "changeType": "added",
     "index": 83
    },
    {
     "cell": "c.239.0",
     "changeType": "added",
     "index": 85
    },
    {
     "cell": "c.240.0",
     "changeType": "added",
     "index": 87
    },
    {
     "cell": "c.241.0",
     "changeType": "added",
     "index": 89
    },
    {
     "cell": "c.242.0",
     "changeType": "added",
     "index": 91
    },
    {
     "cell": "c.243.0",
     "changeType": "added",
     "index": 93
    },
    {
     "cell": "c.244.0",
     "changeType": "added",
     "index": 95
    },
    {
     "cell": "c.245.0",
     "changeType": "added",
     "index": 97
    },
    {
     "cell": "m.160.0",
     "changeType": "added",
     "index": 98
    },
    {
     "cell": "c.246.0",
     "changeType": "added",
     "index": 99
    },
    {
     "cell": "m.125.1",
     "changeType": "edited",
     "index": 31
    }
   ]
  },
  {
   "timestamp": 1616859318783,
   "notebook": 68,
   "targetCells": [
    {
     "cell": "c.247.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.161.0",
     "changeType": "added",
     "index": 98
    },
    {
     "cell": "c.248.0",
     "changeType": "added",
     "index": 99
    }
   ]
  },
  {
   "timestamp": 1616859333029,
   "notebook": 69,
   "targetCells": [
    {
     "cell": "c.249.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "c.247.0",
     "changeType": "removed",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1616860423327,
   "notebook": 70,
   "targetCells": [
    {
     "cell": "c.250.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "c.251.0",
     "changeType": "added",
     "index": 99
    }
   ]
  },
  {
   "timestamp": 1616861593906,
   "notebook": 71,
   "targetCells": [
    {
     "cell": "m.161.1",
     "changeType": "edited",
     "index": 98
    },
    {
     "cell": "m.135.1",
     "changeType": "edited",
     "index": 52
    }
   ]
  },
  {
   "timestamp": 1617006907566,
   "notebook": 72,
   "targetCells": [
    {
     "cell": "c.252.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "c.253.0",
     "changeType": "added",
     "index": 99
    }
   ]
  },
  {
   "timestamp": 1617008269323,
   "notebook": 73,
   "targetCells": [
    {
     "cell": "m.115.1",
     "changeType": "edited",
     "index": 11
    }
   ]
  },
  {
   "timestamp": 1617008281926,
   "notebook": 74,
   "targetCells": [
    {
     "cell": "m.115.2",
     "changeType": "edited",
     "index": 11
    }
   ]
  },
  {
   "timestamp": 1617008296329,
   "notebook": 75,
   "targetCells": [
    {
     "cell": "m.115.3",
     "changeType": "edited",
     "index": 11
    },
    {
     "cell": "c.227.1",
     "changeType": "edited",
     "output": [
      "o.148.0"
     ],
     "index": 59
    }
   ]
  },
  {
   "timestamp": 1617025435363,
   "notebook": 76,
   "targetCells": [
    {
     "cell": "m.162.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "m.163.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "m.164.0",
     "changeType": "added",
     "index": 7
    },
    {
     "cell": "c.254.0",
     "changeType": "added",
     "index": 59
    },
    {
     "cell": "c.255.0",
     "changeType": "added",
     "index": 99
    }
   ]
  },
  {
   "timestamp": 1617025559423,
   "notebook": 77,
   "targetCells": [
    {
     "cell": "m.163.1",
     "changeType": "edited",
     "index": 2
    },
    {
     "cell": "m.112.1",
     "changeType": "edited",
     "index": 5
    },
    {
     "cell": "m.164.1",
     "changeType": "edited",
     "index": 7
    }
   ]
  },
  {
   "timestamp": 1617025660878,
   "notebook": 78,
   "targetCells": [
    {
     "cell": "m.164.2",
     "changeType": "edited",
     "index": 7
    }
   ]
  },
  {
   "timestamp": 1617025751985,
   "notebook": 79,
   "targetCells": [
    {
     "cell": "m.164.3",
     "changeType": "edited",
     "index": 7
    }
   ]
  },
  {
   "timestamp": 1617025756251,
   "notebook": 80,
   "targetCells": [
    {
     "cell": "m.164.4",
     "changeType": "edited",
     "index": 7
    }
   ]
  },
  {
   "timestamp": 1617025773471,
   "notebook": 81,
   "targetCells": [
    {
     "cell": "m.164.5",
     "changeType": "edited",
     "index": 7
    }
   ]
  },
  {
   "timestamp": 1617025783710,
   "notebook": 82,
   "targetCells": [
    {
     "cell": "m.164.6",
     "changeType": "edited",
     "index": 7
    }
   ]
  },
  {
   "timestamp": 1617025822464,
   "notebook": 83,
   "targetCells": [
    {
     "cell": "m.164.7",
     "changeType": "edited",
     "index": 7
    },
    {
     "cell": "c.256.0",
     "changeType": "added",
     "index": 9
    }
   ]
  },
  {
   "timestamp": 1617374393763,
   "notebook": 84,
   "targetCells": [
    {
     "cell": "m.165.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "m.166.0",
     "changeType": "added",
     "index": 10
    },
    {
     "cell": "m.167.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "m.168.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "m.169.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "c.257.0",
     "changeType": "added",
     "index": 16
    },
    {
     "cell": "m.170.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "c.258.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "m.171.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "m.172.0",
     "changeType": "added",
     "index": 22
    },
    {
     "cell": "m.173.0",
     "changeType": "added",
     "index": 24
    },
    {
     "cell": "c.259.0",
     "changeType": "added",
     "index": 25
    },
    {
     "cell": "m.174.0",
     "changeType": "added",
     "index": 26
    },
    {
     "cell": "c.260.0",
     "changeType": "added",
     "index": 27
    },
    {
     "cell": "m.175.0",
     "changeType": "added",
     "index": 28
    },
    {
     "cell": "c.261.0",
     "changeType": "added",
     "index": 29
    },
    {
     "cell": "m.176.0",
     "changeType": "added",
     "index": 30
    },
    {
     "cell": "m.177.0",
     "changeType": "added",
     "index": 33
    },
    {
     "cell": "c.262.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "m.178.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "c.263.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "c.264.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "m.179.0",
     "changeType": "added",
     "index": 39
    },
    {
     "cell": "m.180.0",
     "changeType": "added",
     "index": 41
    },
    {
     "cell": "c.265.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "c.266.0",
     "changeType": "added",
     "index": 43
    },
    {
     "cell": "m.181.0",
     "changeType": "added",
     "index": 105
    },
    {
     "cell": "c.267.0",
     "changeType": "added",
     "index": 106
    },
    {
     "cell": "m.143.1",
     "changeType": "edited",
     "index": 76
    },
    {
     "cell": "m.144.1",
     "changeType": "edited",
     "index": 77
    },
    {
     "cell": "c.268.0",
     "changeType": "added",
     "index": 78
    }
   ]
  },
  {
   "timestamp": 1617374715728,
   "notebook": 85,
   "targetCells": [
    {
     "cell": "c.268.0",
     "changeType": "removed",
     "index": 78
    }
   ]
  },
  {
   "timestamp": 1617374727891,
   "notebook": 86,
   "targetCells": [
    {
     "cell": "c.269.0",
     "changeType": "added",
     "index": 78
    }
   ]
  },
  {
   "timestamp": 1617374738478,
   "notebook": 87,
   "targetCells": [
    {
     "cell": "c.269.1",
     "changeType": "edited",
     "output": [
      "o.159.0"
     ],
     "index": 78
    }
   ]
  },
  {
   "timestamp": 1617374793459,
   "notebook": 88,
   "targetCells": [
    {
     "cell": "c.269.2",
     "changeType": "edited",
     "output": [
      "o.160.0"
     ],
     "index": 78
    }
   ]
  },
  {
   "timestamp": 1617374818127,
   "notebook": 89,
   "targetCells": [
    {
     "cell": "c.269.3",
     "changeType": "edited",
     "output": [
      "o.161.0"
     ],
     "index": 78
    }
   ]
  },
  {
   "timestamp": 1617374831543,
   "notebook": 90,
   "targetCells": [
    {
     "cell": "c.269.4",
     "changeType": "edited",
     "output": [
      "o.162.0"
     ],
     "index": 78
    }
   ]
  },
  {
   "timestamp": 1617531200343,
   "notebook": 91,
   "targetCells": [
    {
     "cell": "m.182.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "c.270.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "m.183.0",
     "changeType": "added",
     "index": 79
    },
    {
     "cell": "c.271.0",
     "changeType": "added",
     "index": 80
    },
    {
     "cell": "m.184.0",
     "changeType": "added",
     "index": 81
    },
    {
     "cell": "c.272.0",
     "changeType": "added",
     "index": 82
    },
    {
     "cell": "m.185.0",
     "changeType": "added",
     "index": 83
    },
    {
     "cell": "c.273.0",
     "changeType": "added",
     "index": 84
    },
    {
     "cell": "c.274.0",
     "changeType": "added",
     "index": 85
    },
    {
     "cell": "m.186.0",
     "changeType": "added",
     "index": 86
    },
    {
     "cell": "m.187.0",
     "changeType": "added",
     "index": 88
    },
    {
     "cell": "m.188.0",
     "changeType": "added",
     "index": 89
    },
    {
     "cell": "m.189.0",
     "changeType": "added",
     "index": 93
    },
    {
     "cell": "c.275.0",
     "changeType": "added",
     "index": 94
    },
    {
     "cell": "m.190.0",
     "changeType": "added",
     "index": 95
    },
    {
     "cell": "c.276.0",
     "changeType": "added",
     "index": 98
    },
    {
     "cell": "c.277.0",
     "changeType": "added",
     "index": 102
    },
    {
     "cell": "m.191.0",
     "changeType": "added",
     "index": 103
    },
    {
     "cell": "c.278.0",
     "changeType": "added",
     "index": 104
    },
    {
     "cell": "m.192.0",
     "changeType": "added",
     "index": 105
    },
    {
     "cell": "m.193.0",
     "changeType": "added",
     "index": 106
    },
    {
     "cell": "c.279.0",
     "changeType": "added",
     "index": 107
    },
    {
     "cell": "m.194.0",
     "changeType": "added",
     "index": 110
    },
    {
     "cell": "c.280.0",
     "changeType": "added",
     "index": 111
    },
    {
     "cell": "m.195.0",
     "changeType": "added",
     "index": 114
    },
    {
     "cell": "c.281.0",
     "changeType": "added",
     "index": 115
    }
   ]
  },
  {
   "timestamp": 1617531350792,
   "notebook": 92,
   "targetCells": [
    {
     "cell": "c.270.1",
     "changeType": "edited",
     "output": [
      "o.173.0"
     ],
     "index": 21
    }
   ]
  },
  {
   "timestamp": 1617531355599,
   "notebook": 93,
   "targetCells": [
    {
     "cell": "c.270.2",
     "changeType": "edited",
     "output": [
      "o.174.0"
     ],
     "index": 21
    }
   ]
  },
  {
   "timestamp": 1617531362078,
   "notebook": 94,
   "targetCells": [
    {
     "cell": "c.270.3",
     "changeType": "edited",
     "output": [
      "o.175.0"
     ],
     "index": 21
    }
   ]
  },
  {
   "timestamp": 1617617991364,
   "notebook": 95,
   "targetCells": [
    {
     "cell": "m.196.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "c.282.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "m.197.0",
     "changeType": "added",
     "index": 22
    },
    {
     "cell": "c.283.0",
     "changeType": "added",
     "index": 23
    },
    {
     "cell": "c.284.0",
     "changeType": "added",
     "index": 117
    }
   ]
  },
  {
   "timestamp": 1618221393623,
   "notebook": 96,
   "targetCells": [
    {
     "cell": "c.285.0",
     "changeType": "added",
     "index": 117
    }
   ]
  },
  {
   "timestamp": 1618238458279,
   "notebook": 97,
   "targetCells": [
    {
     "cell": "m.195.1",
     "changeType": "edited",
     "index": 116
    }
   ]
  },
  {
   "timestamp": 1618239400984,
   "notebook": 98,
   "targetCells": [
    {
     "cell": "m.195.2",
     "changeType": "edited",
     "index": 116
    }
   ]
  },
  {
   "timestamp": 1618239409109,
   "notebook": 99,
   "targetCells": [
    {
     "cell": "m.195.3",
     "changeType": "edited",
     "index": 116
    }
   ]
  },
  {
   "timestamp": 1618239457092,
   "notebook": 100,
   "targetCells": [
    {
     "cell": "m.195.4",
     "changeType": "edited",
     "index": 116
    }
   ]
  },
  {
   "timestamp": 1618239470410,
   "notebook": 101,
   "targetCells": [
    {
     "cell": "m.195.5",
     "changeType": "edited",
     "index": 116
    }
   ]
  },
  {
   "timestamp": 1618320018172,
   "notebook": 102,
   "targetCells": [
    {
     "cell": "m.198.0",
     "changeType": "added",
     "index": 81
    },
    {
     "cell": "m.199.0",
     "changeType": "added",
     "index": 108
    },
    {
     "cell": "c.286.0",
     "changeType": "added",
     "index": 109
    },
    {
     "cell": "c.287.0",
     "changeType": "added",
     "index": 119
    }
   ]
  },
  {
   "timestamp": 1618400989368,
   "notebook": 103,
   "targetCells": [
    {
     "cell": "c.201.1",
     "changeType": "edited",
     "output": [
      "o.179.0"
     ],
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1618400997236,
   "notebook": 104,
   "targetCells": [
    {
     "cell": "c.201.2",
     "changeType": "edited",
     "output": [
      "o.180.0"
     ],
     "index": 8
    }
   ]
  }
 ],
 "notebook": {
  "artifact_name": "n.0",
  "versions": [
   {
    "start_checkpoint": 1616494114891,
    "cells": [
     "c.0.0"
    ]
   },
   {
    "start_checkpoint": 1616498720192,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.0",
     "c.2.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616498746783,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616498750386,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.1",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499297669,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.2",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499338360,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.3",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499351465,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.4",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499363054,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.5",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499535627,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.6",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499708833,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.7",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499721636,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.8",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499741207,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.9",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499753498,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.10",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499759459,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.11",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499788013,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.12",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499833466,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.13",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499841067,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.14",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499849985,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.15",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499858509,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.16",
     "c.11.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499890349,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.17",
     "c.11.1",
     "c.12.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499917417,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.17",
     "c.11.2",
     "c.12.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499923231,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.17",
     "c.11.3",
     "c.13.0",
     "c.12.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499976555,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.17",
     "c.11.4",
     "c.13.1",
     "c.12.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616499993393,
    "cells": [
     "m.0.0",
     "c.1.0",
     "m.1.17",
     "c.11.5",
     "c.13.1",
     "c.12.0",
     "m.2.0",
     "c.3.0",
     "m.3.0",
     "c.4.0",
     "m.4.0",
     "c.5.0",
     "m.5.0",
     "c.6.0",
     "m.6.0",
     "c.7.0",
     "c.8.0",
     "c.9.0",
     "c.10.0"
    ]
   },
   {
    "start_checkpoint": 1616500415041,
    "cells": [
     "m.0.0",
     "c.14.0",
     "m.7.0",
     "c.11.6",
     "c.13.1",
     "c.15.0",
     "m.2.0",
     "c.16.0",
     "m.3.0",
     "c.17.0",
     "m.4.0",
     "c.18.0",
     "m.5.0",
     "c.19.0",
     "m.6.0",
     "c.20.0",
     "c.21.0",
     "c.22.0",
     "c.23.0"
    ]
   },
   {
    "start_checkpoint": 1616506614841,
    "cells": [
     "m.0.0",
     "c.24.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.2.0",
     "c.27.0",
     "m.3.0",
     "c.28.0",
     "m.4.0",
     "c.29.0",
     "m.5.0",
     "c.30.0",
     "m.6.0",
     "c.31.0",
     "c.32.0",
     "c.33.0",
     "c.34.0"
    ]
   },
   {
    "start_checkpoint": 1616506989218,
    "cells": [
     "m.0.0",
     "c.24.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.2.1",
     "c.27.0",
     "m.3.0",
     "c.28.0",
     "m.4.0",
     "c.29.0",
     "m.5.0",
     "c.30.0",
     "m.6.0",
     "c.31.0",
     "c.32.0",
     "c.33.0",
     "c.34.0"
    ]
   },
   {
    "start_checkpoint": 1616506999849,
    "cells": [
     "m.0.0",
     "c.24.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.2.2",
     "c.27.0",
     "m.3.0",
     "c.28.0",
     "m.4.0",
     "c.29.0",
     "m.5.0",
     "c.30.0",
     "m.6.0",
     "c.31.0",
     "c.32.0",
     "c.33.0",
     "c.34.0"
    ]
   },
   {
    "start_checkpoint": 1616507058313,
    "cells": [
     "m.0.0",
     "c.24.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.2.3",
     "c.27.1",
     "m.3.0",
     "c.28.0",
     "m.4.0",
     "c.29.0",
     "m.5.0",
     "c.30.0",
     "m.6.0",
     "c.31.0",
     "c.32.0",
     "c.33.0",
     "c.34.0"
    ]
   },
   {
    "start_checkpoint": 1616507159625,
    "cells": [
     "m.0.0",
     "c.24.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.2.3",
     "c.27.2",
     "m.3.0",
     "c.28.0",
     "m.4.0",
     "c.29.0",
     "m.5.0",
     "c.30.0",
     "m.6.0",
     "c.31.0",
     "c.32.0",
     "c.33.0",
     "c.34.0"
    ]
   },
   {
    "start_checkpoint": 1616585203580,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.0",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585226477,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.1",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585354080,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.2",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585364359,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.3",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585371315,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.4",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585377369,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.5",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585399297,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.6",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585434963,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.7",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585502579,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.8",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585508540,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.9",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585527352,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.10",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585537972,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.11",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585543966,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.0",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616585916649,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.1",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616586162282,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.2",
     "c.46.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616586218316,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.3",
     "c.46.0",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616586254771,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.4",
     "c.46.1",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616586320819,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.4",
     "c.46.2",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616586339268,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.5",
     "c.46.3",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616586523308,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.6",
     "c.46.3",
     "m.3.0",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616591319024,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.6",
     "c.46.3",
     "m.3.1",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616591680074,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.6",
     "c.46.3",
     "m.3.2",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616591687488,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.6",
     "c.46.3",
     "m.3.3",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616591708423,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.6",
     "c.46.3",
     "m.3.4",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616591715143,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.6",
     "c.46.3",
     "m.3.5",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616591723947,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.6",
     "c.46.3",
     "m.3.6",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616591732014,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.6",
     "c.46.3",
     "m.3.7",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616591886115,
    "cells": [
     "m.0.0",
     "c.35.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.14.12",
     "m.15.6",
     "c.46.3",
     "m.3.8",
     "c.39.0",
     "m.4.0",
     "c.40.0",
     "m.5.0",
     "c.41.0",
     "m.6.0",
     "c.42.0",
     "c.43.0",
     "c.44.0",
     "c.45.0"
    ]
   },
   {
    "start_checkpoint": 1616763894011,
    "cells": [
     "m.0.0",
     "c.47.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.16.0",
     "c.48.0",
     "c.49.0",
     "m.17.0",
     "c.46.3",
     "m.18.0",
     "c.50.0",
     "m.19.0",
     "c.51.0",
     "m.20.0",
     "c.52.0",
     "m.21.0",
     "c.53.0",
     "m.22.0",
     "m.23.0",
     "c.54.0",
     "m.24.0",
     "c.55.0",
     "m.25.0",
     "c.56.0",
     "m.26.0",
     "c.57.0",
     "m.27.0",
     "c.58.0",
     "m.28.0",
     "c.59.0",
     "m.29.0",
     "c.60.0",
     "m.30.0",
     "c.61.0",
     "c.62.0",
     "m.31.0",
     "c.63.0",
     "m.32.0",
     "c.64.0",
     "m.33.0",
     "c.65.0",
     "m.34.0",
     "c.66.0",
     "m.5.0",
     "c.67.0",
     "m.6.0",
     "c.68.0",
     "c.69.0",
     "c.70.0",
     "c.71.0"
    ]
   },
   {
    "start_checkpoint": 1616764358932,
    "cells": [
     "m.0.0",
     "c.47.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.10.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.16.0",
     "c.48.0",
     "c.49.0",
     "m.17.0",
     "c.46.3",
     "m.18.0",
     "c.50.0",
     "m.19.0",
     "c.51.0",
     "m.20.0",
     "c.52.0",
     "m.21.0",
     "c.53.0",
     "m.22.0",
     "m.23.0",
     "c.54.0",
     "m.24.0",
     "c.55.0",
     "m.25.0",
     "c.56.0",
     "m.26.0",
     "c.57.0",
     "m.27.0",
     "c.58.0",
     "m.28.0",
     "c.59.0",
     "m.29.0",
     "c.60.0",
     "m.30.0",
     "c.61.0",
     "c.62.0",
     "m.31.0",
     "c.63.0",
     "m.32.0",
     "c.64.0",
     "m.33.0",
     "c.65.0",
     "m.34.0",
     "c.66.0",
     "m.5.0",
     "c.67.0",
     "c.72.0",
     "m.6.0",
     "c.68.0",
     "c.69.0",
     "c.70.0",
     "c.71.0"
    ]
   },
   {
    "start_checkpoint": 1616856887897,
    "cells": [
     "m.0.0",
     "c.73.0",
     "m.8.0",
     "c.25.0",
     "c.13.1",
     "m.9.0",
     "c.26.0",
     "m.35.0",
     "c.74.0",
     "m.11.0",
     "c.36.0",
     "m.12.1",
     "c.37.0",
     "m.13.0",
     "c.38.0",
     "m.16.0",
     "c.48.0",
     "c.49.0",
     "m.17.0",
     "c.46.3",
     "m.18.0",
     "c.50.0",
     "m.19.0",
     "c.51.0",
     "m.20.0",
     "c.52.0",
     "m.21.0",
     "c.53.0",
     "m.22.0",
     "m.23.0",
     "c.54.0",
     "m.24.0",
     "c.55.0",
     "m.25.0",
     "c.56.0",
     "m.26.0",
     "c.57.0",
     "m.27.0",
     "c.58.0",
     "m.28.0",
     "c.59.0",
     "m.29.0",
     "c.60.0",
     "m.30.0",
     "c.61.0",
     "c.62.0",
     "m.31.0",
     "c.63.0",
     "m.32.0",
     "c.64.0",
     "m.33.0",
     "c.65.0",
     "m.34.0",
     "c.66.0",
     "m.36.0",
     "c.75.0",
     "m.37.0",
     "m.38.0",
     "c.76.0",
     "c.77.0",
     "m.39.0",
     "m.40.0",
     "c.78.0",
     "c.79.0",
     "m.41.0",
     "c.80.0",
     "m.42.0",
     "c.81.0",
     "c.82.0",
     "m.43.0",
     "m.44.0",
     "m.45.0",
     "c.83.0",
     "m.46.0",
     "m.47.0",
     "c.84.0",
     "m.48.0",
     "c.85.0",
     "m.49.0",
     "c.86.0",
     "m.50.0",
     "c.87.0",
     "m.51.0",
     "c.88.0",
     "m.52.0",
     "c.89.0",
     "m.53.0",
     "c.90.0",
     "m.54.0",
     "c.91.0",
     "m.55.0",
     "c.92.0",
     "m.56.0",
     "c.93.0",
     "m.57.0",
     "c.94.0",
     "m.58.0",
     "c.95.0",
     "m.59.0",
     "c.96.0"
    ]
   },
   {
    "start_checkpoint": 1616857853381,
    "cells": [
     "m.60.0",
     "c.97.0",
     "m.61.0",
     "m.62.0",
     "m.63.0",
     "m.64.0",
     "m.65.0",
     "m.66.0",
     "m.67.0",
     "m.68.0",
     "m.69.0",
     "m.70.0",
     "m.71.0",
     "m.72.0",
     "m.73.0",
     "m.74.0",
     "m.75.0",
     "m.76.0",
     "m.77.0",
     "m.78.0",
     "m.79.0",
     "m.80.0",
     "m.81.0",
     "m.82.0",
     "m.83.0",
     "m.84.0",
     "m.85.0",
     "m.86.0",
     "m.87.0",
     "m.88.0",
     "m.89.0",
     "m.90.0",
     "m.91.0",
     "m.92.0",
     "m.93.0",
     "m.94.0",
     "m.95.0",
     "m.96.0",
     "m.97.0",
     "m.98.0",
     "m.99.0",
     "m.100.0",
     "m.101.0",
     "m.102.0",
     "m.103.0",
     "m.104.0",
     "m.105.0",
     "m.106.0",
     "m.107.0",
     "m.108.0",
     "m.109.0",
     "c.98.0"
    ]
   },
   {
    "start_checkpoint": 1616857853619,
    "cells": [
     "m.60.0",
     "c.97.0",
     "m.61.0",
     "c.99.0",
     "c.100.0",
     "m.62.0",
     "c.101.0",
     "m.63.0",
     "c.102.0",
     "m.64.0",
     "c.103.0",
     "m.65.0",
     "c.104.0",
     "m.66.0",
     "c.105.0",
     "m.67.0",
     "c.106.0",
     "c.107.0",
     "m.68.0",
     "c.108.0",
     "m.69.0",
     "c.109.0",
     "m.70.0",
     "c.110.0",
     "m.71.1",
     "c.111.0",
     "m.72.0",
     "c.112.0",
     "m.73.0",
     "m.74.0",
     "c.113.0",
     "m.75.0",
     "c.114.0",
     "m.76.0",
     "c.115.0",
     "m.77.0",
     "c.116.0",
     "m.78.0",
     "c.117.0",
     "m.79.0",
     "c.118.0",
     "m.80.0",
     "c.119.0",
     "m.81.0",
     "c.120.0",
     "c.121.0",
     "m.82.0",
     "c.122.0",
     "m.83.0",
     "c.123.0",
     "m.84.0",
     "c.124.0",
     "m.85.0",
     "c.125.0",
     "m.86.0",
     "c.126.0",
     "m.87.0",
     "m.88.0",
     "c.127.0",
     "c.128.0",
     "m.89.0",
     "m.90.0",
     "c.129.0",
     "c.130.0",
     "m.91.0",
     "c.131.0",
     "m.92.0",
     "c.132.0",
     "c.133.0",
     "m.93.0",
     "m.94.0",
     "m.95.0",
     "c.134.0",
     "m.96.0",
     "m.97.0",
     "c.135.0",
     "m.98.0",
     "c.136.0",
     "m.99.0",
     "c.137.0",
     "m.100.0",
     "c.138.0",
     "m.101.0",
     "c.139.0",
     "m.102.0",
     "c.140.0",
     "m.103.0",
     "c.141.0",
     "m.104.0",
     "c.142.0",
     "m.105.0",
     "c.143.0",
     "m.106.0",
     "c.144.0",
     "m.107.0",
     "c.145.0",
     "m.108.0",
     "c.146.0",
     "m.109.0",
     "c.98.0"
    ]
   },
   {
    "start_checkpoint": 1616857990572,
    "cells": [
     "m.60.0",
     "c.97.0",
     "m.61.0",
     "c.99.0",
     "c.100.0",
     "m.62.0",
     "c.101.0",
     "m.63.0",
     "c.102.0",
     "m.64.0",
     "c.103.0",
     "m.65.0",
     "c.104.0",
     "m.66.0",
     "c.105.0",
     "m.67.0",
     "c.106.0",
     "c.107.0",
     "m.68.0",
     "c.108.0",
     "m.69.0",
     "c.109.0",
     "m.70.0",
     "c.110.0",
     "m.71.2",
     "c.111.0",
     "m.72.0",
     "c.112.0",
     "m.73.0",
     "m.74.0",
     "c.113.0",
     "m.75.0",
     "c.114.0",
     "m.76.0",
     "c.115.0",
     "m.77.0",
     "c.116.0",
     "m.78.0",
     "c.117.0",
     "m.79.0",
     "c.118.0",
     "m.80.0",
     "c.119.0",
     "m.81.0",
     "c.120.0",
     "c.121.0",
     "m.82.0",
     "c.122.0",
     "m.83.0",
     "c.123.0",
     "m.84.0",
     "c.124.0",
     "m.85.0",
     "c.125.0",
     "m.86.0",
     "c.126.0",
     "m.87.0",
     "m.88.0",
     "c.127.0",
     "c.128.0",
     "m.89.0",
     "m.90.0",
     "c.129.0",
     "c.130.0",
     "m.91.0",
     "c.131.0",
     "m.92.0",
     "c.132.0",
     "c.133.0",
     "m.93.0",
     "m.94.0",
     "m.95.0",
     "c.134.0",
     "m.96.0",
     "m.97.0",
     "c.135.0",
     "m.98.0",
     "c.136.0",
     "m.99.0",
     "c.137.0",
     "m.100.0",
     "c.138.0",
     "m.101.0",
     "c.139.0",
     "m.102.0",
     "c.140.0",
     "m.103.0",
     "c.141.0",
     "m.104.0",
     "c.142.0",
     "m.105.0",
     "c.143.0",
     "m.106.0",
     "c.144.0",
     "m.107.0",
     "c.145.0",
     "m.108.0",
     "c.146.0",
     "m.109.0",
     "c.98.0"
    ]
   },
   {
    "start_checkpoint": 1616858001954,
    "cells": [
     "m.60.0",
     "c.97.0",
     "m.61.0",
     "c.99.0",
     "c.100.0",
     "m.62.0",
     "c.101.0",
     "m.63.0",
     "c.102.0",
     "m.64.0",
     "c.103.0",
     "m.65.0",
     "c.104.0",
     "m.66.0",
     "c.105.0",
     "m.67.0",
     "c.106.0",
     "c.107.0",
     "m.68.0",
     "c.108.0",
     "m.69.0",
     "c.109.0",
     "m.70.0",
     "c.110.0",
     "m.71.4",
     "c.111.0",
     "m.72.0",
     "c.112.0",
     "m.73.0",
     "m.74.0",
     "c.113.0",
     "m.75.0",
     "c.114.0",
     "m.76.0",
     "c.115.0",
     "m.77.0",
     "c.116.0",
     "m.78.0",
     "c.117.0",
     "m.79.0",
     "c.118.0",
     "m.80.0",
     "c.119.0",
     "m.81.0",
     "c.120.0",
     "c.121.0",
     "m.82.0",
     "c.122.0",
     "m.83.0",
     "c.123.0",
     "m.84.0",
     "c.124.0",
     "m.85.0",
     "c.125.0",
     "m.86.0",
     "c.126.0",
     "m.87.0",
     "m.88.0",
     "c.127.0",
     "c.128.0",
     "m.89.0",
     "m.90.0",
     "c.129.0",
     "c.130.0",
     "m.91.0",
     "c.131.0",
     "m.92.0",
     "c.132.0",
     "c.133.0",
     "m.93.0",
     "m.94.0",
     "m.95.0",
     "c.134.0",
     "m.96.0",
     "m.97.0",
     "c.135.0",
     "m.98.0",
     "c.136.0",
     "m.99.0",
     "c.137.0",
     "m.100.0",
     "c.138.0",
     "m.101.0",
     "c.139.0",
     "m.102.0",
     "c.140.0",
     "m.103.0",
     "c.141.0",
     "m.104.0",
     "c.142.0",
     "m.105.0",
     "c.143.0",
     "m.106.0",
     "c.144.0",
     "m.107.0",
     "c.145.0",
     "m.108.0",
     "c.146.0",
     "m.109.0",
     "c.98.0"
    ]
   },
   {
    "start_checkpoint": 1616858010596,
    "cells": [
     "m.60.0",
     "c.97.0",
     "m.61.0",
     "c.99.0",
     "c.100.0",
     "m.62.0",
     "c.101.0",
     "m.63.0",
     "c.102.0",
     "m.64.0",
     "c.103.0",
     "m.65.0",
     "c.104.0",
     "m.66.0",
     "c.105.0",
     "m.67.0",
     "c.106.0",
     "c.107.0",
     "m.68.0",
     "c.108.0",
     "m.69.0",
     "c.109.0",
     "m.70.0",
     "c.110.0",
     "m.71.6",
     "c.111.0",
     "m.72.0",
     "c.112.0",
     "m.73.0",
     "m.74.0",
     "c.113.0",
     "m.75.0",
     "c.114.0",
     "m.76.0",
     "c.115.0",
     "m.77.0",
     "c.116.0",
     "m.78.0",
     "c.117.0",
     "m.79.0",
     "c.118.0",
     "m.80.0",
     "c.119.0",
     "m.81.0",
     "c.120.0",
     "c.121.0",
     "m.82.0",
     "c.122.0",
     "m.83.0",
     "c.123.0",
     "m.84.0",
     "c.124.0",
     "m.85.0",
     "c.125.0",
     "m.86.0",
     "c.126.0",
     "m.87.0",
     "m.88.0",
     "c.127.0",
     "c.128.0",
     "m.89.0",
     "m.90.0",
     "c.129.0",
     "c.130.0",
     "m.91.0",
     "c.131.0",
     "m.92.0",
     "c.132.0",
     "c.133.0",
     "m.93.0",
     "m.94.0",
     "m.95.0",
     "c.134.0",
     "m.96.0",
     "m.97.0",
     "c.135.0",
     "m.98.0",
     "c.136.0",
     "m.99.0",
     "c.137.0",
     "m.100.0",
     "c.138.0",
     "m.101.0",
     "c.139.0",
     "m.102.0",
     "c.140.0",
     "m.103.0",
     "c.141.0",
     "m.104.0",
     "c.142.0",
     "m.105.0",
     "c.143.0",
     "m.106.0",
     "c.144.0",
     "m.107.0",
     "c.145.0",
     "m.108.0",
     "c.146.0",
     "m.109.0",
     "c.98.0"
    ]
   },
   {
    "start_checkpoint": 1616858354622,
    "cells": [
     "m.110.0",
     "c.147.0",
     "m.111.0",
     "m.112.0",
     "m.113.0",
     "m.114.0",
     "m.115.0",
     "m.116.0",
     "m.117.0",
     "m.118.0",
     "m.119.0",
     "m.120.0",
     "m.121.0",
     "m.122.0",
     "m.123.0",
     "m.124.0",
     "m.125.0",
     "m.126.0",
     "m.127.0",
     "m.128.0",
     "m.129.0",
     "m.130.0",
     "m.131.0",
     "m.132.0",
     "m.133.0",
     "m.134.0",
     "m.135.0",
     "m.136.0",
     "m.137.0",
     "m.138.0",
     "m.139.0",
     "m.140.0",
     "m.141.0",
     "m.142.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "m.146.0",
     "m.147.0",
     "m.148.0",
     "m.149.0",
     "m.150.0",
     "m.151.0",
     "m.152.0",
     "m.153.0",
     "m.154.0",
     "m.155.0",
     "m.156.0",
     "m.157.0",
     "m.158.0",
     "m.159.0",
     "c.148.0"
    ]
   },
   {
    "start_checkpoint": 1616859134396,
    "cells": [
     "m.110.0",
     "c.197.0",
     "m.111.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.113.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.0",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.0",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.227.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.160.0",
     "c.246.0"
    ]
   },
   {
    "start_checkpoint": 1616859318783,
    "cells": [
     "m.110.0",
     "c.247.0",
     "m.111.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.113.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.0",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.0",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.227.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.0",
     "c.248.0"
    ]
   },
   {
    "start_checkpoint": 1616859333029,
    "cells": [
     "m.110.0",
     "c.249.0",
     "m.111.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.113.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.0",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.0",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.227.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.0",
     "c.248.0"
    ]
   },
   {
    "start_checkpoint": 1616860423327,
    "cells": [
     "m.110.0",
     "c.250.0",
     "m.111.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.113.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.0",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.0",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.227.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.0",
     "c.251.0"
    ]
   },
   {
    "start_checkpoint": 1616861593906,
    "cells": [
     "m.110.0",
     "c.250.0",
     "m.111.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.113.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.0",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.227.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.251.0"
    ]
   },
   {
    "start_checkpoint": 1617006907566,
    "cells": [
     "m.110.0",
     "c.252.0",
     "m.111.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.113.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.0",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.227.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.253.0"
    ]
   },
   {
    "start_checkpoint": 1617008269323,
    "cells": [
     "m.110.0",
     "c.252.0",
     "m.111.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.113.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.1",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.227.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.253.0"
    ]
   },
   {
    "start_checkpoint": 1617008281926,
    "cells": [
     "m.110.0",
     "c.252.0",
     "m.111.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.113.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.2",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.227.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.253.0"
    ]
   },
   {
    "start_checkpoint": 1617008296329,
    "cells": [
     "m.110.0",
     "c.252.0",
     "m.111.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.113.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.3",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.227.1",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.253.0"
    ]
   },
   {
    "start_checkpoint": 1617025435363,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.0",
     "c.198.0",
     "c.199.0",
     "m.112.0",
     "c.200.0",
     "m.164.0",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.3",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.255.0"
    ]
   },
   {
    "start_checkpoint": 1617025559423,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.1",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.3",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.255.0"
    ]
   },
   {
    "start_checkpoint": 1617025660878,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.2",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.3",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.255.0"
    ]
   },
   {
    "start_checkpoint": 1617025751985,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.3",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.3",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.255.0"
    ]
   },
   {
    "start_checkpoint": 1617025756251,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.4",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.3",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.255.0"
    ]
   },
   {
    "start_checkpoint": 1617025773471,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.5",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.3",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.255.0"
    ]
   },
   {
    "start_checkpoint": 1617025783710,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.6",
     "c.201.0",
     "m.114.0",
     "c.202.0",
     "m.115.3",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.255.0"
    ]
   },
   {
    "start_checkpoint": 1617025822464,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "c.256.0",
     "m.114.0",
     "c.202.0",
     "m.115.3",
     "c.203.0",
     "m.116.0",
     "c.204.0",
     "m.117.0",
     "c.205.0",
     "c.206.0",
     "m.118.0",
     "c.207.0",
     "m.119.0",
     "c.208.0",
     "m.120.0",
     "c.209.0",
     "m.121.0",
     "c.210.0",
     "m.122.0",
     "c.211.0",
     "m.123.0",
     "m.124.0",
     "c.212.0",
     "m.125.1",
     "c.213.0",
     "m.126.0",
     "c.214.0",
     "m.127.0",
     "c.215.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.0",
     "m.144.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.161.1",
     "c.255.0"
    ]
   },
   {
    "start_checkpoint": 1617374393763,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.144.1",
     "c.268.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.181.0",
     "c.267.0"
    ]
   },
   {
    "start_checkpoint": 1617374715728,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.144.1",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.181.0",
     "c.267.0"
    ]
   },
   {
    "start_checkpoint": 1617374727891,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.144.1",
     "c.269.0",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.181.0",
     "c.267.0"
    ]
   },
   {
    "start_checkpoint": 1617374738478,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.144.1",
     "c.269.1",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.181.0",
     "c.267.0"
    ]
   },
   {
    "start_checkpoint": 1617374793459,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.144.1",
     "c.269.2",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.181.0",
     "c.267.0"
    ]
   },
   {
    "start_checkpoint": 1617374818127,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.144.1",
     "c.269.3",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.181.0",
     "c.267.0"
    ]
   },
   {
    "start_checkpoint": 1617374831543,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.144.1",
     "c.269.4",
     "m.145.0",
     "c.233.0",
     "m.146.0",
     "m.147.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.149.0",
     "c.236.0",
     "m.150.0",
     "c.237.0",
     "m.151.0",
     "c.238.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.240.0",
     "m.154.0",
     "c.241.0",
     "m.155.0",
     "c.242.0",
     "m.156.0",
     "c.243.0",
     "m.157.0",
     "c.244.0",
     "m.158.0",
     "c.245.0",
     "m.181.0",
     "c.267.0"
    ]
   },
   {
    "start_checkpoint": 1617531200343,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.182.0",
     "c.270.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.0",
     "c.281.0"
    ]
   },
   {
    "start_checkpoint": 1617531350792,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.182.0",
     "c.270.1",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.0",
     "c.281.0"
    ]
   },
   {
    "start_checkpoint": 1617531355599,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.182.0",
     "c.270.2",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.0",
     "c.281.0"
    ]
   },
   {
    "start_checkpoint": 1617531362078,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.182.0",
     "c.270.3",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.0",
     "c.281.0"
    ]
   },
   {
    "start_checkpoint": 1617617991364,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.0",
     "c.284.0"
    ]
   },
   {
    "start_checkpoint": 1618221393623,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.0",
     "c.285.0"
    ]
   },
   {
    "start_checkpoint": 1618238458279,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.1",
     "c.285.0"
    ]
   },
   {
    "start_checkpoint": 1618239400984,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.2",
     "c.285.0"
    ]
   },
   {
    "start_checkpoint": 1618239409109,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.3",
     "c.285.0"
    ]
   },
   {
    "start_checkpoint": 1618239457092,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.4",
     "c.285.0"
    ]
   },
   {
    "start_checkpoint": 1618239470410,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.192.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.5",
     "c.285.0"
    ]
   },
   {
    "start_checkpoint": 1618320018172,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.0",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.198.0",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.199.0",
     "c.286.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.5",
     "c.287.0"
    ]
   },
   {
    "start_checkpoint": 1618400989368,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.1",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.198.0",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.199.0",
     "c.286.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.5",
     "c.287.0"
    ]
   },
   {
    "start_checkpoint": 1618400997236,
    "cells": [
     "m.162.0",
     "m.110.0",
     "m.163.1",
     "c.198.0",
     "c.199.0",
     "m.112.1",
     "c.200.0",
     "m.164.7",
     "c.201.2",
     "m.165.0",
     "m.166.0",
     "c.202.0",
     "m.167.0",
     "c.203.0",
     "m.168.0",
     "m.169.0",
     "c.257.0",
     "m.170.0",
     "c.205.0",
     "c.258.0",
     "m.196.0",
     "c.282.0",
     "m.197.0",
     "c.283.0",
     "m.171.0",
     "c.207.0",
     "m.172.0",
     "c.208.0",
     "m.173.0",
     "c.259.0",
     "m.174.0",
     "c.260.0",
     "m.175.0",
     "c.261.0",
     "m.176.0",
     "c.211.0",
     "m.123.0",
     "m.177.0",
     "c.262.0",
     "m.178.0",
     "c.263.0",
     "m.126.0",
     "c.264.0",
     "m.179.0",
     "c.215.0",
     "m.180.0",
     "c.265.0",
     "c.266.0",
     "m.128.0",
     "c.216.0",
     "m.129.0",
     "c.217.0",
     "m.130.0",
     "c.218.0",
     "m.131.0",
     "c.219.0",
     "c.220.0",
     "m.132.0",
     "c.221.0",
     "m.133.0",
     "c.222.0",
     "m.134.0",
     "c.223.0",
     "m.135.1",
     "c.224.0",
     "m.136.0",
     "c.225.0",
     "m.137.0",
     "m.138.0",
     "c.226.0",
     "c.254.0",
     "m.139.0",
     "m.140.0",
     "c.228.0",
     "c.229.0",
     "m.141.0",
     "c.230.0",
     "m.142.0",
     "c.231.0",
     "c.232.0",
     "m.143.1",
     "m.198.0",
     "m.183.0",
     "c.271.0",
     "m.184.0",
     "c.272.0",
     "m.185.0",
     "c.273.0",
     "c.274.0",
     "m.186.0",
     "c.233.0",
     "m.187.0",
     "m.188.0",
     "c.234.0",
     "m.148.0",
     "c.235.0",
     "m.189.0",
     "c.275.0",
     "m.190.0",
     "c.237.0",
     "m.151.0",
     "c.276.0",
     "m.152.0",
     "c.239.0",
     "m.153.0",
     "c.277.0",
     "m.191.0",
     "c.278.0",
     "m.199.0",
     "c.286.0",
     "m.193.0",
     "c.279.0",
     "m.156.0",
     "c.243.0",
     "m.194.0",
     "c.280.0",
     "m.158.0",
     "c.245.0",
     "m.195.5",
     "c.287.0"
    ]
   }
  ]
 },
 "codeCells": [
  {
   "output_histories": {},
   "artifact_name": "c.0",
   "versions": [
    {
     "start_checkpoint": 1616494114891,
     "parent": "n.0.0",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.1",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.0"
   },
   "artifact_name": "c.2",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "literal": "main()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 0,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.3",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.4",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.5",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.6",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.7",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.8",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.9",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.10",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "2": "o.1"
   },
   "artifact_name": "c.11",
   "versions": [
    {
     "start_checkpoint": 1616498750386,
     "parent": "n.0.3",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1616499890349,
     "parent": "n.0.19",
     "literal": "fun main(){\n    println(\"Hello World Kotlin\")\n}"
    },
    {
     "start_checkpoint": 1616499917417,
     "parent": "n.0.20",
     "literal": "fun main(){\n    println(\"Hello World Kotlin\")\n}\nmain()"
    },
    {
     "start_checkpoint": 1616499923231,
     "parent": "n.0.21",
     "literal": "main()"
    },
    {
     "start_checkpoint": 1616499976555,
     "parent": "n.0.22",
     "literal": "fun main(){\n    println(\"Hello World Kotlin\")\n}"
    },
    {
     "start_checkpoint": 1616499993393,
     "parent": "n.0.24",
     "literal": "fun main(){\n    println(\"Hello World Erik\")\n}"
    },
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "literal": "fun main(){\n    println(\"Hello World Kotlin\")\n}"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.12",
   "versions": [
    {
     "start_checkpoint": 1616499890349,
     "parent": "n.0.19",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "1": "o.2"
   },
   "artifact_name": "c.13",
   "versions": [
    {
     "start_checkpoint": 1616499923231,
     "parent": "n.0.21",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1616499976555,
     "parent": "n.0.60",
     "literal": "main()"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.14",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.15",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.16",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.17",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.18",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.19",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.20",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.21",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.22",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.23",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.24",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.25",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.60",
     "literal": "fun main(){\n    println(\"Hello World Kotlin.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.3"
   },
   "artifact_name": "c.26",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.60",
     "literal": "fun main(){\n    val name : String = \"Max\"\n    println(\"Hello World $name.\")\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "2": "o.4"
   },
   "artifact_name": "c.27",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1616507058313,
     "parent": "n.0.28",
     "literal": "val v1 = \"schreibgeschützte Variable\"\n//v1 = \"Test\"   //Fehler: Val cannot be reassigned\nvar v2 = \"veränderbare Variable\"\nv2 = \"Test\""
    },
    {
     "start_checkpoint": 1616507159625,
     "parent": "n.0.29",
     "literal": "val v1 = \"schreibgeschützte Variable\"\n//v1 = \"Test\"   //Fehler: Val cannot be reassigned\nvar v2 = \"veränderbare Variable\"\nv2 = \"Test\"\nprintln(\"$v1 - $v2\")"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.28",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.29",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.30",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.31",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.32",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.33",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.34",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.35",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.5"
   },
   "artifact_name": "c.36",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.60",
     "literal": "val v1 : String = \"schreibgeschützte Variable\"\n//v1 = \"Test\"   //Fehler: Val cannot be reassigned\nvar v2 : String = \"veränderbare Variable\"\nv2 = \"Test\"\nprintln(\"$v1 - $v2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.6"
   },
   "artifact_name": "c.37",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.60",
     "literal": "val value : Int = foo()\nprintln(value)\n\n//const val constant : Int = foo()   -> Error\nconst val constant : Int = 5       //-> Kein Error\nprintln(constant)\n\nfun foo() : Int { //Gibt eine zufällige ganze Zahl zwischen 0 und 10 zurück\n    return (0..10).random()\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.7"
   },
   "artifact_name": "c.38",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.60",
     "literal": "val int1 : Int = 5\nval int2 = 5\nprintln(\"Datentyp von v1: ${v1::class.simpleName}, Datentyp von v2: ${v2::class.simpleName}\")\n\nval string1 : String = \"String 1\"\nval string2 = \"String 2\"\nprintln(\"Datentyp von string1: ${string1::class.simpleName}, Datentyp von string2: ${string2::class.simpleName}\") ",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 113
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.8"
   },
   "artifact_name": "c.39",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.40",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.41",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.42",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.43",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.44",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.45",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "1": "o.9",
    "2": "o.10",
    "3": "o.11"
   },
   "artifact_name": "c.46",
   "versions": [
    {
     "start_checkpoint": 1616586162282,
     "parent": "n.0.44",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1616586254771,
     "parent": "n.0.46",
     "literal": "//const val PI = 3.14159f\nval a = 50\nval b = 20\nvar res : Int\nval bool = false\nres = a - b\nval output = \"a - b ist: $res .\"\nprintln(output)"
    },
    {
     "start_checkpoint": 1616586320819,
     "parent": "n.0.47",
     "literal": "//const val PI = 3.14159f\nval a = 50\nval b = 20\nvar res : Int\nval bool = false\nres = a - b\nval output = \"a - b ist: $res.\"\nprintln(output)"
    },
    {
     "start_checkpoint": 1616586339268,
     "parent": "n.0.60",
     "literal": "//const val PI = 3.14159f\nvar a = 50\nval b = 20\nvar res : Int\nval bool = false\na = a + 30\nres = a - b\nval output = \"a - b ist: $res.\"\nprintln(output)"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.47",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.58",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.12"
   },
   "artifact_name": "c.48",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "fun vergleicheElemente(a: List<Int>, b: List<Int>){\n    if (a == b) println(\"vergleicheElemente: Gleich\")\n    else println(\"vergleicheElemente: Ungleich\")\n}\nfun vergleicheSpeicher(a: List<Int>, b: List<Int>){\n    if (a === b) println(\"vergleicheSpeicher: Gleich\")\n    else println(\"vergleicheSpeicher: Ungleich\")\n}\nval a = listOf(1,2,3)\nval b = listOf(1,2,3)\nvergleicheElemente(a, b)\nvergleicheSpeicher(a, b)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 23
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.13"
   },
   "artifact_name": "c.49",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "fun vergleicheStrings(a: String, b: String){\n    if (a == b) println(\"vergleicheStrings: $a == $b\")\n    else if (a < b) println(\"vergleicheStrings: $a < $b\")\n    else println(\"vergleicheStrings: $a > $b\")\n}\nval a = \"Kotlin\"\nval b = \"Java\"\nvergleicheStrings(a,b)\nvergleicheStrings(b,a)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 21
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.14"
   },
   "artifact_name": "c.50",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "fun foo(): String{\n    return \"TEST\"\n}\n\nfun show(a: String){\n    println(a)\n}\n\nfun main(){\n    val a = foo()\n    show(a)\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.15"
   },
   "artifact_name": "c.51",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "fun foo(a: Int = 0, b: Int = 0, c: Int = 0, d:Int = 0) {\n    println(\"a: $a, b: $b, c: $c, d: $d\")\n}\nfoo(1,2,1,2)\nfoo(1,2)\nfoo()\nfoo(b=2,d=2)\n//foo(b=2,d=2, 3, 4) -> Error: Mixing named and positioned arguments is not allowed",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 82
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.16"
   },
   "artifact_name": "c.52",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "fun sum(a: Int, b: Int) = a+b\nprintln(sum(5,5))\n\nfun foo(num: Int) = if (num == 42) 42 else 0\nprintln(foo(42))\nprintln(foo(24))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.17"
   },
   "artifact_name": "c.53",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "fun sum(a: Int, b: Int) = println(\"Sum mit 2 Int-Parametern: ${a+b}\")\nfun sum(a: Int, b: Int, c: Int) = println(\"Sum mit 3 Int-Parametern: ${a+b+c}\")\nfun sum(a: Double, b: Double) = println(\"Sum mit 2 Double-Parametern: ${a+b}\")\nsum(2,3)\nsum(2,3,4)\nsum(2.0,3.0)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 11
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.18"
   },
   "artifact_name": "c.54",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "fun foo(a: Int): String {\n    val res = if (a < 10) \n                  \"kleiner 10\"\n              else if (a == 10) \n                  \"gleich 10\"\n              else \n                  \"groeßer 10\"\n    return res\n}\nfun foo2(a: Int): String {\n    return if (a < 10) \n               \"kleiner 10\"\n           else if (a == 10) \n               \"gleich 10\"\n           else \n               \"groeßer 10\"\n}\nfun foo3(a: Int) = if (a < 10) \n                       \"kleiner 10\"\n                   else if (a == 10) \n                       \"gleich 10\"\n                   else \n                       \"groeßer 10\"\nval a = 10\nprintln(foo(a))\nprintln(foo2(a))\nprintln(foo3(a))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 26,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.19"
   },
   "artifact_name": "c.55",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "val c = 'ä'\nwhen (c) {\n    'a', 'e', 'i', 'o', 'u' -> println(\"Vokal\")\n    'ä', 'ö', 'ü' -> {\n                        val res = \"Umlaut\"\n                        println(res)\n                     }\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> println(\"Zahl\")\n    else -> println(\"Kostante\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.20"
   },
   "artifact_name": "c.56",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "val a: Any = 0\nval liste = listOf(0, 1, 2, 3)\nwhen (a) {\n    is Double -> println(\"$a ist vom Datentyp Double\")\n    is Long -> println(\"$a ist vom Datentyp Long\")\n    in liste -> println(\"$a ist in Liste $liste\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.21"
   },
   "artifact_name": "c.57",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "val a = 10\nwhen {\n    a == 10 -> println(\"gleich 10\")\n    a < 10 -> println(\"kleiner 10\")\n    else -> println(\"groeßer 10\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.22"
   },
   "artifact_name": "c.58",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "val intBereich = 0..10 //Bereich von 0 - 10\nprintln(\"Der Bereich $intBereich vom Typ ${intBereich::class.simpleName} geht von ${intBereich.first} bis ${intBereich.last} und umfasst ${intBereich.toList()}\")\n\nval start = 5\nval intBereichMitVariable = start..start+5 //Bereich von start bis start+5\nprintln(\"Der Bereich $intBereichMitVariable vom Typ ${intBereichMitVariable::class.simpleName} geht von ${intBereichMitVariable.first} bis ${intBereichMitVariable.last} und umfasst ${intBereichMitVariable.toList()}\")\n\nval charBereich = 'a'..'e' //Bereich von a bis e\nprintln(\"Der Bereich $charBereich vom Typ ${charBereich::class.simpleName} geht von ${charBereich.first} bis ${charBereich.last} und umfasst ${charBereich.toList()}\")\n\nval intBereichUntil = 0 until 10 //Bereich von 0 - 9\nprintln(\"Der Bereich $intBereichUntil vom Typ ${intBereichUntil::class.simpleName} geht von ${intBereichUntil.first} bis ${intBereichUntil.last} und umfasst ${intBereichUntil.toList()}\")\n\nvar umgekehrterIntBereich = 10 downTo 0 //Bereich von 10 - 0\nprintln(\"Der Bereich $umgekehrterIntBereich vom Typ ${umgekehrterIntBereich::class.simpleName} geht von ${umgekehrterIntBereich.first} bis ${umgekehrterIntBereich.last} und umfasst ${umgekehrterIntBereich.toList()}\")\n\nval intBereichSchrittweite = 0..10 step 2 //Bereich von 0 - 10 mit Schrittweite 2\nprintln(\"Der Bereich $intBereichSchrittweite vom Typ ${intBereichSchrittweite::class.simpleName} geht von ${intBereichSchrittweite.first} bis ${intBereichSchrittweite.last} und umfasst ${intBereichSchrittweite.toList()}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 17,
      "ch": 220
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.23"
   },
   "artifact_name": "c.59",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "for (i in 0..10){\n    print(\"$i \")\n}\nprintln()\nfor (i in 0 until 20){\n    print(\"$i \")\n}\nprintln()\nfor (i in 15 downTo 5 step 5){\n    print(\"$i \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.24"
   },
   "artifact_name": "c.60",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "val liste = listOf(\"Kotlin\", \"Java\", \"C\", \"Python\")\nfor (i in liste){\n    print(\"$i \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.25"
   },
   "artifact_name": "c.61",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor (i in liste){\n    i = i*i\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.26"
   },
   "artifact_name": "c.62",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor (i in 0 until liste.size){\n    liste[i] = liste[i] * liste[i]\n}\nprintln(liste)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 13
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.27"
   },
   "artifact_name": "c.63",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor ((index, element) in liste.withIndex()){\n    println(\"An Stelle $index ist $element gespeichert\")\n    liste[index] = element * element\n}\nprintln(liste)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 13
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.28"
   },
   "artifact_name": "c.64",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "val liste1 = (0..100 step 11).toList()\nval liste2 = (0..100 step 5).toList()\niloop@\nfor (i in liste1){\n    println(\"Aktuell untersucht: $i\")\n    for(j in liste2){\n        if(i == j && i != 0){\n            println(\"Gefunden $i\")\n            break@iloop\n        }\n    }\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.29"
   },
   "artifact_name": "c.65",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "var i = 0\nwhile (i<=10){\n    print(\"$i \")\n    i++\n}\ndo {\n    print(\"$i \")\n    i--\n} while(i >= 0)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.30"
   },
   "artifact_name": "c.66",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "literal": "repeat (10){\n    print(\"$it \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.31"
   },
   "artifact_name": "c.67",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.58",
     "literal": "fun foo(a: Int): String {\n    if (a < 10) \n        return \"kleiner 10\"\n    else if (a == 10) \n        return \"gleich 10\"\n    else {\n        val b = 20\n        return \"groeßer 10\"\n    }\n}\nprintln(foo(20))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.68",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.58",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.69",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.58",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.70",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.58",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.71",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.58",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.72",
   "versions": [
    {
     "start_checkpoint": 1616764358932,
     "parent": "n.0.59",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.73",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.32"
   },
   "artifact_name": "c.74",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "fun main(){\n    val name : String = \"MAX\"\n    println(\"Hello World $name.toLowerCase().\") //Falsch\n    println(\"Hello World ${name.toLowerCase()}.\") //Richtig\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.33"
   },
   "artifact_name": "c.75",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "fun Int.zehner() = if (this < 10) //Test, ob eine Zehnerstelle existiert\n                        -1\n                   else\n                        this % 100 / 10\n\nval zahl = 34291\nprintln(\"Die Zehnerstelle von der Zahl $zahl lautet ${zahl.zehner()}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 69
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.34"
   },
   "artifact_name": "c.76",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "//TODO\n\n//Test\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 170
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.35"
   },
   "artifact_name": "c.77",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "//Lösung\nfun String.addNewLine() = \"$this\\n\"\n\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 170
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.36"
   },
   "artifact_name": "c.78",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "//TODO\n\n//Test\nval liste1 = mutableListOf(0,1,2,3,4)\nval liste2 = mutableListOf(0,1,2,3,4)\nval sumListe = liste1 addAllElements liste2\nif (sumListe == listOf(0,2,4,6,8))\n    println(\"Richtig: $sumListe\")\nelse\n    println(\"Falsch: $sumListe. Das Ergebnis sollte eigentlich ${listOf(0,2,4,6,8)} beinhalten\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 95
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.37"
   },
   "artifact_name": "c.79",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "infix fun MutableList<Int>.addAllElements(to: MutableList<Int>): List<Int>{\n    for(i in 0 until this.size){\n        this[i] += to[i]\n    }\n    return this\n}\n\n//Test\nval liste1 = mutableListOf(0,1,2,3,4)\nval liste2 = mutableListOf(0,1,2,3,4)\nval sumListe = liste1 addAllElements liste2\nif (sumListe == listOf(0,2,4,6,8))\n    println(\"Richtig: $sumListe\")\nelse\n    println(\"Falsch: $sumListe. Das Ergebnis sollte eigentlich ${listOf(0,2,4,6,8)} beinhalten\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 95
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.38"
   },
   "artifact_name": "c.80",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int)\n\noperator fun Punkt.unaryMinus() = Punkt(-x, -y, -z)\n\nval punkt = Punkt(10, 20, 30)\nprintln(-punkt)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.39"
   },
   "artifact_name": "c.81",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "//TODO\n\n//Test\nval punkt1 = Punkt(10, 20, 30)\nval punkt2 = Punkt(30, 20, 10)\nval sumPunkt = punkt1 + punkt2\nif (sumPunkt == Punkt(40,40,40)){\n    println(\"Richtig: $sumPunkt\")\n}\nelse\n    println(\"Falsch: $sumPunkt. Das Ergebnis sollte eigentlich ${Punkt(40,40,40)} sein.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 88
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.40"
   },
   "artifact_name": "c.82",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "//Lösung\noperator fun Punkt.plus(other: Punkt) = Punkt(x+other.x, y+other.y,z+other.z)\n\n//Test\nval punkt1 = Punkt(10, 20, 30)\nval punkt2 = Punkt(30, 20, 10)\nval sumPunkt = punkt1 + punkt2\nif (sumPunkt == Punkt(40,40,40)){\n    println(\"Richtig: $sumPunkt\")\n}\nelse\n    println(\"Falsch: $sumPunkt. Das Ergebnis sollte eigentlich ${Punkt(40,40,40)} sein.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 88
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.41"
   },
   "artifact_name": "c.83",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val liste1 = listOf(1,2,3,4,5,6) //unveränderbare Liste mit Elementen des Datentyps Int\n//liste1.add(5) -> Error: Unresolved reference: add\nprintln(\"liste1: $liste1\")\n\nval liste2 = listOf<Int>() //leere, unveränderbare Liste mit Elementen des Datentyps Int\nprintln(\"liste2: $liste2\")\n\nval liste3 = mutableListOf(1,2.0,\"Kotlin\",4.5,'a','/') //veränderbare Liste mit Elementen des Datentyps Any\nliste3.removeAt(3)\nprintln(\"liste3: $liste3\")\n\nval liste4 = mutableListOf<String>() //leere, veränderbare Liste mit Elementen des Datentyps String\nliste4.add(\"Kotlin\")\nliste4.add(\"Java\")\n//liste4.add(10) -> Error: The integer literal does not conform to the expected type String\nprintln(\"liste4: $liste4\")\n\nval liste5 = List(5) { it } //unveränderbare Liste mit Elementen des Datentyps Int, die den Index beinhalten\nprintln(\"liste5: $liste5\")\n\nval liste6 = MutableList(10) { it*it } //veränderbare Liste mit Elementen des Datentyps Int, die den quadrierten Index beinhalten\nprintln(\"liste6: $liste6\")\n\nval liste7 = MutableList(5) { 0 } //veränderbare Liste mit Elementen des Datentyps Int, die 0 beinhalten\nliste7.add(10)\nprintln(\"liste7: $liste7\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 25
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.42"
   },
   "artifact_name": "c.84",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val liste = listOf(0,1,2,3,4)\nprintln(\"liste[1]: ${liste[1]}, liste.get(1): ${liste.get(1)}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 62
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.43"
   },
   "artifact_name": "c.85",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val liste = listOf(true, false, false, false, true, true)\nprintln(\"Länge der Liste $liste: ${liste.size}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 47
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.44"
   },
   "artifact_name": "c.86",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val array = arrayOf(1,2,3,4,5,6)\nprintln(\"array ist ein Array: ${array is Array<*>}\")\nval liste1 = array.toList()\n// liste.add(5) -> Error\nprintln(\"liste1 ist eine List: ${liste1 is List<*>}\")\nval liste2 = liste1.toMutableList()\nliste2.add(5) //-> funktioniert\nprintln(\"liste2 ist eine MutableList: ${liste2 is MutableList<*>}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 66
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.45"
   },
   "artifact_name": "c.87",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val liste = mutableListOf(1,2,3,4,5,6)\nprintln(\"Liste: $liste\")\nliste.fill(100)\nprintln(\"Gefüllte Liste: $liste\")\nliste.clear()\nprintln(\"Geleerte Liste: $liste\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 32
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.46"
   },
   "artifact_name": "c.88",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val liste = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste: $liste\")\nliste.add('f')\nliste.add(2, 'z')\nprintln(\"Liste mit hinzugefügten Elementen: $liste\")\nliste.remove('z')\nliste.removeAt(0)\nprintln(\"Liste mit entfernten Elementen: $liste\")\n\n//Kurzschreibweise\nprintln(\"\\nKurzschreibweise\")\nval liste2 = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste2: $liste2\")\nliste2 += 'f'\nliste2.add(2, 'z')\nprintln(\"Liste2 mit hinzugefügten Elementen: $liste2\")\nliste2 -= 'z'\nliste2.removeAt(0)\nprintln(\"Liste2 mit entfernten Elementen: $liste2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 18,
      "ch": 50
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.47"
   },
   "artifact_name": "c.89",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val liste = listOf(1,2,3,4,5,6)\nprintln(\"Ausgangsliste: $liste\")\nval teilliste = liste.subList(3, liste.size)\nprintln(\"Teilliste von 3 bis liste.size: $teilliste\")\nval teilliste2 = liste.take(3)\nprintln(\"Teilliste der ersten 3 Elemente: $teilliste2\")\nval teilliste3 = liste.takeLast(3)\nprintln(\"Teilliste der letzten 3 Elemente: $teilliste3\")\nval teilliste4 = liste.drop(3)\nprintln(\"Teilliste ohne die ersten 3 Elemente: $teilliste4\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 59
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.48"
   },
   "artifact_name": "c.90",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val liste = listOf(\"Kotlin\", \"Java\", \"Lua\", \"C\", \"Swift\")\nprintln(\"Ist 'Java' in der Liste: ${\"Java\" in liste}\")\nprintln(\"Ist 'Javascript' in der Liste: ${\"Javascript\" in liste}\")\nprintln(\"Welchen Index besitzt 'Java' in der Liste: ${liste.indexOf(\"Java\")}\")\nprintln(\"Welchen Index besitzt 'Javascript' in der Liste: ${liste.indexOf(\"Javascript\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 89
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.49"
   },
   "artifact_name": "c.91",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val liste = mutableListOf(0,1,2,3,4,5,6,7,8,9)\nprintln(\"Ausgangsliste: $liste\")\nprintln(\"Zufälliges Element: ${liste.random()}\")\nliste.shuffle()\nprintln(\"Zufällige Anordnung: ${liste}\")\nliste.sort()\nprintln(\"Wieder sortiert: ${liste}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 35
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.50"
   },
   "artifact_name": "c.92",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val set = setOf(1,2,3,4,5,1,2,3)\nprintln(\"unveränderbares Set: $set\")\nval set2 = mutableSetOf(1,2,3,4,5,1,2,3)\nprintln(\"veränderbares Set: $set2\")\nset2.remove(3)\nprintln(\"veränderbares Set ohne 3: $set2\")\nset2.add(10)\nprintln(\"veränderbares Set mit 10: $set2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 41
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.51"
   },
   "artifact_name": "c.93",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val set1 = setOf(1,2,3,4,5)\nval set2 = setOf(4,5,6,7,8)\nprintln(\"Set1: $set1, Set2: $set2\")\nval vereinigung = set1 union set2\nprintln(\"Vereinigung: $vereinigung\")\nval schnitt = set1 intersect set2\nprintln(\"Schnittmenge: $schnitt\")\nval subset = set1 subtract set2\nprintln(\"Subtraktion: $subset\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 30
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.52"
   },
   "artifact_name": "c.94",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val map = mapOf(\"Kotlin\" to 0, \"Java\" to 1, \"C\" to 2)\nprintln(\"unveränderbare Map: $map\")\n\nval map2 = mutableMapOf(\"AI1\" to \"Westfechtel\", \"AI2\" to \"Rauber\", \"AI3\" to \"Henrich\")\nprintln(\"veränderbare Map: $map2\")\nprintln(\"Wert zum Schlüssel AI2: ${map2[\"AI2\"]}\")\nmap2.put(\"AI4\", \"Jablonski\")\nprintln(\"veränderbare Map mit AI4: $map2\")\nmap2.remove(\"AI2\")\nprintln(\"veränderbare Map ohne AI2: $map2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 42
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.53"
   },
   "artifact_name": "c.95",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "literal": "val map = mapOf(\"AI1\" to \"Westfechtel\", \"AI2\" to \"Rauber\", \"AI3\" to \"Henrich\", \"AI4\" to \"Jablonski\")\nfor ((key, value) in map){\n    println(\"$key: $value\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.96",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.97",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.98",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.99",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun main(){\n    println(\"Hello World Kotlin.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.54"
   },
   "artifact_name": "c.100",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "main()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 0,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.55"
   },
   "artifact_name": "c.101",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun main(){\n    val name : String = \"Max\"\n    println(\"Hello World $name.\")\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.56"
   },
   "artifact_name": "c.102",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun main(){\n    val name : String = \"MAX\"\n    println(\"Hello World $name.toLowerCase().\") //Falsch\n    println(\"Hello World ${name.toLowerCase()}.\") //Richtig\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.57"
   },
   "artifact_name": "c.103",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val v1 : String = \"schreibgeschützte Variable\"\n//v1 = \"Test\"   //Fehler: Val cannot be reassigned\nvar v2 : String = \"veränderbare Variable\"\nv2 = \"Test\"\nprintln(\"$v1 - $v2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.58"
   },
   "artifact_name": "c.104",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val value : Int = foo()\nprintln(value)\n\n//const val constant : Int = foo()   -> Error\nconst val constant : Int = 5       //-> Kein Error\nprintln(constant)\n\nfun foo() : Int { //Gibt eine zufällige ganze Zahl zwischen 0 und 10 zurück\n    return (0..10).random()\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.59"
   },
   "artifact_name": "c.105",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val int1 : Int = 5\nval int2 = 5\nprintln(\"Datentyp von v1: ${v1::class.simpleName}, Datentyp von v2: ${v2::class.simpleName}\")\n\nval string1 : String = \"String 1\"\nval string2 = \"String 2\"\nprintln(\"Datentyp von string1: ${string1::class.simpleName}, Datentyp von string2: ${string2::class.simpleName}\") ",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 113
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.60"
   },
   "artifact_name": "c.106",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun vergleicheElemente(a: List<Int>, b: List<Int>){\n    if (a == b) println(\"vergleicheElemente: Gleich\")\n    else println(\"vergleicheElemente: Ungleich\")\n}\nfun vergleicheSpeicher(a: List<Int>, b: List<Int>){\n    if (a === b) println(\"vergleicheSpeicher: Gleich\")\n    else println(\"vergleicheSpeicher: Ungleich\")\n}\nval a = listOf(1,2,3)\nval b = listOf(1,2,3)\nvergleicheElemente(a, b)\nvergleicheSpeicher(a, b)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 23
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.61"
   },
   "artifact_name": "c.107",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun vergleicheStrings(a: String, b: String){\n    if (a == b) println(\"vergleicheStrings: $a == $b\")\n    else if (a < b) println(\"vergleicheStrings: $a < $b\")\n    else println(\"vergleicheStrings: $a > $b\")\n}\nval a = \"Kotlin\"\nval b = \"Java\"\nvergleicheStrings(a,b)\nvergleicheStrings(b,a)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 21
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.62"
   },
   "artifact_name": "c.108",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "//const val PI = 3.14159f\nvar a = 50\nval b = 20\nvar res : Int\nval bool = false\na = a + 30\nres = a - b\nval output = \"a - b ist: $res.\"\nprintln(output)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.63"
   },
   "artifact_name": "c.109",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun foo(): String{\n    return \"TEST\"\n}\n\nfun show(a: String){\n    println(a)\n}\n\nfun main(){\n    val a = foo()\n    show(a)\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.64"
   },
   "artifact_name": "c.110",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun foo(a: Int = 0, b: Int = 0, c: Int = 0, d:Int = 0) {\n    println(\"a: $a, b: $b, c: $c, d: $d\")\n}\nfoo(1,2,1,2)\nfoo(1,2)\nfoo()\nfoo(b=2,d=2)\n//foo(b=2,d=2, 3, 4) -> Error: Mixing named and positioned arguments is not allowed",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 82
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.65"
   },
   "artifact_name": "c.111",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun sum(a: Int, b: Int) = a+b\nprintln(sum(5,5))\n\nfun foo(num: Int) = if (num == 42) 42 else 0\nprintln(foo(42))\nprintln(foo(24))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.66"
   },
   "artifact_name": "c.112",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun sum(a: Int, b: Int) = println(\"Sum mit 2 Int-Parametern: ${a+b}\")\nfun sum(a: Int, b: Int, c: Int) = println(\"Sum mit 3 Int-Parametern: ${a+b+c}\")\nfun sum(a: Double, b: Double) = println(\"Sum mit 2 Double-Parametern: ${a+b}\")\nsum(2,3)\nsum(2,3,4)\nsum(2.0,3.0)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 11
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.67"
   },
   "artifact_name": "c.113",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun foo(a: Int): String {\n    val res = if (a < 10) \n                  \"kleiner 10\"\n              else if (a == 10) \n                  \"gleich 10\"\n              else \n                  \"groeßer 10\"\n    return res\n}\nfun foo2(a: Int): String {\n    return if (a < 10) \n               \"kleiner 10\"\n           else if (a == 10) \n               \"gleich 10\"\n           else \n               \"groeßer 10\"\n}\nfun foo3(a: Int) = if (a < 10) \n                       \"kleiner 10\"\n                   else if (a == 10) \n                       \"gleich 10\"\n                   else \n                       \"groeßer 10\"\nval a = 10\nprintln(foo(a))\nprintln(foo2(a))\nprintln(foo3(a))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 26,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.68"
   },
   "artifact_name": "c.114",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val c = 'ä'\nwhen (c) {\n    'a', 'e', 'i', 'o', 'u' -> println(\"Vokal\")\n    'ä', 'ö', 'ü' -> {\n                        val res = \"Umlaut\"\n                        println(res)\n                     }\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> println(\"Zahl\")\n    else -> println(\"Kostante\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.69"
   },
   "artifact_name": "c.115",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val a: Any = 0\nval liste = listOf(0, 1, 2, 3)\nwhen (a) {\n    is Double -> println(\"$a ist vom Datentyp Double\")\n    is Long -> println(\"$a ist vom Datentyp Long\")\n    in liste -> println(\"$a ist in Liste $liste\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.70"
   },
   "artifact_name": "c.116",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val a = 10\nwhen {\n    a == 10 -> println(\"gleich 10\")\n    a < 10 -> println(\"kleiner 10\")\n    else -> println(\"groeßer 10\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.71"
   },
   "artifact_name": "c.117",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val intBereich = 0..10 //Bereich von 0 - 10\nprintln(\"Der Bereich $intBereich vom Typ ${intBereich::class.simpleName} geht von ${intBereich.first} bis ${intBereich.last} und umfasst ${intBereich.toList()}\")\n\nval start = 5\nval intBereichMitVariable = start..start+5 //Bereich von start bis start+5\nprintln(\"Der Bereich $intBereichMitVariable vom Typ ${intBereichMitVariable::class.simpleName} geht von ${intBereichMitVariable.first} bis ${intBereichMitVariable.last} und umfasst ${intBereichMitVariable.toList()}\")\n\nval charBereich = 'a'..'e' //Bereich von a bis e\nprintln(\"Der Bereich $charBereich vom Typ ${charBereich::class.simpleName} geht von ${charBereich.first} bis ${charBereich.last} und umfasst ${charBereich.toList()}\")\n\nval intBereichUntil = 0 until 10 //Bereich von 0 - 9\nprintln(\"Der Bereich $intBereichUntil vom Typ ${intBereichUntil::class.simpleName} geht von ${intBereichUntil.first} bis ${intBereichUntil.last} und umfasst ${intBereichUntil.toList()}\")\n\nvar umgekehrterIntBereich = 10 downTo 0 //Bereich von 10 - 0\nprintln(\"Der Bereich $umgekehrterIntBereich vom Typ ${umgekehrterIntBereich::class.simpleName} geht von ${umgekehrterIntBereich.first} bis ${umgekehrterIntBereich.last} und umfasst ${umgekehrterIntBereich.toList()}\")\n\nval intBereichSchrittweite = 0..10 step 2 //Bereich von 0 - 10 mit Schrittweite 2\nprintln(\"Der Bereich $intBereichSchrittweite vom Typ ${intBereichSchrittweite::class.simpleName} geht von ${intBereichSchrittweite.first} bis ${intBereichSchrittweite.last} und umfasst ${intBereichSchrittweite.toList()}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 17,
      "ch": 220
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.72"
   },
   "artifact_name": "c.118",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "for (i in 0..10){\n    print(\"$i \")\n}\nprintln()\nfor (i in 0 until 20){\n    print(\"$i \")\n}\nprintln()\nfor (i in 15 downTo 5 step 5){\n    print(\"$i \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.73"
   },
   "artifact_name": "c.119",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = listOf(\"Kotlin\", \"Java\", \"C\", \"Python\")\nfor (i in liste){\n    print(\"$i \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.74"
   },
   "artifact_name": "c.120",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor (i in liste){\n    i = i*i\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.75"
   },
   "artifact_name": "c.121",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor (i in 0 until liste.size){\n    liste[i] = liste[i] * liste[i]\n}\nprintln(liste)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 13
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.76"
   },
   "artifact_name": "c.122",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor ((index, element) in liste.withIndex()){\n    println(\"An Stelle $index ist $element gespeichert\")\n    liste[index] = element * element\n}\nprintln(liste)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 13
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.77"
   },
   "artifact_name": "c.123",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste1 = (0..100 step 11).toList()\nval liste2 = (0..100 step 5).toList()\niloop@\nfor (i in liste1){\n    println(\"Aktuell untersucht: $i\")\n    for(j in liste2){\n        if(i == j && i != 0){\n            println(\"Gefunden $i\")\n            break@iloop\n        }\n    }\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.78"
   },
   "artifact_name": "c.124",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "var i = 0\nwhile (i<=10){\n    print(\"$i \")\n    i++\n}\ndo {\n    print(\"$i \")\n    i--\n} while(i >= 0)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.79"
   },
   "artifact_name": "c.125",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "repeat (10){\n    print(\"$it \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.80"
   },
   "artifact_name": "c.126",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "fun Int.zehner() = if (this < 10) //Test, ob eine Zehnerstelle existiert\n                        -1\n                   else\n                        this % 100 / 10\n\nval zahl = 34291\nprintln(\"Die Zehnerstelle von der Zahl $zahl lautet ${zahl.zehner()}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 69
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.81"
   },
   "artifact_name": "c.127",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "//TODO\n\n//Test\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 170
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.82"
   },
   "artifact_name": "c.128",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "//Lösung\nfun String.addNewLine() = \"$this\\n\"\n\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 170
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.83"
   },
   "artifact_name": "c.129",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "//TODO\n\n//Test\nval liste1 = mutableListOf(0,1,2,3,4)\nval liste2 = mutableListOf(0,1,2,3,4)\nval sumListe = liste1 addAllElements liste2\nif (sumListe == listOf(0,2,4,6,8))\n    println(\"Richtig: $sumListe\")\nelse\n    println(\"Falsch: $sumListe. Das Ergebnis sollte eigentlich ${listOf(0,2,4,6,8)} beinhalten\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 95
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.84"
   },
   "artifact_name": "c.130",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "infix fun MutableList<Int>.addAllElements(to: MutableList<Int>): List<Int>{\n    for(i in 0 until this.size){\n        this[i] += to[i]\n    }\n    return this\n}\n\n//Test\nval liste1 = mutableListOf(0,1,2,3,4)\nval liste2 = mutableListOf(0,1,2,3,4)\nval sumListe = liste1 addAllElements liste2\nif (sumListe == listOf(0,2,4,6,8))\n    println(\"Richtig: $sumListe\")\nelse\n    println(\"Falsch: $sumListe. Das Ergebnis sollte eigentlich ${listOf(0,2,4,6,8)} beinhalten\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 95
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.85"
   },
   "artifact_name": "c.131",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int)\n\noperator fun Punkt.unaryMinus() = Punkt(-x, -y, -z)\n\nval punkt = Punkt(10, 20, 30)\nprintln(-punkt)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.86"
   },
   "artifact_name": "c.132",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "//TODO\n\n//Test\nval punkt1 = Punkt(10, 20, 30)\nval punkt2 = Punkt(30, 20, 10)\nval sumPunkt = punkt1 + punkt2\nif (sumPunkt == Punkt(40,40,40)){\n    println(\"Richtig: $sumPunkt\")\n}\nelse\n    println(\"Falsch: $sumPunkt. Das Ergebnis sollte eigentlich ${Punkt(40,40,40)} sein.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 88
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.87"
   },
   "artifact_name": "c.133",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "//Lösung\noperator fun Punkt.plus(other: Punkt) = Punkt(x+other.x, y+other.y,z+other.z)\n\n//Test\nval punkt1 = Punkt(10, 20, 30)\nval punkt2 = Punkt(30, 20, 10)\nval sumPunkt = punkt1 + punkt2\nif (sumPunkt == Punkt(40,40,40)){\n    println(\"Richtig: $sumPunkt\")\n}\nelse\n    println(\"Falsch: $sumPunkt. Das Ergebnis sollte eigentlich ${Punkt(40,40,40)} sein.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 88
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.88"
   },
   "artifact_name": "c.134",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste1 = listOf(1,2,3,4,5,6) //unveränderbare Liste mit Elementen des Datentyps Int\n//liste1.add(5) -> Error: Unresolved reference: add\nprintln(\"liste1: $liste1\")\n\nval liste2 = listOf<Int>() //leere, unveränderbare Liste mit Elementen des Datentyps Int\nprintln(\"liste2: $liste2\")\n\nval liste3 = mutableListOf(1,2.0,\"Kotlin\",4.5,'a','/') //veränderbare Liste mit Elementen des Datentyps Any\nliste3.removeAt(3)\nprintln(\"liste3: $liste3\")\n\nval liste4 = mutableListOf<String>() //leere, veränderbare Liste mit Elementen des Datentyps String\nliste4.add(\"Kotlin\")\nliste4.add(\"Java\")\n//liste4.add(10) -> Error: The integer literal does not conform to the expected type String\nprintln(\"liste4: $liste4\")\n\nval liste5 = List(5) { it } //unveränderbare Liste mit Elementen des Datentyps Int, die den Index beinhalten\nprintln(\"liste5: $liste5\")\n\nval liste6 = MutableList(10) { it*it } //veränderbare Liste mit Elementen des Datentyps Int, die den quadrierten Index beinhalten\nprintln(\"liste6: $liste6\")\n\nval liste7 = MutableList(5) { 0 } //veränderbare Liste mit Elementen des Datentyps Int, die 0 beinhalten\nliste7.add(10)\nprintln(\"liste7: $liste7\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 25
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.89"
   },
   "artifact_name": "c.135",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = listOf(0,1,2,3,4)\nprintln(\"liste[1]: ${liste[1]}, liste.get(1): ${liste.get(1)}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 62
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.90"
   },
   "artifact_name": "c.136",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = listOf(true, false, false, false, true, true)\nprintln(\"Länge der Liste $liste: ${liste.size}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 47
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.91"
   },
   "artifact_name": "c.137",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val array = arrayOf(1,2,3,4,5,6)\nprintln(\"array ist ein Array: ${array is Array<*>}\")\nval liste1 = array.toList()\n// liste.add(5) -> Error\nprintln(\"liste1 ist eine List: ${liste1 is List<*>}\")\nval liste2 = liste1.toMutableList()\nliste2.add(5) //-> funktioniert\nprintln(\"liste2 ist eine MutableList: ${liste2 is MutableList<*>}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 66
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.92"
   },
   "artifact_name": "c.138",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = mutableListOf(1,2,3,4,5,6)\nprintln(\"Liste: $liste\")\nliste.fill(100)\nprintln(\"Gefüllte Liste: $liste\")\nliste.clear()\nprintln(\"Geleerte Liste: $liste\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 32
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.93"
   },
   "artifact_name": "c.139",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste: $liste\")\nliste.add('f')\nliste.add(2, 'z')\nprintln(\"Liste mit hinzugefügten Elementen: $liste\")\nliste.remove('z')\nliste.removeAt(0)\nprintln(\"Liste mit entfernten Elementen: $liste\")\n\n//Kurzschreibweise\nprintln(\"\\nKurzschreibweise\")\nval liste2 = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste2: $liste2\")\nliste2 += 'f'\nliste2.add(2, 'z')\nprintln(\"Liste2 mit hinzugefügten Elementen: $liste2\")\nliste2 -= 'z'\nliste2.removeAt(0)\nprintln(\"Liste2 mit entfernten Elementen: $liste2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 18,
      "ch": 50
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.94"
   },
   "artifact_name": "c.140",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = listOf(1,2,3,4,5,6)\nprintln(\"Ausgangsliste: $liste\")\nval teilliste = liste.subList(3, liste.size)\nprintln(\"Teilliste von 3 bis liste.size: $teilliste\")\nval teilliste2 = liste.take(3)\nprintln(\"Teilliste der ersten 3 Elemente: $teilliste2\")\nval teilliste3 = liste.takeLast(3)\nprintln(\"Teilliste der letzten 3 Elemente: $teilliste3\")\nval teilliste4 = liste.drop(3)\nprintln(\"Teilliste ohne die ersten 3 Elemente: $teilliste4\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 59
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.95"
   },
   "artifact_name": "c.141",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = listOf(\"Kotlin\", \"Java\", \"Lua\", \"C\", \"Swift\")\nprintln(\"Ist 'Java' in der Liste: ${\"Java\" in liste}\")\nprintln(\"Ist 'Javascript' in der Liste: ${\"Javascript\" in liste}\")\nprintln(\"Welchen Index besitzt 'Java' in der Liste: ${liste.indexOf(\"Java\")}\")\nprintln(\"Welchen Index besitzt 'Javascript' in der Liste: ${liste.indexOf(\"Javascript\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 89
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.96"
   },
   "artifact_name": "c.142",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val liste = mutableListOf(0,1,2,3,4,5,6,7,8,9)\nprintln(\"Ausgangsliste: $liste\")\nprintln(\"Zufälliges Element: ${liste.random()}\")\nliste.shuffle()\nprintln(\"Zufällige Anordnung: ${liste}\")\nliste.sort()\nprintln(\"Wieder sortiert: ${liste}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 35
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.97"
   },
   "artifact_name": "c.143",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val set = setOf(1,2,3,4,5,1,2,3)\nprintln(\"unveränderbares Set: $set\")\nval set2 = mutableSetOf(1,2,3,4,5,1,2,3)\nprintln(\"veränderbares Set: $set2\")\nset2.remove(3)\nprintln(\"veränderbares Set ohne 3: $set2\")\nset2.add(10)\nprintln(\"veränderbares Set mit 10: $set2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 41
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.98"
   },
   "artifact_name": "c.144",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val set1 = setOf(1,2,3,4,5)\nval set2 = setOf(4,5,6,7,8)\nprintln(\"Set1: $set1, Set2: $set2\")\nval vereinigung = set1 union set2\nprintln(\"Vereinigung: $vereinigung\")\nval schnitt = set1 intersect set2\nprintln(\"Schnittmenge: $schnitt\")\nval subset = set1 subtract set2\nprintln(\"Subtraktion: $subset\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 30
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.99"
   },
   "artifact_name": "c.145",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val map = mapOf(\"Kotlin\" to 0, \"Java\" to 1, \"C\" to 2)\nprintln(\"unveränderbare Map: $map\")\n\nval map2 = mutableMapOf(\"AI1\" to \"Westfechtel\", \"AI2\" to \"Rauber\", \"AI3\" to \"Henrich\")\nprintln(\"veränderbare Map: $map2\")\nprintln(\"Wert zum Schlüssel AI2: ${map2[\"AI2\"]}\")\nmap2.put(\"AI4\", \"Jablonski\")\nprintln(\"veränderbare Map mit AI4: $map2\")\nmap2.remove(\"AI2\")\nprintln(\"veränderbare Map ohne AI2: $map2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 42
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.100"
   },
   "artifact_name": "c.146",
   "versions": [
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "literal": "val map = mapOf(\"AI1\" to \"Westfechtel\", \"AI2\" to \"Rauber\", \"AI3\" to \"Henrich\", \"AI4\" to \"Jablonski\")\nfor ((key, value) in map){\n    println(\"$key: $value\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.147",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.66",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.148",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.66",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.149",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun main(){\n    println(\"Hello World Kotlin.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.150",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "main()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 0,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.151",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun main(){\n    val name : String = \"Max\"\n    println(\"Hello World $name.\")\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.152",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun main(){\n    val name : String = \"MAX\"\n    println(\"Hello World $name.toLowerCase().\") //Falsch\n    println(\"Hello World ${name.toLowerCase()}.\") //Richtig\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.153",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "val v1 : String = \"schreibgeschützte Variable\"\n//v1 = \"Test\"   //Fehler: Val cannot be reassigned\nvar v2 : String = \"veränderbare Variable\"\nv2 = \"Test\"\nprintln(\"$v1 - $v2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.154",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "val value : Int = foo()\nprintln(value)\n\n//const val constant : Int = foo()   -> Error\nconst val constant : Int = 5       //-> Kein Error\nprintln(constant)\n\nfun foo() : Int { //Gibt eine zufällige ganze Zahl zwischen 0 und 10 zurück\n    return (0..10).random()\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.155",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "val int1 : Int = 5\nval int2 = 5\nprintln(\"Datentyp von v1: ${v1::class.simpleName}, Datentyp von v2: ${v2::class.simpleName}\")\n\nval string1 : String = \"String 1\"\nval string2 = \"String 2\"\nprintln(\"Datentyp von string1: ${string1::class.simpleName}, Datentyp von string2: ${string2::class.simpleName}\") ",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 113
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.156",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun vergleicheElemente(a: List<Int>, b: List<Int>){\n    if (a == b) println(\"vergleicheElemente: Gleich\")\n    else println(\"vergleicheElemente: Ungleich\")\n}\nfun vergleicheSpeicher(a: List<Int>, b: List<Int>){\n    if (a === b) println(\"vergleicheSpeicher: Gleich\")\n    else println(\"vergleicheSpeicher: Ungleich\")\n}\nval a = listOf(1,2,3)\nval b = listOf(1,2,3)\nvergleicheElemente(a, b)\nvergleicheSpeicher(a, b)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 23
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.157",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun vergleicheStrings(a: String, b: String){\n    if (a == b) println(\"vergleicheStrings: $a == $b\")\n    else if (a < b) println(\"vergleicheStrings: $a < $b\")\n    else println(\"vergleicheStrings: $a > $b\")\n}\nval a = \"Kotlin\"\nval b = \"Java\"\nvergleicheStrings(a,b)\nvergleicheStrings(b,a)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 21
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.158",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "//const val PI = 3.14159f\nvar a = 50\nval b = 20\nvar res : Int\nval bool = false\na = a + 30\nres = a - b\nval output = \"a - b ist: $res.\"\nprintln(output)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.159",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun foo(): String{\n    return \"TEST\"\n}\n\nfun show(a: String){\n    println(a)\n}\n\nfun main(){\n    val a = foo()\n    show(a)\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.160",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun foo(a: Int = 0, b: Int = 0, c: Int = 0, d:Int = 0) {\n    println(\"a: $a, b: $b, c: $c, d: $d\")\n}\nfoo(1,2,1,2)\nfoo(1,2)\nfoo()\nfoo(b=2,d=2)\n//foo(b=2,d=2, 3, 4) -> Error: Mixing named and positioned arguments is not allowed",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 82
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.161",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun sum(a: Int, b: Int) = a+b\nprintln(sum(5,5))\n\nfun foo(num: Int) = if (num == 42) 42 else 0\nprintln(foo(42))\nprintln(foo(24))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.162",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun sum(a: Int, b: Int) = println(\"Sum mit 2 Int-Parametern: ${a+b}\")\nfun sum(a: Int, b: Int, c: Int) = println(\"Sum mit 3 Int-Parametern: ${a+b+c}\")\nfun sum(a: Double, b: Double) = println(\"Sum mit 2 Double-Parametern: ${a+b}\")\nsum(2,3)\nsum(2,3,4)\nsum(2.0,3.0)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 11
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.163",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "fun foo(a: Int): String {\n    val res = if (a < 10) \n                  \"kleiner 10\"\n              else if (a == 10) \n                  \"gleich 10\"\n              else \n                  \"groeßer 10\"\n    return res\n}\nfun foo2(a: Int): String {\n    return if (a < 10) \n               \"kleiner 10\"\n           else if (a == 10) \n               \"gleich 10\"\n           else \n               \"groeßer 10\"\n}\nfun foo3(a: Int) = if (a < 10) \n                       \"kleiner 10\"\n                   else if (a == 10) \n                       \"gleich 10\"\n                   else \n                       \"groeßer 10\"\nval a = 10\nprintln(foo(a))\nprintln(foo2(a))\nprintln(foo3(a))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 26,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.164",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "val c = 'ä'\nwhen (c) {\n    'a', 'e', 'i', 'o', 'u' -> println(\"Vokal\")\n    'ä', 'ö', 'ü' -> {\n                        val res = \"Umlaut\"\n                        println(res)\n                     }\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> println(\"Zahl\")\n    else -> println(\"Kostante\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.165",
   "versions": [
    {
     "start_checkpoint": 1616858354852,
     "literal": "val a: Any = 0\nval liste = listOf(0, 1, 2, 3)\nwhen (a) {\n    is Double -> println(\"$a ist vom Datentyp Double\")\n    is Long -> println(\"$a ist vom Datentyp Long\")\n    in liste -> println(\"$a ist in Liste $liste\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.166",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val a = 10\nwhen {\n    a == 10 -> println(\"gleich 10\")\n    a < 10 -> println(\"kleiner 10\")\n    else -> println(\"groeßer 10\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.167",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val intBereich = 0..10 //Bereich von 0 - 10\nprintln(\"Der Bereich $intBereich vom Typ ${intBereich::class.simpleName} geht von ${intBereich.first} bis ${intBereich.last} und umfasst ${intBereich.toList()}\")\n\nval start = 5\nval intBereichMitVariable = start..start+5 //Bereich von start bis start+5\nprintln(\"Der Bereich $intBereichMitVariable vom Typ ${intBereichMitVariable::class.simpleName} geht von ${intBereichMitVariable.first} bis ${intBereichMitVariable.last} und umfasst ${intBereichMitVariable.toList()}\")\n\nval charBereich = 'a'..'e' //Bereich von a bis e\nprintln(\"Der Bereich $charBereich vom Typ ${charBereich::class.simpleName} geht von ${charBereich.first} bis ${charBereich.last} und umfasst ${charBereich.toList()}\")\n\nval intBereichUntil = 0 until 10 //Bereich von 0 - 9\nprintln(\"Der Bereich $intBereichUntil vom Typ ${intBereichUntil::class.simpleName} geht von ${intBereichUntil.first} bis ${intBereichUntil.last} und umfasst ${intBereichUntil.toList()}\")\n\nvar umgekehrterIntBereich = 10 downTo 0 //Bereich von 10 - 0\nprintln(\"Der Bereich $umgekehrterIntBereich vom Typ ${umgekehrterIntBereich::class.simpleName} geht von ${umgekehrterIntBereich.first} bis ${umgekehrterIntBereich.last} und umfasst ${umgekehrterIntBereich.toList()}\")\n\nval intBereichSchrittweite = 0..10 step 2 //Bereich von 0 - 10 mit Schrittweite 2\nprintln(\"Der Bereich $intBereichSchrittweite vom Typ ${intBereichSchrittweite::class.simpleName} geht von ${intBereichSchrittweite.first} bis ${intBereichSchrittweite.last} und umfasst ${intBereichSchrittweite.toList()}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 17,
      "ch": 220
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.168",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "for (i in 0..10){\n    print(\"$i \")\n}\nprintln()\nfor (i in 0 until 20){\n    print(\"$i \")\n}\nprintln()\nfor (i in 15 downTo 5 step 5){\n    print(\"$i \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.169",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste = listOf(\"Kotlin\", \"Java\", \"C\", \"Python\")\nfor (i in liste){\n    print(\"$i \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.170",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor (i in liste){\n    i = i*i\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.171",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor (i in 0 until liste.size){\n    liste[i] = liste[i] * liste[i]\n}\nprintln(liste)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 13
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.172",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor ((index, element) in liste.withIndex()){\n    println(\"An Stelle $index ist $element gespeichert\")\n    liste[index] = element * element\n}\nprintln(liste)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 13
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.173",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste1 = (0..100 step 11).toList()\nval liste2 = (0..100 step 5).toList()\niloop@\nfor (i in liste1){\n    println(\"Aktuell untersucht: $i\")\n    for(j in liste2){\n        if(i == j && i != 0){\n            println(\"Gefunden $i\")\n            break@iloop\n        }\n    }\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.174",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "var i = 0\nwhile (i<=10){\n    print(\"$i \")\n    i++\n}\ndo {\n    print(\"$i \")\n    i--\n} while(i >= 0)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.175",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "repeat (10){\n    print(\"$it \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.176",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "fun Int.zehner() = if (this < 10) //Test, ob eine Zehnerstelle existiert\n                        -1\n                   else\n                        this % 100 / 10\n\nval zahl = 34291\nprintln(\"Die Zehnerstelle von der Zahl $zahl lautet ${zahl.zehner()}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 69
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.177",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "//TODO\n\n//Test\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 170
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.178",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "//Lösung\nfun String.addNewLine() = \"$this\\n\"\n\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 170
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.179",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "//TODO\n\n//Test\nval liste1 = mutableListOf(0,1,2,3,4)\nval liste2 = mutableListOf(0,1,2,3,4)\nval sumListe = liste1 addAllElements liste2\nif (sumListe == listOf(0,2,4,6,8))\n    println(\"Richtig: $sumListe\")\nelse\n    println(\"Falsch: $sumListe. Das Ergebnis sollte eigentlich ${listOf(0,2,4,6,8)} beinhalten\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 95
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.180",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "infix fun MutableList<Int>.addAllElements(to: MutableList<Int>): List<Int>{\n    for(i in 0 until this.size){\n        this[i] += to[i]\n    }\n    return this\n}\n\n//Test\nval liste1 = mutableListOf(0,1,2,3,4)\nval liste2 = mutableListOf(0,1,2,3,4)\nval sumListe = liste1 addAllElements liste2\nif (sumListe == listOf(0,2,4,6,8))\n    println(\"Richtig: $sumListe\")\nelse\n    println(\"Falsch: $sumListe. Das Ergebnis sollte eigentlich ${listOf(0,2,4,6,8)} beinhalten\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 95
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.181",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int)\n\noperator fun Punkt.unaryMinus() = Punkt(-x, -y, -z)\n\nval punkt = Punkt(10, 20, 30)\nprintln(-punkt)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.182",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "//TODO\n\n//Test\nval punkt1 = Punkt(10, 20, 30)\nval punkt2 = Punkt(30, 20, 10)\nval sumPunkt = punkt1 + punkt2\nif (sumPunkt == Punkt(40,40,40)){\n    println(\"Richtig: $sumPunkt\")\n}\nelse\n    println(\"Falsch: $sumPunkt. Das Ergebnis sollte eigentlich ${Punkt(40,40,40)} sein.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 88
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.183",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "//Lösung\noperator fun Punkt.plus(other: Punkt) = Punkt(x+other.x, y+other.y,z+other.z)\n\n//Test\nval punkt1 = Punkt(10, 20, 30)\nval punkt2 = Punkt(30, 20, 10)\nval sumPunkt = punkt1 + punkt2\nif (sumPunkt == Punkt(40,40,40)){\n    println(\"Richtig: $sumPunkt\")\n}\nelse\n    println(\"Falsch: $sumPunkt. Das Ergebnis sollte eigentlich ${Punkt(40,40,40)} sein.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 88
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.184",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste1 = listOf(1,2,3,4,5,6) //unveränderbare Liste mit Elementen des Datentyps Int\n//liste1.add(5) -> Error: Unresolved reference: add\nprintln(\"liste1: $liste1\")\n\nval liste2 = listOf<Int>() //leere, unveränderbare Liste mit Elementen des Datentyps Int\nprintln(\"liste2: $liste2\")\n\nval liste3 = mutableListOf(1,2.0,\"Kotlin\",4.5,'a','/') //veränderbare Liste mit Elementen des Datentyps Any\nliste3.removeAt(3)\nprintln(\"liste3: $liste3\")\n\nval liste4 = mutableListOf<String>() //leere, veränderbare Liste mit Elementen des Datentyps String\nliste4.add(\"Kotlin\")\nliste4.add(\"Java\")\n//liste4.add(10) -> Error: The integer literal does not conform to the expected type String\nprintln(\"liste4: $liste4\")\n\nval liste5 = List(5) { it } //unveränderbare Liste mit Elementen des Datentyps Int, die den Index beinhalten\nprintln(\"liste5: $liste5\")\n\nval liste6 = MutableList(10) { it*it } //veränderbare Liste mit Elementen des Datentyps Int, die den quadrierten Index beinhalten\nprintln(\"liste6: $liste6\")\n\nval liste7 = MutableList(5) { 0 } //veränderbare Liste mit Elementen des Datentyps Int, die 0 beinhalten\nliste7.add(10)\nprintln(\"liste7: $liste7\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 25
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.185",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste = listOf(0,1,2,3,4)\nprintln(\"liste[1]: ${liste[1]}, liste.get(1): ${liste.get(1)}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 62
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.186",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste = listOf(true, false, false, false, true, true)\nprintln(\"Länge der Liste $liste: ${liste.size}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 47
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.187",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val array = arrayOf(1,2,3,4,5,6)\nprintln(\"array ist ein Array: ${array is Array<*>}\")\nval liste1 = array.toList()\n// liste.add(5) -> Error\nprintln(\"liste1 ist eine List: ${liste1 is List<*>}\")\nval liste2 = liste1.toMutableList()\nliste2.add(5) //-> funktioniert\nprintln(\"liste2 ist eine MutableList: ${liste2 is MutableList<*>}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 66
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.188",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste = mutableListOf(1,2,3,4,5,6)\nprintln(\"Liste: $liste\")\nliste.fill(100)\nprintln(\"Gefüllte Liste: $liste\")\nliste.clear()\nprintln(\"Geleerte Liste: $liste\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 32
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.189",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste: $liste\")\nliste.add('f')\nliste.add(2, 'z')\nprintln(\"Liste mit hinzugefügten Elementen: $liste\")\nliste.remove('z')\nliste.removeAt(0)\nprintln(\"Liste mit entfernten Elementen: $liste\")\n\n//Kurzschreibweise\nprintln(\"\\nKurzschreibweise\")\nval liste2 = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste2: $liste2\")\nliste2 += 'f'\nliste2.add(2, 'z')\nprintln(\"Liste2 mit hinzugefügten Elementen: $liste2\")\nliste2 -= 'z'\nliste2.removeAt(0)\nprintln(\"Liste2 mit entfernten Elementen: $liste2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 18,
      "ch": 50
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.190",
   "versions": [
    {
     "start_checkpoint": 1616858354853,
     "literal": "val liste = listOf(1,2,3,4,5,6)\nprintln(\"Ausgangsliste: $liste\")\nval teilliste = liste.subList(3, liste.size)\nprintln(\"Teilliste von 3 bis liste.size: $teilliste\")\nval teilliste2 = liste.take(3)\nprintln(\"Teilliste der ersten 3 Elemente: $teilliste2\")\nval teilliste3 = liste.takeLast(3)\nprintln(\"Teilliste der letzten 3 Elemente: $teilliste3\")\nval teilliste4 = liste.drop(3)\nprintln(\"Teilliste ohne die ersten 3 Elemente: $teilliste4\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 59
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.191",
   "versions": [
    {
     "start_checkpoint": 1616858354854,
     "literal": "val liste = listOf(\"Kotlin\", \"Java\", \"Lua\", \"C\", \"Swift\")\nprintln(\"Ist 'Java' in der Liste: ${\"Java\" in liste}\")\nprintln(\"Ist 'Javascript' in der Liste: ${\"Javascript\" in liste}\")\nprintln(\"Welchen Index besitzt 'Java' in der Liste: ${liste.indexOf(\"Java\")}\")\nprintln(\"Welchen Index besitzt 'Javascript' in der Liste: ${liste.indexOf(\"Javascript\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 89
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.192",
   "versions": [
    {
     "start_checkpoint": 1616858354854,
     "literal": "val liste = mutableListOf(0,1,2,3,4,5,6,7,8,9)\nprintln(\"Ausgangsliste: $liste\")\nprintln(\"Zufälliges Element: ${liste.random()}\")\nliste.shuffle()\nprintln(\"Zufällige Anordnung: ${liste}\")\nliste.sort()\nprintln(\"Wieder sortiert: ${liste}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 35
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.193",
   "versions": [
    {
     "start_checkpoint": 1616858354854,
     "literal": "val set = setOf(1,2,3,4,5,1,2,3)\nprintln(\"unveränderbares Set: $set\")\nval set2 = mutableSetOf(1,2,3,4,5,1,2,3)\nprintln(\"veränderbares Set: $set2\")\nset2.remove(3)\nprintln(\"veränderbares Set ohne 3: $set2\")\nset2.add(10)\nprintln(\"veränderbares Set mit 10: $set2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 41
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.194",
   "versions": [
    {
     "start_checkpoint": 1616858354854,
     "literal": "val set1 = setOf(1,2,3,4,5)\nval set2 = setOf(4,5,6,7,8)\nprintln(\"Set1: $set1, Set2: $set2\")\nval vereinigung = set1 union set2\nprintln(\"Vereinigung: $vereinigung\")\nval schnitt = set1 intersect set2\nprintln(\"Schnittmenge: $schnitt\")\nval subset = set1 subtract set2\nprintln(\"Subtraktion: $subset\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 30
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.195",
   "versions": [
    {
     "start_checkpoint": 1616858354854,
     "literal": "val map = mapOf(\"Kotlin\" to 0, \"Java\" to 1, \"C\" to 2)\nprintln(\"unveränderbare Map: $map\")\n\nval map2 = mutableMapOf(\"AI1\" to \"Westfechtel\", \"AI2\" to \"Rauber\", \"AI3\" to \"Henrich\")\nprintln(\"veränderbare Map: $map2\")\nprintln(\"Wert zum Schlüssel AI2: ${map2[\"AI2\"]}\")\nmap2.put(\"AI4\", \"Jablonski\")\nprintln(\"veränderbare Map mit AI4: $map2\")\nmap2.remove(\"AI2\")\nprintln(\"veränderbare Map ohne AI2: $map2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 42
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.196",
   "versions": [
    {
     "start_checkpoint": 1616858354854,
     "literal": "val map = mapOf(\"AI1\" to \"Westfechtel\", \"AI2\" to \"Rauber\", \"AI3\" to \"Henrich\", \"AI4\" to \"Jablonski\")\nfor ((key, value) in map){\n    println(\"$key: $value\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.197",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.67",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.198",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "fun main(){\n    println(\"Hello World Kotlin.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.101"
   },
   "artifact_name": "c.199",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "main()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 0,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.102"
   },
   "artifact_name": "c.200",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "fun main(){\n    val name : String = \"Max\"\n    println(\"Hello World $name.\")\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.103",
    "1": "o.179",
    "2": "o.180"
   },
   "artifact_name": "c.201",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "fun main(){\n    val name : String = \"MAX\"\n    println(\"Hello World $name.toLowerCase().\") //Falsch\n    println(\"Hello World ${name.toLowerCase()}.\") //Richtig\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 5
     }
    },
    {
     "start_checkpoint": 1618400989368,
     "parent": "n.0.103",
     "literal": "fun main(){\n    val name : String = \"OLE\"\n    println(\"Hello World $name.toLowerCase().\") //Falsch\n    println(\"Hello World ${name.toLowerCase()}.\") //Richtig\n}\nmain()"
    },
    {
     "start_checkpoint": 1618400997236,
     "parent": "n.0.104",
     "literal": "fun main(){\n    val name : String = \"MAX\"\n    println(\"Hello World $name.toLowerCase().\") //Falsch\n    println(\"Hello World ${name.toLowerCase()}.\") //Richtig\n}\nmain()"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.104"
   },
   "artifact_name": "c.202",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val v1 : String = \"schreibgeschützte Variable\"\n//v1 = \"Test\"   //Fehler: Val cannot be reassigned\nvar v2 : String = \"veränderbare Variable\"\nv2 = \"Test\"\nprintln(\"$v1 - $v2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.105"
   },
   "artifact_name": "c.203",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val value : Int = foo()\nprintln(value)\n\n//const val constant : Int = foo()   -> Error\nconst val constant : Int = 5       //-> Kein Error\nprintln(constant)\n\nfun foo() : Int { //Gibt eine zufällige ganze Zahl zwischen 0 und 10 zurück\n    return (0..10).random()\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.106"
   },
   "artifact_name": "c.204",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.76",
     "literal": "val int1 : Int = 5\nval int2 = 5\nprintln(\"Datentyp von v1: ${v1::class.simpleName}, Datentyp von v2: ${v2::class.simpleName}\")\n\nval string1 : String = \"String 1\"\nval string2 = \"String 2\"\nprintln(\"Datentyp von string1: ${string1::class.simpleName}, Datentyp von string2: ${string2::class.simpleName}\") ",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 113
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.107"
   },
   "artifact_name": "c.205",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "fun vergleicheElemente(a: List<Int>, b: List<Int>){\n    if (a == b) println(\"vergleicheElemente: Gleich\")\n    else println(\"vergleicheElemente: Ungleich\")\n}\nfun vergleicheSpeicher(a: List<Int>, b: List<Int>){\n    if (a === b) println(\"vergleicheSpeicher: Gleich\")\n    else println(\"vergleicheSpeicher: Ungleich\")\n}\nval a = listOf(1,2,3)\nval b = listOf(1,2,3)\nvergleicheElemente(a, b)\nvergleicheSpeicher(a, b)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 23
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.108"
   },
   "artifact_name": "c.206",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.76",
     "literal": "fun vergleicheStrings(a: String, b: String){\n    if (a == b) println(\"vergleicheStrings: $a == $b\")\n    else if (a < b) println(\"vergleicheStrings: $a < $b\")\n    else println(\"vergleicheStrings: $a > $b\")\n}\nval a = \"Kotlin\"\nval b = \"Java\"\nvergleicheStrings(a,b)\nvergleicheStrings(b,a)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 21
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.109"
   },
   "artifact_name": "c.207",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "//const val PI = 3.14159f\nvar a = 50\nval b = 20\nvar res : Int\nval bool = false\na = a + 30\nres = a - b\nval output = \"a - b ist: $res.\"\nprintln(output)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.110"
   },
   "artifact_name": "c.208",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "fun foo(): String{\n    return \"TEST\"\n}\n\nfun show(a: String){\n    println(a)\n}\n\nfun main(){\n    val a = foo()\n    show(a)\n}\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.111"
   },
   "artifact_name": "c.209",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.76",
     "literal": "fun foo(a: Int = 0, b: Int = 0, c: Int = 0, d:Int = 0) {\n    println(\"a: $a, b: $b, c: $c, d: $d\")\n}\nfoo(1,2,1,2)\nfoo(1,2)\nfoo()\nfoo(b=2,d=2)\n//foo(b=2,d=2, 3, 4) -> Error: Mixing named and positioned arguments is not allowed",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 82
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.112"
   },
   "artifact_name": "c.210",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.76",
     "literal": "fun sum(a: Int, b: Int) = a+b\nprintln(sum(5,5))\n\nfun foo(num: Int) = if (num == 42) 42 else 0\nprintln(foo(42))\nprintln(foo(24))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.113"
   },
   "artifact_name": "c.211",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "fun sum(a: Int, b: Int) = println(\"Sum mit 2 Int-Parametern: ${a+b}\")\nfun sum(a: Int, b: Int, c: Int) = println(\"Sum mit 3 Int-Parametern: ${a+b+c}\")\nfun sum(a: Double, b: Double) = println(\"Sum mit 2 Double-Parametern: ${a+b}\")\nsum(2,3)\nsum(2,3,4)\nsum(2.0,3.0)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 11
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.114"
   },
   "artifact_name": "c.212",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.76",
     "literal": "fun foo(a: Int): String {\n    val res = if (a < 10) \n                  \"kleiner 10\"\n              else if (a == 10) \n                  \"gleich 10\"\n              else \n                  \"groeßer 10\"\n    return res\n}\nfun foo2(a: Int): String {\n    return if (a < 10) \n               \"kleiner 10\"\n           else if (a == 10) \n               \"gleich 10\"\n           else \n               \"groeßer 10\"\n}\nfun foo3(a: Int) = if (a < 10) \n                       \"kleiner 10\"\n                   else if (a == 10) \n                       \"gleich 10\"\n                   else \n                       \"groeßer 10\"\nval a = 10\nprintln(foo(a))\nprintln(foo2(a))\nprintln(foo3(a))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 26,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.115"
   },
   "artifact_name": "c.213",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.76",
     "literal": "val c = 'ä'\nwhen (c) {\n    'a', 'e', 'i', 'o', 'u' -> println(\"Vokal\")\n    'ä', 'ö', 'ü' -> {\n                        val res = \"Umlaut\"\n                        println(res)\n                     }\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> println(\"Zahl\")\n    else -> println(\"Kostante\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.116"
   },
   "artifact_name": "c.214",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.76",
     "literal": "val a: Any = 0\nval liste = listOf(0, 1, 2, 3)\nwhen (a) {\n    is Double -> println(\"$a ist vom Datentyp Double\")\n    is Long -> println(\"$a ist vom Datentyp Long\")\n    in liste -> println(\"$a ist in Liste $liste\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.117"
   },
   "artifact_name": "c.215",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val a = 10\nwhen {\n    a == 10 -> println(\"gleich 10\")\n    a < 10 -> println(\"kleiner 10\")\n    else -> println(\"groeßer 10\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.118"
   },
   "artifact_name": "c.216",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val intBereich = 0..10 //Bereich von 0 - 10\nprintln(\"Der Bereich $intBereich vom Typ ${intBereich::class.simpleName} geht von ${intBereich.first} bis ${intBereich.last} und umfasst ${intBereich.toList()}\")\n\nval start = 5\nval intBereichMitVariable = start..start+5 //Bereich von start bis start+5\nprintln(\"Der Bereich $intBereichMitVariable vom Typ ${intBereichMitVariable::class.simpleName} geht von ${intBereichMitVariable.first} bis ${intBereichMitVariable.last} und umfasst ${intBereichMitVariable.toList()}\")\n\nval charBereich = 'a'..'e' //Bereich von a bis e\nprintln(\"Der Bereich $charBereich vom Typ ${charBereich::class.simpleName} geht von ${charBereich.first} bis ${charBereich.last} und umfasst ${charBereich.toList()}\")\n\nval intBereichUntil = 0 until 10 //Bereich von 0 - 9\nprintln(\"Der Bereich $intBereichUntil vom Typ ${intBereichUntil::class.simpleName} geht von ${intBereichUntil.first} bis ${intBereichUntil.last} und umfasst ${intBereichUntil.toList()}\")\n\nvar umgekehrterIntBereich = 10 downTo 0 //Bereich von 10 - 0\nprintln(\"Der Bereich $umgekehrterIntBereich vom Typ ${umgekehrterIntBereich::class.simpleName} geht von ${umgekehrterIntBereich.first} bis ${umgekehrterIntBereich.last} und umfasst ${umgekehrterIntBereich.toList()}\")\n\nval intBereichSchrittweite = 0..10 step 2 //Bereich von 0 - 10 mit Schrittweite 2\nprintln(\"Der Bereich $intBereichSchrittweite vom Typ ${intBereichSchrittweite::class.simpleName} geht von ${intBereichSchrittweite.first} bis ${intBereichSchrittweite.last} und umfasst ${intBereichSchrittweite.toList()}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 17,
      "ch": 220
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.119"
   },
   "artifact_name": "c.217",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "for (i in 0..10){\n    print(\"$i \")\n}\nprintln()\nfor (i in 0 until 20){\n    print(\"$i \")\n}\nprintln()\nfor (i in 15 downTo 5 step 5){\n    print(\"$i \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.120"
   },
   "artifact_name": "c.218",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste = listOf(\"Kotlin\", \"Java\", \"C\", \"Python\")\nfor (i in liste){\n    print(\"$i \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.121"
   },
   "artifact_name": "c.219",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor (i in liste){\n    i = i*i\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.122"
   },
   "artifact_name": "c.220",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor (i in 0 until liste.size){\n    liste[i] = liste[i] * liste[i]\n}\nprintln(liste)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 13
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.123"
   },
   "artifact_name": "c.221",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste = mutableListOf(1,2,3,4,5)\nfor ((index, element) in liste.withIndex()){\n    println(\"An Stelle $index ist $element gespeichert\")\n    liste[index] = element * element\n}\nprintln(liste)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 13
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.124"
   },
   "artifact_name": "c.222",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste1 = (0..100 step 11).toList()\nval liste2 = (0..100 step 5).toList()\niloop@\nfor (i in liste1){\n    println(\"Aktuell untersucht: $i\")\n    for(j in liste2){\n        if(i == j && i != 0){\n            println(\"Gefunden $i\")\n            break@iloop\n        }\n    }\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.125"
   },
   "artifact_name": "c.223",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "var i = 0\nwhile (i<=10){\n    print(\"$i \")\n    i++\n}\ndo {\n    print(\"$i \")\n    i--\n} while(i >= 0)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.126"
   },
   "artifact_name": "c.224",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "repeat (10){\n    print(\"$it \")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.127"
   },
   "artifact_name": "c.225",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "fun Int.zehner() = if (this < 10) //Test, ob eine Zehnerstelle existiert\n                        -1\n                   else\n                        this % 100 / 10\n\nval zahl = 34291\nprintln(\"Die Zehnerstelle von der Zahl $zahl lautet ${zahl.zehner()}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 69
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.128"
   },
   "artifact_name": "c.226",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "//TODO\n\n//Test\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 170
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.129",
    "1": "o.148"
   },
   "artifact_name": "c.227",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.72",
     "literal": "//Lösung\nfun String.addNewLine() = \"$this\\n\"\n\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 170
     }
    },
    {
     "start_checkpoint": 1617008296329,
     "parent": "n.0.75",
     "literal": "//Lösung\nfun String.addNewLine() = \"$this\"\n\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.130"
   },
   "artifact_name": "c.228",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "//TODO\n\n//Test\nval liste1 = mutableListOf(0,1,2,3,4)\nval liste2 = mutableListOf(0,1,2,3,4)\nval sumListe = liste1 addAllElements liste2\nif (sumListe == listOf(0,2,4,6,8))\n    println(\"Richtig: $sumListe\")\nelse\n    println(\"Falsch: $sumListe. Das Ergebnis sollte eigentlich ${listOf(0,2,4,6,8)} beinhalten\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 95
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.131"
   },
   "artifact_name": "c.229",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "infix fun MutableList<Int>.addAllElements(to: MutableList<Int>): List<Int>{\n    for(i in 0 until this.size){\n        this[i] += to[i]\n    }\n    return this\n}\n\n//Test\nval liste1 = mutableListOf(0,1,2,3,4)\nval liste2 = mutableListOf(0,1,2,3,4)\nval sumListe = liste1 addAllElements liste2\nif (sumListe == listOf(0,2,4,6,8))\n    println(\"Richtig: $sumListe\")\nelse\n    println(\"Falsch: $sumListe. Das Ergebnis sollte eigentlich ${listOf(0,2,4,6,8)} beinhalten\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 95
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.132"
   },
   "artifact_name": "c.230",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int)\n\noperator fun Punkt.unaryMinus() = Punkt(-x, -y, -z)\n\nval punkt = Punkt(10, 20, 30)\nprintln(-punkt)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.133"
   },
   "artifact_name": "c.231",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "//TODO\n\n//Test\nval punkt1 = Punkt(10, 20, 30)\nval punkt2 = Punkt(30, 20, 10)\nval sumPunkt = punkt1 + punkt2\nif (sumPunkt == Punkt(40,40,40)){\n    println(\"Richtig: $sumPunkt\")\n}\nelse\n    println(\"Falsch: $sumPunkt. Das Ergebnis sollte eigentlich ${Punkt(40,40,40)} sein.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 88
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.134"
   },
   "artifact_name": "c.232",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "//Lösung\noperator fun Punkt.plus(other: Punkt) = Punkt(x+other.x, y+other.y,z+other.z)\n\n//Test\nval punkt1 = Punkt(10, 20, 30)\nval punkt2 = Punkt(30, 20, 10)\nval sumPunkt = punkt1 + punkt2\nif (sumPunkt == Punkt(40,40,40)){\n    println(\"Richtig: $sumPunkt\")\n}\nelse\n    println(\"Falsch: $sumPunkt. Das Ergebnis sollte eigentlich ${Punkt(40,40,40)} sein.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 88
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.135"
   },
   "artifact_name": "c.233",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste1 = listOf(1,2,3,4,5,6) //unveränderbare Liste mit Elementen des Datentyps Int\n//liste1.add(5) -> Error: Unresolved reference: add\nprintln(\"liste1: $liste1\")\n\nval liste2 = listOf<Int>() //leere, unveränderbare Liste mit Elementen des Datentyps Int\nprintln(\"liste2: $liste2\")\n\nval liste3 = mutableListOf(1,2.0,\"Kotlin\",4.5,'a','/') //veränderbare Liste mit Elementen des Datentyps Any\nliste3.removeAt(3)\nprintln(\"liste3: $liste3\")\n\nval liste4 = mutableListOf<String>() //leere, veränderbare Liste mit Elementen des Datentyps String\nliste4.add(\"Kotlin\")\nliste4.add(\"Java\")\n//liste4.add(10) -> Error: The integer literal does not conform to the expected type String\nprintln(\"liste4: $liste4\")\n\nval liste5 = List(5) { it } //unveränderbare Liste mit Elementen des Datentyps Int, die den Index beinhalten\nprintln(\"liste5: $liste5\")\n\nval liste6 = MutableList(10) { it*it } //veränderbare Liste mit Elementen des Datentyps Int, die den quadrierten Index beinhalten\nprintln(\"liste6: $liste6\")\n\nval liste7 = MutableList(5) { 0 } //veränderbare Liste mit Elementen des Datentyps Int, die 0 beinhalten\nliste7.add(10)\nprintln(\"liste7: $liste7\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 25
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.136"
   },
   "artifact_name": "c.234",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste = listOf(0,1,2,3,4)\nprintln(\"liste[1]: ${liste[1]}, liste.get(1): ${liste.get(1)}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 62
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.137"
   },
   "artifact_name": "c.235",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste = listOf(true, false, false, false, true, true)\nprintln(\"Länge der Liste $liste: ${liste.size}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 47
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.138"
   },
   "artifact_name": "c.236",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.84",
     "literal": "val array = arrayOf(1,2,3,4,5,6)\nprintln(\"array ist ein Array: ${array is Array<*>}\")\nval liste1 = array.toList()\n// liste.add(5) -> Error\nprintln(\"liste1 ist eine List: ${liste1 is List<*>}\")\nval liste2 = liste1.toMutableList()\nliste2.add(5) //-> funktioniert\nprintln(\"liste2 ist eine MutableList: ${liste2 is MutableList<*>}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 66
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.139"
   },
   "artifact_name": "c.237",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste = mutableListOf(1,2,3,4,5,6)\nprintln(\"Liste: $liste\")\nliste.fill(100)\nprintln(\"Gefüllte Liste: $liste\")\nliste.clear()\nprintln(\"Geleerte Liste: $liste\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 32
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.140"
   },
   "artifact_name": "c.238",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.84",
     "literal": "val liste = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste: $liste\")\nliste.add('f')\nliste.add(2, 'z')\nprintln(\"Liste mit hinzugefügten Elementen: $liste\")\nliste.remove('z')\nliste.removeAt(0)\nprintln(\"Liste mit entfernten Elementen: $liste\")\n\n//Kurzschreibweise\nprintln(\"\\nKurzschreibweise\")\nval liste2 = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste2: $liste2\")\nliste2 += 'f'\nliste2.add(2, 'z')\nprintln(\"Liste2 mit hinzugefügten Elementen: $liste2\")\nliste2 -= 'z'\nliste2.removeAt(0)\nprintln(\"Liste2 mit entfernten Elementen: $liste2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 18,
      "ch": 50
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.141"
   },
   "artifact_name": "c.239",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val liste = listOf(1,2,3,4,5,6)\nprintln(\"Ausgangsliste: $liste\")\nval teilliste = liste.subList(3, liste.size)\nprintln(\"Teilliste von 3 bis liste.size: $teilliste\")\nval teilliste2 = liste.take(3)\nprintln(\"Teilliste der ersten 3 Elemente: $teilliste2\")\nval teilliste3 = liste.takeLast(3)\nprintln(\"Teilliste der letzten 3 Elemente: $teilliste3\")\nval teilliste4 = liste.drop(3)\nprintln(\"Teilliste ohne die ersten 3 Elemente: $teilliste4\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 59
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.142"
   },
   "artifact_name": "c.240",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.84",
     "literal": "val liste = listOf(\"Kotlin\", \"Java\", \"Lua\", \"C\", \"Swift\")\nprintln(\"Ist 'Java' in der Liste: ${\"Java\" in liste}\")\nprintln(\"Ist 'Javascript' in der Liste: ${\"Javascript\" in liste}\")\nprintln(\"Welchen Index besitzt 'Java' in der Liste: ${liste.indexOf(\"Java\")}\")\nprintln(\"Welchen Index besitzt 'Javascript' in der Liste: ${liste.indexOf(\"Javascript\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 89
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.143"
   },
   "artifact_name": "c.241",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.84",
     "literal": "val liste = mutableListOf(0,1,2,3,4,5,6,7,8,9)\nprintln(\"Ausgangsliste: $liste\")\nprintln(\"Zufälliges Element: ${liste.random()}\")\nliste.shuffle()\nprintln(\"Zufällige Anordnung: ${liste}\")\nliste.sort()\nprintln(\"Wieder sortiert: ${liste}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 35
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.144"
   },
   "artifact_name": "c.242",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.84",
     "literal": "val set = setOf(1,2,3,4,5,1,2,3)\nprintln(\"unveränderbares Set: $set\")\nval set2 = mutableSetOf(1,2,3,4,5,1,2,3)\nprintln(\"veränderbares Set: $set2\")\nset2.remove(3)\nprintln(\"veränderbares Set ohne 3: $set2\")\nset2.add(10)\nprintln(\"veränderbares Set mit 10: $set2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 41
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.145"
   },
   "artifact_name": "c.243",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val set1 = setOf(1,2,3,4,5)\nval set2 = setOf(4,5,6,7,8)\nprintln(\"Set1: $set1, Set2: $set2\")\nval vereinigung = set1 union set2\nprintln(\"Vereinigung: $vereinigung\")\nval schnitt = set1 intersect set2\nprintln(\"Schnittmenge: $schnitt\")\nval subset = set1 subtract set2\nprintln(\"Subtraktion: $subset\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 30
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.146"
   },
   "artifact_name": "c.244",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.84",
     "literal": "val map = mapOf(\"Kotlin\" to 0, \"Java\" to 1, \"C\" to 2)\nprintln(\"unveränderbare Map: $map\")\n\nval map2 = mutableMapOf(\"AI1\" to \"Westfechtel\", \"AI2\" to \"Rauber\", \"AI3\" to \"Henrich\")\nprintln(\"veränderbare Map: $map2\")\nprintln(\"Wert zum Schlüssel AI2: ${map2[\"AI2\"]}\")\nmap2.put(\"AI4\", \"Jablonski\")\nprintln(\"veränderbare Map mit AI4: $map2\")\nmap2.remove(\"AI2\")\nprintln(\"veränderbare Map ohne AI2: $map2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 42
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.147"
   },
   "artifact_name": "c.245",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.102",
     "literal": "val map = mapOf(\"AI1\" to \"Westfechtel\", \"AI2\" to \"Rauber\", \"AI3\" to \"Henrich\", \"AI4\" to \"Jablonski\")\nfor ((key, value) in map){\n    println(\"$key: $value\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.246",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.67",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.247",
   "versions": [
    {
     "start_checkpoint": 1616859318783,
     "parent": "n.0.68",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.248",
   "versions": [
    {
     "start_checkpoint": 1616859318783,
     "parent": "n.0.68",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.249",
   "versions": [
    {
     "start_checkpoint": 1616859333029,
     "parent": "n.0.69",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.250",
   "versions": [
    {
     "start_checkpoint": 1616860423327,
     "parent": "n.0.70",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.251",
   "versions": [
    {
     "start_checkpoint": 1616860423327,
     "parent": "n.0.70",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.252",
   "versions": [
    {
     "start_checkpoint": 1617006907566,
     "parent": "n.0.72",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.253",
   "versions": [
    {
     "start_checkpoint": 1617006907566,
     "parent": "n.0.72",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.149"
   },
   "artifact_name": "c.254",
   "versions": [
    {
     "start_checkpoint": 1617025435363,
     "parent": "n.0.102",
     "literal": "//Lösung\nfun String.addNewLine() = \"$this\\n\"\n\nval zeile = \"Erweiterungsmethoden erweitern eine Klasse.\"\nif(zeile.addNewLine() == \"Erweiterungsmethoden erweitern eine Klasse.\\n\")\n    print(\"Richtig:\\n${zeile.addNewLine()}${zeile.addNewLine()}\")\nelse\n    print(\"Falsch:\\n${zeile.addNewLine()}${zeile.addNewLine()}\\nRichtig wäre:\\nErweiterungsmethoden erweitern eine Klasse.\\nErweiterungsmethoden erweitern eine Klasse.\\n\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 170
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.255",
   "versions": [
    {
     "start_checkpoint": 1617025435363,
     "parent": "n.0.76",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.256",
   "versions": [
    {
     "start_checkpoint": 1617025822464,
     "parent": "n.0.83",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.150"
   },
   "artifact_name": "c.257",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "val int1 : Int = 5 //explizite Zuweisung\nval int2 = 5 //implizierte Zuweisung\nprintln(\"Datentyp von int1: ${int1::class.simpleName}, Datentyp von int2: ${int2::class.simpleName}\")\n\nval string1 : String = \"String 1\"\nval string2 = \"String 2\"\nprintln(\"Datentyp von string1: ${string1::class.simpleName}, Datentyp von string2: ${string2::class.simpleName}\") ",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 113
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.151"
   },
   "artifact_name": "c.258",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "fun vergleicheStrings(a: String, b: String){\n    if (a == b) print(\"vergleicheStrings: $a == $b\")\n    else if (a < b) print(\"vergleicheStrings: $a < $b\" )\n    else print(\"vergleicheStrings: $a > $b\" )\n    print(\". Ergebnis von compareTo(): ${a.compareTo(b)}. \\n\")\n}\nval a = \"Kotlin\"\nval b = \"Java\"\nvergleicheStrings(a,b)\nvergleicheStrings(b,a)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 21
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.152"
   },
   "artifact_name": "c.259",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "fun foo(a: Int = 0, b: Int = 0, c: Int = 0, d: Int = 0) : String {\n    return \"a: $a, b: $b, c: $c, d: $d\"\n}\nprintln(\"foo(1,2,1,2): ${foo(1,2,1,2)}\")\nprintln(\"foo(1,2): ${foo(1,2)}\")\nprintln(\"foo(): ${foo()}\")\nprintln(\"foo(b=2,d=2): ${foo(b=2,d=2)}\")\n//foo(b=2,d=2, 3, 4) -> Error: Mixing named and positioned arguments is not allowed",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 82
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.260",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "fun failNothing(message: String): Nothing{\n    throw Exception(message)\n}\n\nfun failUnit(message: String): Unit{\n    throw Exception(message)\n}\n\nfun fooNothing(num: Int) : Int {\n                    return if (num == 42){\n                        42\n                    }\n                    else {\n                        failNothing(\"Falsch\")\n                    }\n}\n\n//fun fooUnit(num: Int) : Int {  //-> Error Type mismatch: inferred type is Unit but Int was expected\nfun fooUnit(num: Int) : Any {\n                    return if (num == 42){\n                        42\n                    }\n                    else {\n                        failUnit(\"Falsch\")\n                    }\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.153"
   },
   "artifact_name": "c.261",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "fun sum(a: Int, b: Int) = a+b\nprintln(\"sum(5,5): ${sum(5,5)}\")\n\nfun foo(num: Int) = if (num == 42) 42 else 0\nprintln(\"foo(42): ${foo(42)}\")\nprintln(\"foo(24): ${foo(24)}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 29
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.154"
   },
   "artifact_name": "c.262",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "//Standardfall\nfun foo(a: Int): String {\n    var res = \"\"\n    if (a < 10) \n        res = \"$a ist kleiner 10\"\n    else if (a == 10) \n        res = \"$a ist gleich 10\"\n    else \n        res = \"$a ist groeßer 10\"\n    return res\n}\n//Direkte Zuweisung des Wertes von res mit der if-Verzweigung\nfun foo1(a: Int): String {\n    val res = if (a < 10) \n                  \"$a ist kleiner 10\"\n              else if (a == 10) \n                  \"$a ist gleich 10\"\n              else \n                  \"$a ist groeßer 10\"\n    return res\n}\n//Voransetzen des returns\nfun foo2(a: Int): String {\n    return if (a < 10) \n               \"$a ist kleiner 10\"\n           else if (a == 10) \n               \"$a ist gleich 10\"\n           else \n               \"$a ist groeßer 10\"\n}\n//Anwendung der Kurzschreibweise von Methoden\nfun foo3(a: Int) = if (a < 10) \n                       \"$a ist kleiner 10\"\n                   else if (a == 10) \n                       \"$a ist gleich 10\"\n                   else \n                       \"$a ist groeßer 10\"\n//Test\nval a = 10\nprintln(foo(a))\nprintln(foo1(a))\nprintln(foo2(a))\nprintln(foo3(a))",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 42,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.155"
   },
   "artifact_name": "c.263",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "val c = 'ä'\nwhen (c) {\n    'a', 'e', 'i', 'o', 'u' -> println(\"Vokal\")\n    'ä', 'ö', 'ü' -> {\n                        val res = \"Umlaut\"\n                        println(res)\n                     }\n    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' -> println(\"Zahl\")\n    else -> println(\"Kostante\") //default-Fall\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.156"
   },
   "artifact_name": "c.264",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "val a: Any = 0\nval liste = listOf(0, 1, 2, 3)\nwhen (a) {\n    is Double -> println(\"$a ist vom Datentyp Double\") //ist die Variable vom Typ Double?\n    is Long -> println(\"$a ist vom Datentyp Long\") //ist die Variable vom Typ Long?\n    in liste -> println(\"$a ist in Liste $liste\") //ist die Variable in der Liste liste?\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.157"
   },
   "artifact_name": "c.265",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "fun typCheckerIf(a: Any) = \"\"//TODO\n    \nfun typCheckerWhen(a: Any) = \"\"//TODO\n    \n//Test\nval testInt = 1\nval testDouble = 1.0\nval testLong : Long = 100L\nval testSonstiges = \"Test\"\nval tests = listOf<Any>(testInt, testDouble, testLong, testSonstiges)\nfor(i in tests){\n    if((typCheckerIf(i) == typCheckerWhen(i)) && (i::class.simpleName == typCheckerIf(i) || typCheckerIf(i) == \"Sonstiges\"))\n        println(\"Richtig! $i ist vom Typ ${typCheckerIf(i)}\")\n    else\n        println(\"Falsch! $i ist vom Typ ${i::class.simpleName}, Ergebnis typCheckerIf: ${typCheckerIf(i)}, Ergebnis typCheckerWhen: ${typCheckerWhen(i)}\")   \n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 15,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.158"
   },
   "artifact_name": "c.266",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "literal": "//Lösung\nfun typCheckerIf(a: Any) = if (a is Int)\n                                \"Int\"\n                            else if (a is Double)\n                                \"Double\"\n                            else if (a is Long)\n                                \"Long\"\n                            else\n                                \"Sonstiges\"\n\n\nfun typCheckerWhen(a: Any) = when(a) {\n    is Int -> \"Int\"\n    is Double -> \"Double\"\n    is Long -> \"Long2\"\n    else -> \"Sonstiges\"\n}\n\n//Test\nval testInt = 1\nval testDouble = 1.0\nval testLong : Long = 100L\nval testSonstiges = \"Test\"\nval tests = listOf<Any>(testInt, testDouble, testLong, testSonstiges)\nfor(i in tests){\n    if((typCheckerIf(i) == typCheckerWhen(i)) && (i::class.simpleName == typCheckerIf(i) || typCheckerIf(i) == \"Sonstiges\"))\n        println(\"Richtig! $i ist vom Typ ${typCheckerIf(i)}\")\n    else\n        println(\"Falsch! $i ist vom Typ ${i::class.simpleName}, Ergebnis typCheckerIf: ${typCheckerIf(i)}, Ergebnis typCheckerWhen: ${typCheckerWhen(i)}\")   \n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 29,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.267",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.84",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.268",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.84",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "1": "o.159",
    "2": "o.160",
    "3": "o.161",
    "4": "o.162"
   },
   "artifact_name": "c.269",
   "versions": [
    {
     "start_checkpoint": 1617374727891,
     "parent": "n.0.86",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1617374738478,
     "parent": "n.0.87",
     "literal": "val array1 = arrayOf(1,2,3,4) //[1, 2, 3, 4] -> Int-Array\nprintln(array1[2]) //3\nprintln(array1.size) //4\n\nval array2 = Array(6) {0.0} //[0.0, 0.0, 0.0, 0.0, 0.0, 0.0] -> Double-Array\nprintln(array2[2]) //0.0\nprintln(array2.size) //6\narray2[3] = 5.0 //[0.0, 0.0, 0.0, 5.0, 0.0, 0.0]\nprintln(array2[3]) //5.0"
    },
    {
     "start_checkpoint": 1617374793459,
     "parent": "n.0.88",
     "literal": "val array1 = arrayOf(1,2,3,4) //[1, 2, 3, 4] -> Int-Array\nprintln(\"array1: $array1\")\nprintln(\"array1[2]: array1[2]\")\nprintln(\"array1.size: ${array1.size}\") //4\n\nval array2 = Array(6) {0.0} //[0.0, 0.0, 0.0, 0.0, 0.0, 0.0] -> Double-Array\nprintln(array2[2]) //0.0\nprintln(array2.size) //6\narray2[3] = 5.0 //[0.0, 0.0, 0.0, 5.0, 0.0, 0.0]\nprintln(array2[3]) //5.0"
    },
    {
     "start_checkpoint": 1617374818127,
     "parent": "n.0.89",
     "literal": "val array1 = arrayOf(1,2,3,4) //[1, 2, 3, 4] -> Int-Array\nprintln(\"array1: ${array1.toList()}\")\nprintln(\"array1[2]: array1[2]\")\nprintln(\"array1.size: ${array1.size}\") //4\n\nval array2 = Array(6) {0.0} //[0.0, 0.0, 0.0, 0.0, 0.0, 0.0] -> Double-Array\nprintln(array2[2]) //0.0\nprintln(array2.size) //6\narray2[3] = 5.0 //[0.0, 0.0, 0.0, 5.0, 0.0, 0.0]\nprintln(array2[3]) //5.0"
    },
    {
     "start_checkpoint": 1617374831543,
     "parent": "n.0.90",
     "literal": "val array1 = arrayOf(1,2,3,4) //[1, 2, 3, 4] -> Int-Array\nprintln(\"array1: ${array1.toList()}\")\nprintln(\"array1[2]: ${array1[2]}\")\nprintln(\"array1.size: ${array1.size}\") //4\n\nval array2 = Array(6) {0.0} //[0.0, 0.0, 0.0, 0.0, 0.0, 0.0] -> Double-Array\nprintln(array2[2]) //0.0\nprintln(array2.size) //6\narray2[3] = 5.0 //[0.0, 0.0, 0.0, 5.0, 0.0, 0.0]\nprintln(array2[3]) //5.0"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.163",
    "1": "o.173",
    "2": "o.174",
    "3": "o.175"
   },
   "artifact_name": "c.270",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.91",
     "literal": "val v1: Any = 0\nval v2: Int = v1 as Int\nprintln(\"v1: $v1, Datentyp: ${v1::class.simpleName}\")\nprintln(\"v2: $v2, Datentyp: ${v2::class.simpleName}\")\n\nval v3 = 20\n//val v4 = v3 as Float -> Error: ClassCastException\nval v4 = v3.toFloat()\nprintln(\"v3: $v3, Datentyp: ${v3::class.simpleName}\")\nprintln(\"v4: $v4, Datentyp: ${v4::class.simpleName}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 52
     }
    },
    {
     "start_checkpoint": 1617531350792,
     "parent": "n.0.92",
     "literal": "val any: Any = 0\nif (any is String){\n    val v1 = any as String\n    println(\"String\")\n}\nif (any is Int){\n    val v1 = any as Int\n    println(\"Int\")\n}\nif (any is Double){\n    val v1 = any as Double\n    println(\"Double\")\n}"
    },
    {
     "start_checkpoint": 1617531355599,
     "parent": "n.0.93",
     "literal": "val any: Any = \"Test\"\nif (any is String){\n    val v1 = any as String\n    println(\"String\")\n}\nif (any is Int){\n    val v1 = any as Int\n    println(\"Int\")\n}\nif (any is Double){\n    val v1 = any as Double\n    println(\"Double\")\n}"
    },
    {
     "start_checkpoint": 1617531362078,
     "parent": "n.0.94",
     "literal": "val any: Any = 0.0\nif (any is String){\n    val v1 = any as String\n    println(\"String\")\n}\nif (any is Int){\n    val v1 = any as Int\n    println(\"Int\")\n}\nif (any is Double){\n    val v1 = any as Double\n    println(\"Double\")\n}"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.164"
   },
   "artifact_name": "c.271",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val array1 = arrayOf(1,2,3,4) //-> Int-Array\nprintln(\"array1: ${array1.toList()}\")\nprintln(\"array1[2]: ${array1[2]}\")\nprintln(\"array1.size: ${array1.size}\")\nprintln()\n\nval array2 = Array(6) {0.0} //-> Double-Array\nprintln(\"array2: ${array2.toList()}\")\nprintln(\"array2[2]: ${array2[2]}\")\nprintln(\"array2.size: ${array2.size}\")\narray2[3] = 5.0\nprintln(\"array2 geändert: ${array2.toList()}\")\nprintln(\"array2[3]: ${array2[3]}\") //5.0",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 39
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.165"
   },
   "artifact_name": "c.272",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val arrayDim2 = Array(5) { Array(5) {\"Eintrag\"} } //Erzeugt ein 2 dimensionales String-Array der Größe 5x5, welches gefüllt ist mit \"Eintrag\"\nprintln(arrayDim2[0][3])",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 23
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.273",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val array = Array(5) { Array(5) { (0..20).random() } }\n\n//TODO",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.166"
   },
   "artifact_name": "c.274",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val array = Array(5) { Array(5) { (0..20).random() } }\nfor (col in array){\n    for (elem in col){\n        print(\" $elem\")\n    }\n    println()\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.167"
   },
   "artifact_name": "c.275",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val array = arrayOf(1,2,3,4,5,6)\nprintln(\"array ist ein Array: ${array is Array<*>}, array: $array\")\nval liste1 = array.toList()\n// liste.add(5) -> Error\nprintln(\"liste1 ist eine List: ${liste1 is List<*>}, liste1: $liste1\")\nval liste2 = liste1.toMutableList()\nliste2.add(5) //-> funktioniert\nprintln(\"liste2 ist eine MutableList: ${liste2 is MutableList<*>}, liste2: $liste2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 83
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.168"
   },
   "artifact_name": "c.276",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val liste = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste: $liste\")\nliste.add('f')\nliste.add(2, 'z')\nprintln(\"Liste mit hinzugefügten Elementen (f, z): $liste\")\nliste.remove('e')\nliste.removeAt(0)\nprintln(\"Liste mit entfernten Elementen (e, a): $liste\")\n\n//Kurzschreibweise\nprintln(\"\\nKurzschreibweise\")\nval liste2 = mutableListOf('a', 'b', 'c', 'd', 'e')\nprintln(\"Liste2: $liste2\")\nliste2 += 'f'\nliste2.add(2, 'z')\nprintln(\"Liste2 mit hinzugefügten Elementen (f, z): $liste2\")\nliste2 -= 'e'\nliste2.removeAt(0)\nprintln(\"Liste2 mit entfernten Elementen (e, a): $liste2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 18,
      "ch": 57
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.169"
   },
   "artifact_name": "c.277",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val liste = listOf(\"Kotlin\", \"Java\", \"Lua\", \"C\", \"Swift\")\nprintln(\"Ist 'Lua' in der Liste: ${\"Lua\" in liste}\")\nprintln(\"Ist 'Javascript' in der Liste: ${\"Javascript\" in liste}\")\nprintln(\"Welchen Index besitzt 'Lua' in der Liste: ${liste.indexOf(\"Lua\")}\")\nprintln(\"Welchen Index besitzt 'Javascript' in der Liste: ${liste.indexOf(\"Javascript\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 4,
      "ch": 89
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.170"
   },
   "artifact_name": "c.278",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val liste = mutableListOf(0,1,2,3,4,5,6,7,8,9)\nprintln(\"Ausgangsliste: $liste\")\nprintln(\"Zufälliges Element: ${liste.random()}\")\nprintln(\"Zufälliges Element zwischen 0 und 9: ${(0..10).random()}\")\nliste.shuffle()\nprintln(\"Zufällige Anordnung: ${liste}\")\nliste.sort()\nprintln(\"Wieder sortiert: ${liste}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 35
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.171"
   },
   "artifact_name": "c.279",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val set = setOf(1,6,3,4,5,1,2,3)\nprintln(\"unveränderbares Set: $set\")\nval set2 = mutableSetOf(1,6,3,4,5,1,2,3)\nprintln(\"veränderbares Set: $set2\")\nset2.remove(3)\nprintln(\"veränderbares Set ohne 3: $set2\")\nset2.add(10)\nprintln(\"veränderbares Set mit 10: $set2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 41
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.172"
   },
   "artifact_name": "c.280",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "literal": "val map = mapOf(\"Kotlin\" to 0, \"Java\" to 1, \"C\" to 2)\nprintln(\"Unveränderbare Map: $map\")\nprintln()\n\nval map2 = mutableMapOf(\"AI1\" to \"Westfechtel\", \"AI2\" to \"Rauber\", \"AI3\" to \"Henrich\")\nprintln(\"Veränderbare Map: $map2\")\nprintln(\"Wert zum Schlüssel AI2: ${map2[\"AI2\"]}\")\nmap2.put(\"AI4\", \"Jablonski\")\nprintln(\"Veränderbare Map mit AI4: $map2\")\nmap2.remove(\"AI2\")\nprintln(\"Veränderbare Map ohne AI2: $map2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 42
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.281",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.91",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.176"
   },
   "artifact_name": "c.282",
   "versions": [
    {
     "start_checkpoint": 1617617991364,
     "parent": "n.0.102",
     "literal": "val any: Any = 10.0\nif (any is String){\n    val v1 = any as String\n    println(\"Typ von v1: ${v1::class.simpleName}\")\n}\nif (any is Int){\n    val v1 = any as Int\n    println(\"Typ von v1: ${v1::class.simpleName}\")\n}\nif (any is Double){\n    val v1 = any as Double\n    println(\"Typ von v1: ${v1::class.simpleName}\")\n}\n\nval int: Int = 10\nprintln(\"Typ von int: ${int::class.simpleName}\")\nval float: Float = int.toFloat()\nprintln(\"Typ von float: ${float::class.simpleName}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 17,
      "ch": 51
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.177"
   },
   "artifact_name": "c.283",
   "versions": [
    {
     "start_checkpoint": 1617617991364,
     "parent": "n.0.102",
     "literal": "val any: Any = 10.0\nif (any is String){\n    val v1 = any\n    println(\"Typ von v1: ${v1::class.simpleName}\")\n}\nif (any is Int){\n    val v1 = any\n    println(\"Typ von v1: ${v1::class.simpleName}\")\n}\nif (any is Double){\n    val v1 = any\n    println(\"Typ von v1: ${v1::class.simpleName}\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.284",
   "versions": [
    {
     "start_checkpoint": 1617617991364,
     "parent": "n.0.95",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.285",
   "versions": [
    {
     "start_checkpoint": 1618221393623,
     "parent": "n.0.96",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.178"
   },
   "artifact_name": "c.286",
   "versions": [
    {
     "start_checkpoint": 1618320018172,
     "parent": "n.0.102",
     "literal": "fun List<List<Char>>.printMandala() {\n    for (zeile in this){\n        for (eintrag in zeile){\n            print(\"$eintrag\")\n        }\n        println()\n    }\n}\n\nval mandala1 = listOf(\n    listOf(' ', ' ', ' ', ' ', '/', '\\\\', ' ', ' ', ' ', ' '),\n    listOf(' ', ' ', ' ', '/', '=', '=', '\\\\', ' ', ' ', ' '),\n    listOf(' ', ' ', '/', '=', '/', '\\\\', '=', '\\\\', ' ', ' '),\n    listOf(' ', '/', '=', '/', '=', '=', '\\\\', '=', '\\\\', ' '),\n    listOf('/', '=', '/', '=', '/', '\\\\', '=', '\\\\', '=', '\\\\')\n)\n\nfun getMandala1(): List<List<Char>>{\n    val res = \n    \n}\n\nmandala1.printMandala()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 22,
      "ch": 22
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.287",
   "versions": [
    {
     "start_checkpoint": 1618320018172,
     "parent": "n.0.102",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  }
 ],
 "markdownCells": [
  {
   "artifact_name": "m.0",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.60",
     "markdown": "# Abschnitt 1 - Grundlagen\n## Einführung"
    }
   ]
  },
  {
   "artifact_name": "m.1",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.1",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```"
    },
    {
     "start_checkpoint": 1616498750386,
     "parent": "n.0.3",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Es muss keine Klasse erstellt werden. In Kotlin können Methoden auf die höchste Ebene geschrieben und ausgeführt werden.\n"
    },
    {
     "start_checkpoint": 1616499297669,
     "parent": "n.0.4",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Wegfallen der Klasse: In Kotlin können Methoden auf die höchste Ebene deklariert und aufgerufen werden.\n- Unterschiedlicher Methodensyntax: Methoden werden in Kotlin mit dem Schlüsselbegriff 'fun' gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java beschrieben durch void) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n"
    },
    {
     "start_checkpoint": 1616499338360,
     "parent": "n.0.5",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Wegfallen der Klasse: In Kotlin können Methoden auf die höchste Ebene deklariert und aufgerufen werden.\n- Unterschiedlicher Methodensyntax: Methoden werden in Kotlin mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java beschrieben durch void) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n"
    },
    {
     "start_checkpoint": 1616499351465,
     "parent": "n.0.6",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Wegfallen der Klasse: In Kotlin können Methoden auf die höchste Ebene deklariert und aufgerufen werden.\n- Unterschiedlicher Methodensyntax: Methoden werden in Kotlin mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch 'void') besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n"
    },
    {
     "start_checkpoint": 1616499363054,
     "parent": "n.0.7",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Wegfallen der Klasse: In Kotlin können Methoden auf die höchste Ebene deklariert und aufgerufen werden.\n- Unterschiedlicher Methodensyntax: Methoden werden in Kotlin mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n"
    },
    {
     "start_checkpoint": 1616499535627,
     "parent": "n.0.8",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Wegfallen der Klasse: In Kotlin können Methoden auf die höchste Ebene deklariert und aufgerufen werden.\n- Unterschiedlicher Methodensyntax: Methoden werden in Kotlin mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.\n"
    },
    {
     "start_checkpoint": 1616499708833,
     "parent": "n.0.9",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Wegfallen der Klasse: In Kotlin können Methoden auf die höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden in Kotlin mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.\n"
    },
    {
     "start_checkpoint": 1616499721636,
     "parent": "n.0.10",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: In Kotlin können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden in Kotlin mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.\n"
    },
    {
     "start_checkpoint": 1616499741207,
     "parent": "n.0.11",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.\n"
    },
    {
     "start_checkpoint": 1616499753498,
     "parent": "n.0.12",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println()`: Die Bibliotheksmethode `println()` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.\n"
    },
    {
     "start_checkpoint": 1616499759459,
     "parent": "n.0.13",
     "markdown": "## Lektion 1 - Hello World\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.\n"
    },
    {
     "start_checkpoint": 1616499788013,
     "parent": "n.0.14",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.\n"
    },
    {
     "start_checkpoint": 1616499833466,
     "parent": "n.0.15",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.\nDie Methode kann, wie in Java, mit ihrem Namen aufgerufen werden."
    },
    {
     "start_checkpoint": 1616499841067,
     "parent": "n.0.16",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.<br />\nDie Methode kann, wie in Java, mit ihrem Namen aufgerufen werden."
    },
    {
     "start_checkpoint": 1616499849985,
     "parent": "n.0.17",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.<br />\n<br />Die Methode kann, wie in Java, mit ihrem Namen aufgerufen werden."
    },
    {
     "start_checkpoint": 1616499858509,
     "parent": "n.0.18",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.<br />\nDie Methode kann, wie in Java, mit ihrem Namen aufgerufen werden."
    },
    {
     "start_checkpoint": 1616499890349,
     "parent": "n.0.19",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.<br />\n\nDie Methode kann, wie in Java, mit ihrem Namen aufgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.2",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.25",
     "markdown": "## Lektion 2 - Variablen"
    },
    {
     "start_checkpoint": 1616506989218,
     "parent": "n.0.26",
     "markdown": "## Lektion 2 - Variablen\nDiese Lektion behandelt Variablen, Datentypen und Vergleiche.\n\nVariablen lassen sich in Kotlin in 2 Arten unterglieder: *(Illustration)*\n- `val`: Beschreibt eine Variable mit *lesenden* Zugriff. Sobald sie einen Wert zugewiesen bekommt, kann dieser nicht mehr verändert, sondern nur abgerufen werden.\n- `var`: Beschreibt eine Variable mit *lesenden* und *schreibenden* Zugriff. Ihr Wert kann beliebig oft verändert werden."
    },
    {
     "start_checkpoint": 1616506999849,
     "parent": "n.0.27",
     "markdown": "## Lektion 2 - Variablen\nDiese Lektion behandelt Variablen, Datentypen und Vergleiche.\n\nVariablen lassen sich in Kotlin in 2 Arten unterglieder: *(Illustration)*\n- `val`: Beschreibt eine Variable mit *lesenden* Zugriff. Sobald sie einen Wert zugewiesen bekommt, kann dieser nicht mehr verändert, sondern nur abgerufen werden.\n- `var`: Beschreibt eine Variable mit *lesenden* und *schreibenden* Zugriff. Ihr Wert kann beliebig oft verändert werden.\n\nBeispiel:"
    },
    {
     "start_checkpoint": 1616507058313,
     "parent": "n.0.28",
     "markdown": "## Lektion 2 - Variablen\nDiese Lektion behandelt Variablen, Datentypen und Vergleiche.\n\nVariablen lassen sich in Kotlin in 2 Arten unterglieder: **(Illustration)**\n- `val`: Beschreibt eine Variable mit **lesenden** Zugriff. Sobald sie einen Wert zugewiesen bekommt, kann dieser nicht mehr verändert, sondern nur abgerufen werden.\n- `var`: Beschreibt eine Variable mit **lesenden** und **schreibenden** Zugriff. Ihr Wert kann beliebig oft verändert werden.\n\nBeispiel:"
    }
   ]
  },
  {
   "artifact_name": "m.3",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.30",
     "markdown": "## Lektion 3 - Methoden"
    },
    {
     "start_checkpoint": 1616591319024,
     "parent": "n.0.50",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\n\n### Parameter\n\n### Rückgabe\n- Nothing & Unit\n\n### Erweitert\n- Überladen\n- kurzschreibweise\n"
    },
    {
     "start_checkpoint": 1616591680074,
     "parent": "n.0.51",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 20%; text-align: center\">\n\n### Parameter\n\n### Rückgabe\n- Nothing & Unit\n\n### Erweitert\n- Überladen\n- kurzschreibweise\n"
    },
    {
     "start_checkpoint": 1616591687488,
     "parent": "n.0.52",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 20%; text-align: center\">\n\n### Parameter\n\n### Rückgabe\n- Nothing & Unit\n\n### Erweitert\n- Überladen\n- kurzschreibweise\n"
    },
    {
     "start_checkpoint": 1616591708423,
     "parent": "n.0.53",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 40%; text-align: center\">\n\n### Parameter\n\n### Rückgabe\n- Nothing & Unit\n\n### Erweitert\n- Überladen\n- kurzschreibweise\n"
    },
    {
     "start_checkpoint": 1616591715143,
     "parent": "n.0.54",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 30%; text-align: center\">\n\n### Parameter\n\n### Rückgabe\n- Nothing & Unit\n\n### Erweitert\n- Überladen\n- kurzschreibweise\n"
    },
    {
     "start_checkpoint": 1616591723947,
     "parent": "n.0.55",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 500px; text-align: center\">\n\n### Parameter\n\n### Rückgabe\n- Nothing & Unit\n\n### Erweitert\n- Überladen\n- kurzschreibweise\n"
    },
    {
     "start_checkpoint": 1616591732014,
     "parent": "n.0.56",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 700px; text-align: center\">\n\n### Parameter\n\n### Rückgabe\n- Nothing & Unit\n\n### Erweitert\n- Überladen\n- kurzschreibweise\n"
    },
    {
     "start_checkpoint": 1616591886115,
     "parent": "n.0.57",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 700px; text-align: center\">\n\nBeginnend mit dem Schlüsselwort `fun`, das eine Methode angkündigt, folgt der Name. Danach werden in runden Klammern, falls benötigt, die Parameter angegeben. Bevor der Methodenrumpf durch `{` beginnt, ist noch ein optionaler Rückgabetyp zu finden. Es ergibt sich folgender Syntax: <br />\n\n### Parameter\n\n### Rückgabe\n- Nothing & Unit\n\n### Erweitert\n- Überladen\n- kurzschreibweise\n"
    }
   ]
  },
  {
   "artifact_name": "m.4",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.30",
     "markdown": "## Lektion 4 - Kontrollstrukturen"
    }
   ]
  },
  {
   "artifact_name": "m.5",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.58",
     "markdown": "## Lektion 5 - Erweiterungsmethoden"
    }
   ]
  },
  {
   "artifact_name": "m.6",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "n.0.58",
     "markdown": "\n## Lektion 6 - Datenstrukturen"
    }
   ]
  },
  {
   "artifact_name": "m.7",
   "versions": [
    {
     "start_checkpoint": 1616500415041,
     "parent": "n.0.24",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.<br />\n\nDie Methode kann, wie in Java, mit ihrem Namen aufgerufen werden:"
    }
   ]
  },
  {
   "artifact_name": "m.8",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.60",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java.\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin.\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.<br />\n\nDie Methode kann, wie in Java, mit ihrem Namen aufgerufen werden:"
    }
   ]
  },
  {
   "artifact_name": "m.9",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.60",
     "markdown": "### Erweiterung\nDas \"Hello World\"-Programm wird nun so erweitert, dass dem \"Hello World\"-String eine Variable angehängt wird."
    }
   ]
  },
  {
   "artifact_name": "m.10",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "n.0.58",
     "markdown": "Der Methodenkopf und -aufruf verändern sich nicht. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt ein Wert zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;`. Während in Java nach jeder Anweisung ein Semikolon folgen muss, ist das in Kotlin nur noch der Fall, wenn mehrere Anweisungen in eine Zeile geschrieben werden. Ansonsten ist kein Semikolon notwendig.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n    \n| Java                                         | Kotlin                                       |\n|----------------------------------------------|----------------------------------------------|\n| <pre lang=\"java\"> \"Hello World\" + name </pre> | <pre lang=\"kotlin\"> \"Hello World \\$name\" </pre> |\n| <pre lang=\"java\"> String.format(\"Hello World %s\", name)</pre> |  |\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert bzw. angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden."
    }
   ]
  },
  {
   "artifact_name": "m.11",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.60",
     "markdown": "## Lektion 2 - Variablen\nDiese Lektion behandelt Variablen, Datentypen und Vergleiche.\n### Variablen\nVariablen lassen sich in Kotlin in 2 Arten unterglieder: **(Illustration)**\n- `val` (value): Beschreibt eine Variable mit **lesenden** Zugriff. Bei Deklarierung muss ihr direkt ein Wert zugewiesen werden, welcher nicht mehr verädnert werdne kann. Eine `val`-Variable in Kotlin ist mit einer `final`-Variable in Java zu vergleichen.\n- `var` (variable): Beschreibt eine Variable mit **lesenden** und **schreibenden** Zugriff. Ihr Wert kann beliebig oft verändert werden und muss nicht direkt bei Deklarierung gesetzt werden. Dies entspricht einer normalen Variable in Java.\n\nBeispiel:"
    }
   ]
  },
  {
   "artifact_name": "m.12",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "markdown": "Die Untergliederung der Variablen in `val` und `var` hat den Hintergrund, dass der funktionale Programmierstil, welcher einfacher zu verstehen ist, gefördert wird. <br />\nDer Syntax (Wissensstand jetzt) der Deklarierung und Initialsisierung ist folgendermaßen: <br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> (\"var\"|\"val\") name \":\" Datentyp \"=\" Wert.<br />\nEine weitere Besonderheit bei Variablen ist der Umgang mit `null`. Variablen, die mit dem eben kennengelernten Syntax initialisiert und deklariert werden, können nicht den Wert `null` annehmen:\n```kotlin \nvar test_null : Int = null //-> Null can not be a value of a non-null type Int\n```\nGenauer werden wir uns den Umgang mit `null` in Abschnitt 2 beschäftigen.<br />\n<br />\nKonstanten werden in Kotlin sind Variablen der Kategorie `val`, denen das Schlüsselwort `const` vorangestellt wird. Sie dürfen nur auf der Top-Level-Ebene oder in Objekten (näheres dazu in Abschnitt 3) deklariert werden:\n```kotlin \nconst val constant : Int = 24\n```\nAuf den ersten Blick scheinen schreibgeschützte Variablen und Konstanten den gleichen Nutzen haben: Einen unveränderlichen Wert speichern und zur Verfügung stellen. Im Grunde ist das richtig, jedoch gibt es einen großen Unterschied. Während `val`-Variablen als so genannte runtime constants angesehen werden, sind Konstenten compile-time constants. Praktisch bedeutet dies, dass eine Konstante immer den zugewiesenen Wert besitzt, während eine schreibgeschützte Variable bei jedem Ausführen einen unterschiedlichen, aber unveränderlichen Wert annehmen kann."
    },
    {
     "start_checkpoint": 1616585916649,
     "parent": "n.0.60",
     "markdown": "Die Untergliederung der Variablen in `val` und `var` hat den Hintergrund, dass der funktionale Programmierstil, welcher einfacher zu verstehen ist, gefördert wird. Es herrscht der Grundsatz: Überall wo es geht `val` statt `var`. **(andere Formulierung)**<br />\nDer Syntax (Wissensstand jetzt) der Deklarierung und Initialsisierung ist folgendermaßen: <br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> (\"var\"|\"val\") name \":\" Datentyp \"=\" Wert.<br />\nEine weitere Besonderheit bei Variablen ist der Umgang mit `null`. Variablen, die mit dem eben kennengelernten Syntax initialisiert und deklariert werden, können nicht den Wert `null` annehmen:\n```kotlin \nvar test_null : Int = null //-> Null can not be a value of a non-null type Int\n```\nGenauer werden wir uns den Umgang mit `null` in Abschnitt 2 beschäftigen.<br />\n<br />\nKonstanten werden in Kotlin sind Variablen der Kategorie `val`, denen das Schlüsselwort `const` vorangestellt wird. Sie dürfen nur auf der Top-Level-Ebene oder in Objekten (näheres dazu in Abschnitt 3) deklariert werden:\n```kotlin \nconst val constant : Int = 24\n```\nAuf den ersten Blick scheinen schreibgeschützte Variablen und Konstanten den gleichen Nutzen haben: Einen unveränderlichen Wert speichern und zur Verfügung stellen. Im Grunde ist das richtig, jedoch gibt es einen großen Unterschied. Während `val`-Variablen als so genannte runtime constants angesehen werden, sind Konstenten compile-time constants. Praktisch bedeutet dies, dass eine Konstante immer den zugewiesenen Wert besitzt, während eine schreibgeschützte Variable bei jedem Ausführen einen unterschiedlichen, aber unveränderlichen Wert annehmen kann."
    }
   ]
  },
  {
   "artifact_name": "m.13",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.60",
     "markdown": "### Datentypen\nKotlin ist - wie Java - eine statisch typisierte Programmiersprache. Das bedeutet, dass jeder Variable, jeder Ausdruck einen statischen Typ besitzt, der bei der Deklarierung festgelegt werden und bei Kompilierung erkennbar sein muss. Dies kann entweder explizit durch eine Datentypzuweisung (wie wir es bis jetzt gemacht haben) oder implizit durch eine direkte aussagekräftige Initialisierung erfolgen. In diesem Fall wird vom Compiler ein zum Wert passender Datentyp der Variable zugewiesen."
    }
   ]
  },
  {
   "artifact_name": "m.14",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.\n![Typhierarchie](https://assets.digitalocean.com/articles/alligator/boo.svg \"a title\")\n"
    },
    {
     "start_checkpoint": 1616585226477,
     "parent": "n.0.31",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.\n![Typhierarchie](images/typhierarchie.png \"a title\")\n"
    },
    {
     "start_checkpoint": 1616585354080,
     "parent": "n.0.32",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"heigth: 50px\">"
    },
    {
     "start_checkpoint": 1616585364359,
     "parent": "n.0.33",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 50px\">"
    },
    {
     "start_checkpoint": 1616585371315,
     "parent": "n.0.34",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 200px\">"
    },
    {
     "start_checkpoint": 1616585377369,
     "parent": "n.0.35",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 500px\">"
    },
    {
     "start_checkpoint": 1616585399297,
     "parent": "n.0.36",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 500px; float: left\">"
    },
    {
     "start_checkpoint": 1616585434963,
     "parent": "n.0.37",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\n<div style=\"width: 80%; float:left \">Anders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.</div>\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 20%; float: left\">"
    },
    {
     "start_checkpoint": 1616585502579,
     "parent": "n.0.38",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.<br />\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 20%; float: left\">"
    },
    {
     "start_checkpoint": 1616585508540,
     "parent": "n.0.39",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.<br />\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 20%\">"
    },
    {
     "start_checkpoint": 1616585527352,
     "parent": "n.0.40",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.<br />\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 20%; text-align: center\">"
    },
    {
     "start_checkpoint": 1616585537972,
     "parent": "n.0.41",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.<br />\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" >"
    },
    {
     "start_checkpoint": 1616585543966,
     "parent": "n.0.42",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.<br />\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 20%; text-align: center\">"
    }
   ]
  },
  {
   "artifact_name": "m.15",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "n.0.30",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin:\n```java\n    \n```"
    },
    {
     "start_checkpoint": 1616585916649,
     "parent": "n.0.43",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin:\n```java\nfinal static float PI = 3.14159f\nint a = 50;\nint b = 20\nfinal boolean b = false;\na = a - b\nSystem.out.println(\"a - b ist: \" + a + \".\")\n```"
    },
    {
     "start_checkpoint": 1616586162282,
     "parent": "n.0.44",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin:\n```java\nfinal static float PI = 3.14159f\nint a = 50;\nint b = 20\nfinal boolean b = false;\na = a - b\nString output = \"a - b ist: \" + a + \".\"\nSystem.out.println(output)\n```"
    },
    {
     "start_checkpoint": 1616586218316,
     "parent": "n.0.45",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin:\n```java\nfinal static float PI = 3.14159f;\nint a = 50;\nint b = 20;\nint res;\nfinal boolean b = false;\nres = a - b;\nString output = \"a - b ist: \" + res + \".\";\nSystem.out.println(output);\n```"
    },
    {
     "start_checkpoint": 1616586254771,
     "parent": "n.0.46",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin:\n```java\nfinal static float PI = 3.14159f;\nint a = 50;\nint b = 20;\nint res;\nfinal boolean b = false;\na = a + 30;\nres = a - b;\nString output = \"a - b ist: \" + res + \".\";\nSystem.out.println(output);\n```"
    },
    {
     "start_checkpoint": 1616586339268,
     "parent": "n.0.48",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin:\n```java\nfinal static float PI = 3.14159f;\nint a = 50;\nint b = 20;\nint res;\nfinal boolean bool = false;\na = a + 30;\nres = a - b;\nString output = \"a - b ist: \" + res + \".\";\nSystem.out.println(output);\n```"
    },
    {
     "start_checkpoint": 1616586523308,
     "parent": "n.0.49",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin und wählen Sie passende Variablentypen:\n```java\nfinal static float PI = 3.14159f;\nint a = 50;\nint b = 20;\nint res;\nfinal boolean bool = false;\na = a + 30;\nres = a - b;\nString output = \"a - b ist: \" + res + \".\";\nSystem.out.println(output);\n```"
    }
   ]
  },
  {
   "artifact_name": "m.16",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.<br />\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 20%; text-align: center\">\n\n### Vergleiche\nVergleiche in Kotlin sind einfacher und intuitiver als in Java. Der Grund dafür ist, dass nicht mehr zwischen elementaren und nicht-elementaren Datentypen unterschieden wird. Alle von Kotlin bereitgestellte Datentypen implementieren das `Comparable`-Interface und können somit mit `compareTo` verglichen werden. Jedoch muss man nicht die Methode zum Vergleichen aufrufen, sondern kann dies mit den bekannten Vergleichszeichen bewerkstelligen. Der Vorteil ist in Kotlin mit `==` immer der Inhalt der Variable, des Parameters verglichen wird und nicht wie in Java die Referenz. Außerdem sind dadurch auch einfach kleiner und größer Vergleiche möglich. Für einen Vergleich der Refernzen wurde in Kotlin das `===` eingeführt."
    }
   ]
  },
  {
   "artifact_name": "m.17",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin und wählen Sie passende Variablen.\n```java\nfinal static float PI = 3.14159f;\nint a = 50;\nint b = 20;\nint res;\nfinal boolean bool = false;\na = a + 30;\nres = a - b;\nString output = \"a - b ist: \" + res + \".\";\nSystem.out.println(output);\n```"
    }
   ]
  },
  {
   "artifact_name": "m.18",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 700px; text-align: center\">\n\nBeginnend mit dem Schlüsselwort `fun`, das eine Methode angkündigt, folgt der Name. Danach werden in runden Klammern, falls benötigt, die Parameter angegeben. Bevor der Methodenrumpf durch `{` beginnt, ist noch ein optionaler Rückgabetyp zu finden. Es ergibt sich folgender Syntax: <br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nFalls ein Rückgabetyp angegeben ist, muss etwas zurückgegeben werden. Dies wird mit `return` eingeleitet. Falls der Rückgabetyp fehlt, gibt die Methode nichts zurück, kann aber mit `return` beendet werden. Das Hauptprogramm besitzt den Methodenkopf:\n```kotlin\nfun main(){ ... }\n//oder\nfun main(args: Array) { ... }\n```"
    }
   ]
  },
  {
   "artifact_name": "m.19",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "### Parameter\nEs können einer Methode beliebig viele Parameter übergeben werden. Dabei wird zuerst der Name und danach der Datentyp angegeben. Sie sind mit einem Doppelpunkt getrennt. Außerdem kann jedem Parameter ein default-Wert zugewiesen werden. Wird der Parameter bei Methodenaufruf weggelassen wird er auf diesen gesetzt. Falls kein default-Wert festgelegt wurde, wird der Parameter mit dem default-Wert des Datentyps gefüllt. Es können auch bestimmte Parameter mit deren Namen im Methodenaufrug angesprochen werden. Dann ist die Reihenfolge der mit Namen genannten Übergabeparameer unwichtig. Es sollte jedoch nur eine Form der Übergabe angewendet werden, da dies sonst zu einer falschen Positionierung führen kann.<br />\nSyntax der Parameter:<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />"
    }
   ]
  },
  {
   "artifact_name": "m.20",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Kollektion (zum Beispiel ein Array) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:80%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl 42 ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falschhe Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 20%; float:left\">\n\n\n### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen, und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ (falls, Kontrollstrukturen vorkommen) implizit ermittelt."
    }
   ]
  },
  {
   "artifact_name": "m.21",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "#### Überladen\nDas Überladen von Methoden ist auch in Kotlin möglich. Einzige Einschränkung ist, dass der Compiler - genauso wie in Java - das Parameterprofil der unterschiedlichen Methoden voeinander unterscheiden kann."
    }
   ]
  },
  {
   "artifact_name": "m.22",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "## Lektion 4 - Kontrollstrukturen\nIn dieser Lektion werden die Kontrollstrukturen in Kotlin behandelt und Ranges eingeführt."
    }
   ]
  },
  {
   "artifact_name": "m.23",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "### `if`-Verzweigung\nDie simpelste Art der Verzweigung ist `if`. In Verbindung mit `else` und `else if` können so mehrere Fälle definiert, geprüft und nach deren Ergebnis gehandelt werden. Falls nur eine Anweisung einem Fall zugeordnet wird, können die geschweiften Klammern weggelassen werden.\n```kotlin\nfun foo(a: Int): String {\n    if (a < 10) \n        return \"kleiner 10\"\n    else if (a == 10) \n        return \"gleich 10\"\n    else {\n        val b = 20\n        return \"groeßer 10\"\n    }\n}\n```\nEine Neuerung ist, dass falls eine `if`-Verzweigung einen Wert zurückgibt dieser auch direkt einer Variable zugewiesen werden kann oder bei einer Methode zurückgegeben werden kann."
    }
   ]
  },
  {
   "artifact_name": "m.24",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "### `when`-Verzweigung\nEine weitere Art der Verzweigung ist `when`. Diese ähnelt von der Funktionalität an Javas `switch`. Das Schlüsselwort mit dem ein `when`-Block eingeleitet wird, ist `when`. In runden Klammern muss daraufhin die zu untersuchende Variable folgen. In dem Block steht links der Vergleichswert (die Vergleichswerte mit Komma getrennt) und rechts die Anweisung. Diese kann als Einzeiler ohne geschweifte Klammern geschrieben werden oder als Block mit. Getrennt werden die Seite mit mit `->`. Anders als in Java muss nicht nach jedem Block ein `break` stehen. Standardmäßig wird nach dem Ausführen der rechten Seite der `when`-Block verlassen. Ein \"Durchrustschen\" geschieht nicht.\n"
    }
   ]
  },
  {
   "artifact_name": "m.25",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "Es können aber auch weiterführende Vergleiche angestellt werden. Mit `is` kann überprüft werden, ob die zu untersuchende Variable einen bestimmten Datentyp besitzt. `in` hingegen sucht die Variable in einer Datenstruktur."
    }
   ]
  },
  {
   "artifact_name": "m.26",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "Außerdem kann `when` auch ein Ersatz für `if` sein. Dies bietet sich vor Allem an, wenn die `if`-Verzweigung mehr als 2 Fälle besitzt. Dabei wird die zu untersuchende Variable nicht zu Beginn, sondern auf die linken Seite mit einem boolschen Ausdruck geschrieben. Folgender Code mit einer `if`-Verzweigung soll nun mit einer `when`-Verzweigung ersetzt werden:\n```kotlin\nval a = 10\nif (a < 10) \n   println(\"gleich 10\")\nelse if (a < 10) \n   println(\"kleiner 10\")\nelse \n   println(\"groeßer 10\")\n```"
    }
   ]
  },
  {
   "artifact_name": "m.27",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "### `for`-Schleife\nAuch sind `for`-Schleifen in Kotlin zu finden. Jedoch weicht ihr Syntax stark von dem in Java ab. Der normale Aufbau einer `for`-Schleife mit 3 Teilen fällt weg und wird durch Breiche oder auch Ranges ersetzt.\n#### Bereiche\nBereiche sind eine Folge von Elementen, die einen definierten Start- und Endpunkt besitzen. Die beiden Werte werden durch `..` getrennt. Kotlin stellt Bereiche des Typs `Int`, `Long` und `Char` bereit. Der Endwert ist dabei immer der letzte Wert des Bereichs.\nDer Startwert kann mit `first` und der Endwert mit `last` adressiert werden. Ein Bereich des Datentyps `Range` ist aufsteigend mit einer Schrittweite von 1. Alle anderen Bereiche besitzen den Datentyp `Progression` und sind mächtiger. So kann ein Bereich entweder mit `reversed()` oder mit dem Schlüsselwort `downTo` statt `..` erzeugt werden. Soll die Obergrenze exklusiv sein, hilft zudem das Schlüsselwort `until` anstelle von `..`. Zur schöneren Darstellung oder zum Erzeugen einfacher Listen können Bereiche in Listen oder Sets umgewandelt werden mit `toList()` beziehungsweise `toSet()` (näheres zu Datenstrukturen in [Lektion 6](#Lektion-6---Datenstrukturen))."
    }
   ]
  },
  {
   "artifact_name": "m.28",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "#### Schleife\nDie aus Java bekannte 3 gliedrige `for`-Schleife wird in Kotlin durch eine Schleife über einen Bereich ersetzt. Das benötigt Schlüsselwort lautet `in`."
    }
   ]
  },
  {
   "artifact_name": "m.29",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "Anstelle über eine Range kann aber auch über eine Kollektion (zum Beispiel eine Liste) iteriert werden."
    }
   ]
  },
  {
   "artifact_name": "m.30",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "Dabei ist aber zu beachten, dass das Element nicht in der Schleife verändert werden kann. Dies geht nur mit einem Bereich und Zugriff auf den Index an der aktuellen Stelle."
    }
   ]
  },
  {
   "artifact_name": "m.31",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "Eine elegantere Lösung ist die Option über die Liste und den aktuellen Index zu iterieren. Dies ist mit Hilfe von `.withIndex()` möglich. Ein ähnlicher Fall ist die Itereriung über Maps. Dies wird in [Lektion 6](#Lektion-6---Datenstrukturen) behandelt."
    }
   ]
  },
  {
   "artifact_name": "m.32",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "#### `break`\nIn Kotlin kann mit Hilfe von `break` die aktuelle oder eine bestimmte Schleife abgebrochen werden. Der 2. Fall benötigt eine Bezeichnung der abzubrechenden Schleife. Dies kann mit `@` gefolgt von dem Namen vor der Schleife gemacht werden. Der Name der Schleife inklusive dem `@` wird in der Schleife dem `break` angehängt."
    }
   ]
  },
  {
   "artifact_name": "m.33",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "### `while`-Schleife\nDie `while`-Schleife ist identisch zu der in Java. Zusätzlich zu der normalen `while`-Schleife gibt es auch die `do-while`-Schleife."
    }
   ]
  },
  {
   "artifact_name": "m.34",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "n.0.60",
     "markdown": "### `repeat`-Schleife\nDie `repeat`-Schleife ist vor Allem an Anfänger:innen gerichtet. Es wird lediglich ein exklusiver Endwert angegeben, zu dem von 0 aus hochgezählt wird. In der Schleife kann auf den aktuelle Durchlauf mit `it` zugegriffen werden."
    }
   ]
  },
  {
   "artifact_name": "m.35",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "Der Methodenkopf und -aufruf verändern sich nicht. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt ein Wert zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;`. Während in Java nach jeder Anweisung ein Semikolon folgen muss, ist das in Kotlin nur noch der Fall, wenn mehrere Anweisungen in eine Zeile geschrieben werden. Ansonsten ist kein Semikolon notwendig.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n    \n| Java                                         | Kotlin                                       |\n|----------------------------------------------|----------------------------------------------|\n| <pre lang=\"java\"> \"Hello World\" + name </pre> | <pre lang=\"kotlin\"> \"Hello World \\$name\" </pre> |\n| <pre lang=\"java\"> String.format(\"Hello World %s\", name)</pre> |  |\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert bzw. angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    }
   ]
  },
  {
   "artifact_name": "m.36",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "## Lektion 5 - Weitere Methodentypen\nIn dieser Lektion werden weitere Methodentypen behandelt.\n### Erweiterungsmethoden\nErweiterungsfunktionen können eine bestehende Klasse einfach durch eine Methode, die außerhalb der Klasse definiert wird, erweitern. Dies findet vor Allem Anwendung bei Klassen, der keine Objektmethode hinzugefügt werden kann. Beispielsweise die Klassen der Datentypen. Im folgenden Beispiel wird die Klasse `Int` mit einer Methode erweitert, die die Zehnerstelle zurückgibt:"
    }
   ]
  },
  {
   "artifact_name": "m.37",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "In dem Beispiel wird der Klasse `Int` eine Erweiterungsmethode `zehner` hinzugefügt. Dies wird dadruch gekennzeichnet, dass die zu erweiternde Klasse (hier: `Int`) mit `.` getrennt vor dem Namen der Methode (hier: `zehner`) steht. Da keine weiteren Parameter benötigt werden, bleiben diese leer. Auf das Objekt, auf den die Methode aufgerufen wird, kann mit `this` zugegriffen werden.<br />\nEs ist außerdem zu beachten, dass Erweiterungsmethoden **immer** von Objektmethoden überdeckt werden. "
    }
   ]
  },
  {
   "artifact_name": "m.38",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "#### Aufgabe\nErweitern Sie die Klasse `String` mit der Methode `addNewLine`, die am Ende des Strings einem Zeilenumbruch (`'\\n'`) hinzufügt. Vervollständigen Sie dazu das folgende Grundgerüst:"
    }
   ]
  },
  {
   "artifact_name": "m.39",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "### `infix`-Methoden\nBereits kennengelertne Beispiele von `infix`-Methoden sind bei Bereichen zu finden. Anstelle von konkreten Methodenaufrufen werden Schlüsselworte bereitgestellt, die auf eine bestimmte `infix`-Methode verweisen. Dadurch wird der Code näher an den Sprachgebrauch angegliedert, was die Verständlichkeit fördert. Diesen Methoden wird das Schlüsselwort `infix` vorangestellt. Vor den Methodenname getrennt mit einem `.` wird der Datentyp des ersten Objekts angegeben, ähnlich zu eienr Erweiterungsmethode. In den Parametern der des Zweiten zusammen mit dem Namen des Parameters. Auf den \"ersten\" Parameter kann wieder mit `this` zugegriffen werden.\n```kotlin\n5 until 10 //infix\n5.until(10) //umgewandelt\ninfix fun Int.until(to: Int): IntRange //Methodenkopf\n```\nEs können beliebige `infix`-Methoden implementiert werden, falls das Schlüsselwort noch nicht besetzt ist."
    }
   ]
  },
  {
   "artifact_name": "m.40",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "#### Aufgabe\nEine weit verbreitete Operation ist das Addieren der Inhalt 2er Listen. Schreiben Sie eine `infix`-Methode mit der 2 Listen vom Typ `MutableList<Int>` mit dem Schlüsselwort `addAllElements` elementweise addiert und als neue Liste vom Typ `List<Int>` zurückgegeben werden. Es kann angenommen werden, dass beide Listen gleich viele Elemente besitzen."
    }
   ]
  },
  {
   "artifact_name": "m.41",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "### `operator`-Methoden\nEinige Anweisungen shene auf den ersten Block nach `infix`-Methoden aus, sind aber keine. Dies ist immer der Fall, wenn mathematische Zeichen im Spiel sind. Für diese gibt es keine `infix`-Methoden, da sie auf sogenannte `operator`-Methoden abgebildet werden. Sie werden auf Methoden mit bestimmten Namen abgebildet. So wird aus `5 + 10` im Hintergund `5.plus(10)` aufgerufen. Weitere Beispiele:\n\n| Ausdruck | Aufruf         |\n|----------|----------------|\n| +a       | a.unaryPlus()  |\n| a++    | a.inc()       |\n| -a       | a.unaryMinus() |\n| a--    | a.dec()       |\n| !a       | a.not()        |\n| a + b    | a.plus(b)      |\n| a - b    | a.minus(b)     |\n| a * b    | a.times(b)     |\n| a / b    | a.div(b)       |\n| a..b     | a.rangeTo(b)   |\n\nDer Methodenkopf einer `operator`-Methode ähnelt dem einer `infix`-Methode. Statt dem Schlüsselword `infix` wird nun aber `operator` benutzt. Im Folgenden wird eine Datenklasse (näheres dazu in Abschnitt 3) `Punkt` definiert und den unären Operator `-` implementiert.\n"
    }
   ]
  },
  {
   "artifact_name": "m.42",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "#### Aufgabe\nErweitern Sie die Datenklasse `Punkt`, sodass zwei Punkte mit dem Operator `+`addiert werden können."
    }
   ]
  },
  {
   "artifact_name": "m.43",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "## Lektion 6 - Datenstrukturen\nIn dieser Lektion werden ausgewählte Datenstrukturen in Kotlin vorgestellt."
    }
   ]
  },
  {
   "artifact_name": "m.44",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "### Array\nDie Datenstruktur des Arrays sollte bereits umfänglich bekannt sein. Die Funktionsweise unterscheidet sich nicht von Java, abgesehen von der Inititalisierung. Diese kann entweder mit dem Schlüselwort `arrayOf` erfolgen, falls alle Werte bereits vorliegen. Ansonsten kann ein leeres Array mit einer festgelegten Länge mit dem Ausdruck `Array(Länge) {Standardwert}` definiert werden.\n```kotlin\nval array1 = arrayOf(1,2,3,4) //[1, 2, 3, 4] -> Int-Array\nprintln(array1[2]) //3\nprintln(array1.size) //4\n\nval array2 = Array(6) {0.0} //[0.0, 0.0, 0.0, 0.0, 0.0, 0.0] -> Double-Array\nprintln(array2[2]) //0.0\nprintln(array2.size) //6\narray2[3] = 5.0 //[0.0, 0.0, 0.0, 5.0, 0.0, 0.0]\nprintln(array2[3]) //5.0\n```\n\nMehrdimensionale Arrays können, wie in Java, erstellt werden, indem in ein Element eines eindimensionales Arrays ein weiteres Array zu finden ist.\n```kotlin\nval arrayDim2 = Array(5) { Array(5) {\"Eintrag\"} } //Erzeugt ein 2 dimensionales String-Array der Größe 5x5, welches gefüllt ist mit \"Eintrag\"\nprintln(arrayDim2[0][3]) //\"Eintrag\"\n````\n\n[Weiterführende Informationen](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/)"
    }
   ]
  },
  {
   "artifact_name": "m.45",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "### Liste\nAufgrund einer größeren Flexibilität und besseren Implementierung in Kotlin sind Listen gegenüber Arrays zu bevorzugen. Ähnlich zu den zwei verschiedene Variablentypen (`val`/`var`), sind Listen ebenso in Veränderbare (`MutableList`) und Unveränderbare (`List`) aufgeteilt. Währund die `MutableList` an eine klassische `List` in Java erinnert, können die Einträge einer Kotlin-`List` im Nachhinein nicht verändert werden. Außerdem können in einer Liste nur Elemente eines Typs gespeichert werden.\n#### Inititalisierung\nEine Liste kann, ähnlich zu einem Array, mit der Methode `listOf()` beziehungsweise `mutableListOf()` erzeugt werden. Als Parameter können die Listeneinträge übergeben werden. Falls sie leer sind, muss der Datentyp der Elemente der Liste angegeben werden. Außerdem kann auch der bereits bei Arrays kennengelernte Konstruktor angewendet werden. Dabei muss die (festgesetzte) Länge angegeben werden. In den geschweiften Klammern kann mit dem Schlüsselwort `it` der Index des zu füllenden Elements abgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.46",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "#### Veränderbar & Unveränderbar\nBei der Betrachtung des obigen Beispiels könnten einige Fragen aufgekommen sein, die mit der Veränderbarkeit der Listen und deren Variablen zutun hat. Deswegen folgt hier noch eine ausführlichere Erklärung.<br />\nBeginnen wir mit einer Betrachtung der Listentypen: \n- Eine Liste der Klasse `List` können Sie sich vorstellen wie eine Liste mit einer, bei Inititalisierung festgelegter, Länge. In der Liste sind Variablen des Typs `val` gespeichert. Diese können also nicht verändert werden. \n- Eine Liste der Klasse `MutableList` hat keine festgelegte Länge und kann folglich beliebig verlängert oder verkürzt werden. Die Elemente sind Variablen des Typs `var` und können verändert werden.\n\nGespeichert werden die Listen in eigenen Variablen, die wiederum verschieden veränderbar sein können:\n- Wird eine beliebige in einer Variable des Typs `val` gespeichert, kann der Variable keine neue Liste zugewiesen werden. Dies hat jedoch **keinen** Einfluss auf den Typ der Liste.\n- Wird eine beliebige in einer Variable des Typs `var` gespeichert, kann die gespeicherte Liste durch eine Andere ersetzt werden. Die Variable ist veränderbar. Falls jedoch eine unveränderbare Liste in einer veränderbaren Variable gespeichert wird, kann die Liste dennoch nicht bearbeitet werden.\n\nZusammenfassung:\n\n|     | List                                                      | MutableList                                                     |\n|-----|-----------------------------------------------------------|-----------------------------------------------------------------|\n| val | Variable und Liste können nicht verändert werden          | Variable kann nicht verändert werden, die Liste hingegen schon. |\n| val | Variable kann verändert werden, die Liste hingegen nicht. | Variable und Liste können verändert werden                      |"
    }
   ]
  },
  {
   "artifact_name": "m.47",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "#### Ausgewählte Operationen\nIm folgenden werden einige ausgewählte Operationen vorgestellt, mit denen Listen bearbeitet werden können.\n##### Zugriff auf ein Element\nDer Zugriff auf ein Element kann entweder wie bei einem Array mit dem Index erfolgen oder mit der Methode `get()` und dem Index als Parameter."
    }
   ]
  },
  {
   "artifact_name": "m.48",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "##### Länge\nDie Länge einer Liste kann mit der Variable `size` abgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.49",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "##### Konvertierung\nListen können untereinander mit `toList()` konvertiert werden. Außerdem können auch andere Datenstrukturen mit dieser Methode zu einer Liste konvertiert werden."
    }
   ]
  },
  {
   "artifact_name": "m.50",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "##### Füllen und Leeren\nEine veränderbare Liste kann mit `fill()` mit dem übergebenden Element gefüllt werden. `clear()` hingegen löscht alle Elemente aus der Liste."
    }
   ]
  },
  {
   "artifact_name": "m.51",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "##### Hinzufügen und Löschen\nEiner veränderbaren Liste können Elemente mit `add()` hinzugefügt werden. Wird nur das Element übergeben, wird dieses am Ende angehängt. Wenn zusätzlich noch ein Index angegeben wird, wird das Element an diesem Index eingefügt.<br />\nMit `remove()` beziehungsweise `removeAt()` kann ein bestimmtes Element oder ein Element an einem bestimmten Index entfernt werden.<br />\nFür eine bessere Übersitlichkeit kann das Hinzufügen beziehungsweise Löschen mit Operatoren abgekürzt werden. Diese ersetzen aber lediglich die einfachen Methoden `add` und `remove`."
    }
   ]
  },
  {
   "artifact_name": "m.52",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "##### Teilliste\nEine Teilliste kann mit der Methode `subList()` erstellt werden. Dabei müssen als Parameter der Startindex (inklusive) und Endindex (exklusive) angegeben werden.<br />\nEine neue Liste mit den ersten n Elementen einer Liste kann mit `take(n)` erzeugt werden. Sollen hingegen die letzten n Elemente zurückgegeben werden findet `takeLast(n)` Anwendung.<br />\nEine Liste ohne die ersten n Elemente kann mit der Methode `drop(n)` erlangt werden."
    }
   ]
  },
  {
   "artifact_name": "m.53",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "##### Suchen\nMit dem Schlüsselwort `in` kann ein Element in einer Liste gesucht werden. Zurückgegeben wird `true`, falls es gefunden wurde, ansonsten `false`.<br />\nWenn statt der Information, ob das Element vorhanden ist, zusätzlich noch der Index gesucht ist, kann die Methode `indexOf()` benutzt werden. Falls das übergebene Element nicht in der Liste vorhanden ist, wird `-1` zurückgegeben."
    }
   ]
  },
  {
   "artifact_name": "m.54",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "##### Anordnen und Zufall\nEin zufälliges Element einer Liste kann mit `random()` erhalten werden.<br />\nSoll eine veränderbaren Liste durchmischt werden, findet `shuffle()` Anwendung.<br />\nDas sortieren einer veränderbaren Liste funktioniert unter Anderem mit `sort()`. [Genauere Informationen](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort.html) zum Sortieren"
    }
   ]
  },
  {
   "artifact_name": "m.55",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "### Set\nSets sind primitivere Listen. Ihre Elemente sind ungeordnet und besitzen keine Duplikate. Nur ein `MutableSet` kann nur vergrößert oder verkleinert werden. Erzeugen kann man sie mit `setOf()` beziehungsweise `mutableSetOf()`."
    }
   ]
  },
  {
   "artifact_name": "m.56",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "Ein Vorteil an Sets ist, dass einfache Operationen mit Mengen ermöglicht werden. Mit `union` oder `+` können zwei Sets vereinigt werden, `intersect` gibt eine Schnittmenge zurück und `subtract` entfernt alle Elemente der ersten Menge aus der Zweiten."
    }
   ]
  },
  {
   "artifact_name": "m.57",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "### Map\nMaps sind eine Liste von Paaren von Elementen. Ein Paar besteht aus einem Schlüssel (key) und einem Wert (value). Der Schlüssel ist dabei der \"Index\" eines Werts. Eine unveränderbare Map gehört der Klasse `Map` an und kann mit `mapOf()` erzeugt werden, während eine Veränderbare der Klasse `MutableMap` zugeordnet wird und mit Hilfe von `mutableMapOf()` initialisiert werden. Ein Eintrag in der Map wird mit dem Schlüssel und dem Wert verbunden mit `to` gekennzeichnet. Zu einer veränderbaren Map kann mit der Methode `put()` ein Eintrag hinzugefügt werden. Dazu müssen der Schlüssel und der Wert mit Komma getrennt übergeben werden. Ein Eintrag kann mit `remove()` und der übergabe des Schlüssels entfernt werden."
    }
   ]
  },
  {
   "artifact_name": "m.58",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "Eine Map kann mit einer `for`-Schleife einfach durchlaufen werden:"
    }
   ]
  },
  {
   "artifact_name": "m.59",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "n.0.60",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/>\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann "
    }
   ]
  },
  {
   "artifact_name": "m.60",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "# Abschnitt 1 - Grundlagen\n## Einführung"
    }
   ]
  },
  {
   "artifact_name": "m.61",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java.\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin.\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.<br />\n\nDie Methode kann, wie in Java, mit ihrem Namen aufgerufen werden:"
    }
   ]
  },
  {
   "artifact_name": "m.62",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### Erweiterung\nDas \"Hello World\"-Programm wird nun so erweitert, dass dem \"Hello World\"-String eine Variable angehängt wird."
    }
   ]
  },
  {
   "artifact_name": "m.63",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Der Methodenkopf und -aufruf verändern sich nicht. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt ein Wert zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;`. Während in Java nach jeder Anweisung ein Semikolon folgen muss, ist das in Kotlin nur noch der Fall, wenn mehrere Anweisungen in eine Zeile geschrieben werden. Ansonsten ist kein Semikolon notwendig.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n    \n| Java                                         | Kotlin                                       |\n|----------------------------------------------|----------------------------------------------|\n| <pre lang=\"java\"> \"Hello World\" + name </pre> | <pre lang=\"kotlin\"> \"Hello World \\$name\" </pre> |\n| <pre lang=\"java\"> String.format(\"Hello World %s\", name)</pre> |  |\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert bzw. angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    }
   ]
  },
  {
   "artifact_name": "m.64",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "## Lektion 2 - Variablen\nDiese Lektion behandelt Variablen, Datentypen und Vergleiche.\n### Variablen\nVariablen lassen sich in Kotlin in 2 Arten unterglieder: **(Illustration)**\n- `val` (value): Beschreibt eine Variable mit **lesenden** Zugriff. Bei Deklarierung muss ihr direkt ein Wert zugewiesen werden, welcher nicht mehr verädnert werdne kann. Eine `val`-Variable in Kotlin ist mit einer `final`-Variable in Java zu vergleichen.\n- `var` (variable): Beschreibt eine Variable mit **lesenden** und **schreibenden** Zugriff. Ihr Wert kann beliebig oft verändert werden und muss nicht direkt bei Deklarierung gesetzt werden. Dies entspricht einer normalen Variable in Java.\n\nBeispiel:"
    }
   ]
  },
  {
   "artifact_name": "m.65",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Die Untergliederung der Variablen in `val` und `var` hat den Hintergrund, dass der funktionale Programmierstil, welcher einfacher zu verstehen ist, gefördert wird. Es herrscht der Grundsatz: Überall wo es geht `val` statt `var`. **(andere Formulierung)**<br />\nDer Syntax (Wissensstand jetzt) der Deklarierung und Initialsisierung ist folgendermaßen: <br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> (\"var\"|\"val\") name \":\" Datentyp \"=\" Wert.<br />\nEine weitere Besonderheit bei Variablen ist der Umgang mit `null`. Variablen, die mit dem eben kennengelernten Syntax initialisiert und deklariert werden, können nicht den Wert `null` annehmen:\n```kotlin \nvar test_null : Int = null //-> Null can not be a value of a non-null type Int\n```\nGenauer werden wir uns den Umgang mit `null` in Abschnitt 2 beschäftigen.<br />\n<br />\nKonstanten werden in Kotlin sind Variablen der Kategorie `val`, denen das Schlüsselwort `const` vorangestellt wird. Sie dürfen nur auf der Top-Level-Ebene oder in Objekten (näheres dazu in Abschnitt 3) deklariert werden:\n```kotlin \nconst val constant : Int = 24\n```\nAuf den ersten Blick scheinen schreibgeschützte Variablen und Konstanten den gleichen Nutzen haben: Einen unveränderlichen Wert speichern und zur Verfügung stellen. Im Grunde ist das richtig, jedoch gibt es einen großen Unterschied. Während `val`-Variablen als so genannte runtime constants angesehen werden, sind Konstenten compile-time constants. Praktisch bedeutet dies, dass eine Konstante immer den zugewiesenen Wert besitzt, während eine schreibgeschützte Variable bei jedem Ausführen einen unterschiedlichen, aber unveränderlichen Wert annehmen kann."
    }
   ]
  },
  {
   "artifact_name": "m.66",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### Datentypen\nKotlin ist - wie Java - eine statisch typisierte Programmiersprache. Das bedeutet, dass jeder Variable, jeder Ausdruck einen statischen Typ besitzt, der bei der Deklarierung festgelegt werden und bei Kompilierung erkennbar sein muss. Dies kann entweder explizit durch eine Datentypzuweisung (wie wir es bis jetzt gemacht haben) oder implizit durch eine direkte aussagekräftige Initialisierung erfolgen. In diesem Fall wird vom Compiler ein zum Wert passender Datentyp der Variable zugewiesen."
    }
   ]
  },
  {
   "artifact_name": "m.67",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.<br />\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 20%; text-align: center\">\n\n### Vergleiche\nVergleiche in Kotlin sind einfacher und intuitiver als in Java. Der Grund dafür ist, dass nicht mehr zwischen elementaren und nicht-elementaren Datentypen unterschieden wird. Alle von Kotlin bereitgestellte Datentypen implementieren das `Comparable`-Interface und können somit mit `compareTo` verglichen werden. Jedoch muss man nicht die Methode zum Vergleichen aufrufen, sondern kann dies mit den bekannten Vergleichszeichen bewerkstelligen. Der Vorteil ist in Kotlin mit `==` immer der Inhalt der Variable, des Parameters verglichen wird und nicht wie in Java die Referenz. Außerdem sind dadurch auch einfach kleiner und größer Vergleiche möglich. Für einen Vergleich der Refernzen wurde in Kotlin das `===` eingeführt."
    }
   ]
  },
  {
   "artifact_name": "m.68",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin und wählen Sie passende Variablen.\n```java\nfinal static float PI = 3.14159f;\nint a = 50;\nint b = 20;\nint res;\nfinal boolean bool = false;\na = a + 30;\nres = a - b;\nString output = \"a - b ist: \" + res + \".\";\nSystem.out.println(output);\n```"
    }
   ]
  },
  {
   "artifact_name": "m.69",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 700px; text-align: center\">\n\nBeginnend mit dem Schlüsselwort `fun`, das eine Methode angkündigt, folgt der Name. Danach werden in runden Klammern, falls benötigt, die Parameter angegeben. Bevor der Methodenrumpf durch `{` beginnt, ist noch ein optionaler Rückgabetyp zu finden. Es ergibt sich folgender Syntax: <br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nFalls ein Rückgabetyp angegeben ist, muss etwas zurückgegeben werden. Dies wird mit `return` eingeleitet. Falls der Rückgabetyp fehlt, gibt die Methode nichts zurück, kann aber mit `return` beendet werden. Das Hauptprogramm besitzt den Methodenkopf:\n```kotlin\nfun main(){ ... }\n//oder\nfun main(args: Array) { ... }\n```"
    }
   ]
  },
  {
   "artifact_name": "m.70",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### Parameter\nEs können einer Methode beliebig viele Parameter übergeben werden. Dabei wird zuerst der Name und danach der Datentyp angegeben. Sie sind mit einem Doppelpunkt getrennt. Außerdem kann jedem Parameter ein default-Wert zugewiesen werden. Wird der Parameter bei Methodenaufruf weggelassen wird er auf diesen gesetzt. Falls kein default-Wert festgelegt wurde, wird der Parameter mit dem default-Wert des Datentyps gefüllt. Es können auch bestimmte Parameter mit deren Namen im Methodenaufrug angesprochen werden. Dann ist die Reihenfolge der mit Namen genannten Übergabeparameer unwichtig. Es sollte jedoch nur eine Form der Übergabe angewendet werden, da dies sonst zu einer falschen Positionierung führen kann.<br />\nSyntax der Parameter:<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />"
    }
   ]
  },
  {
   "artifact_name": "m.71",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Kollektion (zum Beispiel ein Array) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:80%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl 42 ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falschhe Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 20%; float:left\">\n\n\n### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen, und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ (falls, Kontrollstrukturen vorkommen) implizit ermittelt."
    },
    {
     "start_checkpoint": 1616857853619,
     "parent": "n.0.62",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Kollektion (zum Beispiel ein Array) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:80%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl 42 ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falschhe Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 20%; float:left\">\n\n<div style=\"clear:both\"></div>\n### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen, und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ (falls, Kontrollstrukturen vorkommen) implizit ermittelt."
    },
    {
     "start_checkpoint": 1616857990572,
     "parent": "n.0.63",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Kollektion (zum Beispiel ein Array) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:80%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl 42 ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falschhe Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 20%; float:left\">\n\n<div style=\"clear:both\"></div>\n### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen, und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ (falls, Kontrollstrukturen vorkommen) implizit ermittelt."
    },
    {
     "start_checkpoint": 1616858001954,
     "parent": "n.0.64",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Kollektion (zum Beispiel ein Array) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:70%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl 42 ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falschhe Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 30%; float:left\">\n\n<div style=\"clear:both\"></div>\n### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen, und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ (falls, Kontrollstrukturen vorkommen) implizit ermittelt."
    },
    {
     "start_checkpoint": 1616858001954,
     "parent": "n.0.64",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Kollektion (zum Beispiel ein Array) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:70%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl 42 ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falschhe Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 30%; float:left\">\n\n<div style=\"clear:both\"></div>\n### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen, und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ (falls, Kontrollstrukturen vorkommen) implizit ermittelt."
    },
    {
     "start_checkpoint": 1616858010596,
     "parent": "n.0.65",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Kollektion (zum Beispiel ein Array) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:70%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl 42 ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falschhe Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 30%; float:left\">\n\n<div style=\"clear:both\"></div>\n\n### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen, und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ (falls, Kontrollstrukturen vorkommen) implizit ermittelt."
    },
    {
     "start_checkpoint": 1616858010596,
     "parent": "n.0.65",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Kollektion (zum Beispiel ein Array) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:70%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl 42 ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falschhe Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 30%; float:left\">\n\n<div style=\"clear:both\"></div>\n\n### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen, und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ (falls, Kontrollstrukturen vorkommen) implizit ermittelt."
    }
   ]
  },
  {
   "artifact_name": "m.72",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "#### Überladen\nDas Überladen von Methoden ist auch in Kotlin möglich. Einzige Einschränkung ist, dass der Compiler - genauso wie in Java - das Parameterprofil der unterschiedlichen Methoden voeinander unterscheiden kann."
    }
   ]
  },
  {
   "artifact_name": "m.73",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "## Lektion 4 - Kontrollstrukturen\nIn dieser Lektion werden die Kontrollstrukturen in Kotlin behandelt und Ranges eingeführt."
    }
   ]
  },
  {
   "artifact_name": "m.74",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### `if`-Verzweigung\nDie simpelste Art der Verzweigung ist `if`. In Verbindung mit `else` und `else if` können so mehrere Fälle definiert, geprüft und nach deren Ergebnis gehandelt werden. Falls nur eine Anweisung einem Fall zugeordnet wird, können die geschweiften Klammern weggelassen werden.\n```kotlin\nfun foo(a: Int): String {\n    if (a < 10) \n        return \"kleiner 10\"\n    else if (a == 10) \n        return \"gleich 10\"\n    else {\n        val b = 20\n        return \"groeßer 10\"\n    }\n}\n```\nEine Neuerung ist, dass falls eine `if`-Verzweigung einen Wert zurückgibt dieser auch direkt einer Variable zugewiesen werden kann oder bei einer Methode zurückgegeben werden kann."
    }
   ]
  },
  {
   "artifact_name": "m.75",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### `when`-Verzweigung\nEine weitere Art der Verzweigung ist `when`. Diese ähnelt von der Funktionalität an Javas `switch`. Das Schlüsselwort mit dem ein `when`-Block eingeleitet wird, ist `when`. In runden Klammern muss daraufhin die zu untersuchende Variable folgen. In dem Block steht links der Vergleichswert (die Vergleichswerte mit Komma getrennt) und rechts die Anweisung. Diese kann als Einzeiler ohne geschweifte Klammern geschrieben werden oder als Block mit. Getrennt werden die Seite mit mit `->`. Anders als in Java muss nicht nach jedem Block ein `break` stehen. Standardmäßig wird nach dem Ausführen der rechten Seite der `when`-Block verlassen. Ein \"Durchrustschen\" geschieht nicht.\n"
    }
   ]
  },
  {
   "artifact_name": "m.76",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Es können aber auch weiterführende Vergleiche angestellt werden. Mit `is` kann überprüft werden, ob die zu untersuchende Variable einen bestimmten Datentyp besitzt. `in` hingegen sucht die Variable in einer Datenstruktur."
    }
   ]
  },
  {
   "artifact_name": "m.77",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Außerdem kann `when` auch ein Ersatz für `if` sein. Dies bietet sich vor Allem an, wenn die `if`-Verzweigung mehr als 2 Fälle besitzt. Dabei wird die zu untersuchende Variable nicht zu Beginn, sondern auf die linken Seite mit einem boolschen Ausdruck geschrieben. Folgender Code mit einer `if`-Verzweigung soll nun mit einer `when`-Verzweigung ersetzt werden:\n```kotlin\nval a = 10\nif (a < 10) \n   println(\"gleich 10\")\nelse if (a < 10) \n   println(\"kleiner 10\")\nelse \n   println(\"groeßer 10\")\n```"
    }
   ]
  },
  {
   "artifact_name": "m.78",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### `for`-Schleife\nAuch sind `for`-Schleifen in Kotlin zu finden. Jedoch weicht ihr Syntax stark von dem in Java ab. Der normale Aufbau einer `for`-Schleife mit 3 Teilen fällt weg und wird durch Breiche oder auch Ranges ersetzt.\n#### Bereiche\nBereiche sind eine Folge von Elementen, die einen definierten Start- und Endpunkt besitzen. Die beiden Werte werden durch `..` getrennt. Kotlin stellt Bereiche des Typs `Int`, `Long` und `Char` bereit. Der Endwert ist dabei immer der letzte Wert des Bereichs.\nDer Startwert kann mit `first` und der Endwert mit `last` adressiert werden. Ein Bereich des Datentyps `Range` ist aufsteigend mit einer Schrittweite von 1. Alle anderen Bereiche besitzen den Datentyp `Progression` und sind mächtiger. So kann ein Bereich entweder mit `reversed()` oder mit dem Schlüsselwort `downTo` statt `..` erzeugt werden. Soll die Obergrenze exklusiv sein, hilft zudem das Schlüsselwort `until` anstelle von `..`. Zur schöneren Darstellung oder zum Erzeugen einfacher Listen können Bereiche in Listen oder Sets umgewandelt werden mit `toList()` beziehungsweise `toSet()` (näheres zu Datenstrukturen in [Lektion 6](#Lektion-6---Datenstrukturen))."
    }
   ]
  },
  {
   "artifact_name": "m.79",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "#### Schleife\nDie aus Java bekannte 3 gliedrige `for`-Schleife wird in Kotlin durch eine Schleife über einen Bereich ersetzt. Das benötigt Schlüsselwort lautet `in`."
    }
   ]
  },
  {
   "artifact_name": "m.80",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Anstelle über eine Range kann aber auch über eine Kollektion (zum Beispiel eine Liste) iteriert werden."
    }
   ]
  },
  {
   "artifact_name": "m.81",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Dabei ist aber zu beachten, dass das Element nicht in der Schleife verändert werden kann. Dies geht nur mit einem Bereich und Zugriff auf den Index an der aktuellen Stelle."
    }
   ]
  },
  {
   "artifact_name": "m.82",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Eine elegantere Lösung ist die Option über die Liste und den aktuellen Index zu iterieren. Dies ist mit Hilfe von `.withIndex()` möglich. Ein ähnlicher Fall ist die Itereriung über Maps. Dies wird in [Lektion 6](#Lektion-6---Datenstrukturen) behandelt."
    }
   ]
  },
  {
   "artifact_name": "m.83",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "#### `break`\nIn Kotlin kann mit Hilfe von `break` die aktuelle oder eine bestimmte Schleife abgebrochen werden. Der 2. Fall benötigt eine Bezeichnung der abzubrechenden Schleife. Dies kann mit `@` gefolgt von dem Namen vor der Schleife gemacht werden. Der Name der Schleife inklusive dem `@` wird in der Schleife dem `break` angehängt."
    }
   ]
  },
  {
   "artifact_name": "m.84",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### `while`-Schleife\nDie `while`-Schleife ist identisch zu der in Java. Zusätzlich zu der normalen `while`-Schleife gibt es auch die `do-while`-Schleife."
    }
   ]
  },
  {
   "artifact_name": "m.85",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### `repeat`-Schleife\nDie `repeat`-Schleife ist vor Allem an Anfänger:innen gerichtet. Es wird lediglich ein exklusiver Endwert angegeben, zu dem von 0 aus hochgezählt wird. In der Schleife kann auf den aktuelle Durchlauf mit `it` zugegriffen werden."
    }
   ]
  },
  {
   "artifact_name": "m.86",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "## Lektion 5 - Weitere Methodentypen\nIn dieser Lektion werden weitere Methodentypen behandelt.\n### Erweiterungsmethoden\nErweiterungsfunktionen können eine bestehende Klasse einfach durch eine Methode, die außerhalb der Klasse definiert wird, erweitern. Dies findet vor Allem Anwendung bei Klassen, der keine Objektmethode hinzugefügt werden kann. Beispielsweise die Klassen der Datentypen. Im folgenden Beispiel wird die Klasse `Int` mit einer Methode erweitert, die die Zehnerstelle zurückgibt:"
    }
   ]
  },
  {
   "artifact_name": "m.87",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "In dem Beispiel wird der Klasse `Int` eine Erweiterungsmethode `zehner` hinzugefügt. Dies wird dadruch gekennzeichnet, dass die zu erweiternde Klasse (hier: `Int`) mit `.` getrennt vor dem Namen der Methode (hier: `zehner`) steht. Da keine weiteren Parameter benötigt werden, bleiben diese leer. Auf das Objekt, auf den die Methode aufgerufen wird, kann mit `this` zugegriffen werden.<br />\nEs ist außerdem zu beachten, dass Erweiterungsmethoden **immer** von Objektmethoden überdeckt werden. "
    }
   ]
  },
  {
   "artifact_name": "m.88",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "#### Aufgabe\nErweitern Sie die Klasse `String` mit der Methode `addNewLine`, die am Ende des Strings einem Zeilenumbruch (`'\\n'`) hinzufügt. Vervollständigen Sie dazu das folgende Grundgerüst:"
    }
   ]
  },
  {
   "artifact_name": "m.89",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### `infix`-Methoden\nBereits kennengelertne Beispiele von `infix`-Methoden sind bei Bereichen zu finden. Anstelle von konkreten Methodenaufrufen werden Schlüsselworte bereitgestellt, die auf eine bestimmte `infix`-Methode verweisen. Dadurch wird der Code näher an den Sprachgebrauch angegliedert, was die Verständlichkeit fördert. Diesen Methoden wird das Schlüsselwort `infix` vorangestellt. Vor den Methodenname getrennt mit einem `.` wird der Datentyp des ersten Objekts angegeben, ähnlich zu eienr Erweiterungsmethode. In den Parametern der des Zweiten zusammen mit dem Namen des Parameters. Auf den \"ersten\" Parameter kann wieder mit `this` zugegriffen werden.\n```kotlin\n5 until 10 //infix\n5.until(10) //umgewandelt\ninfix fun Int.until(to: Int): IntRange //Methodenkopf\n```\nEs können beliebige `infix`-Methoden implementiert werden, falls das Schlüsselwort noch nicht besetzt ist."
    }
   ]
  },
  {
   "artifact_name": "m.90",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "#### Aufgabe\nEine weit verbreitete Operation ist das Addieren der Inhalt 2er Listen. Schreiben Sie eine `infix`-Methode mit der 2 Listen vom Typ `MutableList<Int>` mit dem Schlüsselwort `addAllElements` elementweise addiert und als neue Liste vom Typ `List<Int>` zurückgegeben werden. Es kann angenommen werden, dass beide Listen gleich viele Elemente besitzen."
    }
   ]
  },
  {
   "artifact_name": "m.91",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### `operator`-Methoden\nEinige Anweisungen shene auf den ersten Block nach `infix`-Methoden aus, sind aber keine. Dies ist immer der Fall, wenn mathematische Zeichen im Spiel sind. Für diese gibt es keine `infix`-Methoden, da sie auf sogenannte `operator`-Methoden abgebildet werden. Sie werden auf Methoden mit bestimmten Namen abgebildet. So wird aus `5 + 10` im Hintergund `5.plus(10)` aufgerufen. Weitere Beispiele:\n\n| Ausdruck | Aufruf         |\n|----------|----------------|\n| +a       | a.unaryPlus()  |\n| a++    | a.inc()       |\n| -a       | a.unaryMinus() |\n| a--    | a.dec()       |\n| !a       | a.not()        |\n| a + b    | a.plus(b)      |\n| a - b    | a.minus(b)     |\n| a * b    | a.times(b)     |\n| a / b    | a.div(b)       |\n| a..b     | a.rangeTo(b)   |\n\nDer Methodenkopf einer `operator`-Methode ähnelt dem einer `infix`-Methode. Statt dem Schlüsselword `infix` wird nun aber `operator` benutzt. Im Folgenden wird eine Datenklasse (näheres dazu in Abschnitt 3) `Punkt` definiert und den unären Operator `-` implementiert.\n"
    }
   ]
  },
  {
   "artifact_name": "m.92",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "#### Aufgabe\nErweitern Sie die Datenklasse `Punkt`, sodass zwei Punkte mit dem Operator `+`addiert werden können."
    }
   ]
  },
  {
   "artifact_name": "m.93",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "## Lektion 6 - Datenstrukturen\nIn dieser Lektion werden ausgewählte Datenstrukturen in Kotlin vorgestellt."
    }
   ]
  },
  {
   "artifact_name": "m.94",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### Array\nDie Datenstruktur des Arrays sollte bereits umfänglich bekannt sein. Die Funktionsweise unterscheidet sich nicht von Java, abgesehen von der Inititalisierung. Diese kann entweder mit dem Schlüselwort `arrayOf` erfolgen, falls alle Werte bereits vorliegen. Ansonsten kann ein leeres Array mit einer festgelegten Länge mit dem Ausdruck `Array(Länge) {Standardwert}` definiert werden.\n```kotlin\nval array1 = arrayOf(1,2,3,4) //[1, 2, 3, 4] -> Int-Array\nprintln(array1[2]) //3\nprintln(array1.size) //4\n\nval array2 = Array(6) {0.0} //[0.0, 0.0, 0.0, 0.0, 0.0, 0.0] -> Double-Array\nprintln(array2[2]) //0.0\nprintln(array2.size) //6\narray2[3] = 5.0 //[0.0, 0.0, 0.0, 5.0, 0.0, 0.0]\nprintln(array2[3]) //5.0\n```\n\nMehrdimensionale Arrays können, wie in Java, erstellt werden, indem in ein Element eines eindimensionales Arrays ein weiteres Array zu finden ist.\n```kotlin\nval arrayDim2 = Array(5) { Array(5) {\"Eintrag\"} } //Erzeugt ein 2 dimensionales String-Array der Größe 5x5, welches gefüllt ist mit \"Eintrag\"\nprintln(arrayDim2[0][3]) //\"Eintrag\"\n````\n\n[Weiterführende Informationen](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/)"
    }
   ]
  },
  {
   "artifact_name": "m.95",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### Liste\nAufgrund einer größeren Flexibilität und besseren Implementierung in Kotlin sind Listen gegenüber Arrays zu bevorzugen. Ähnlich zu den zwei verschiedene Variablentypen (`val`/`var`), sind Listen ebenso in Veränderbare (`MutableList`) und Unveränderbare (`List`) aufgeteilt. Währund die `MutableList` an eine klassische `List` in Java erinnert, können die Einträge einer Kotlin-`List` im Nachhinein nicht verändert werden. Außerdem können in einer Liste nur Elemente eines Typs gespeichert werden.\n#### Inititalisierung\nEine Liste kann, ähnlich zu einem Array, mit der Methode `listOf()` beziehungsweise `mutableListOf()` erzeugt werden. Als Parameter können die Listeneinträge übergeben werden. Falls sie leer sind, muss der Datentyp der Elemente der Liste angegeben werden. Außerdem kann auch der bereits bei Arrays kennengelernte Konstruktor angewendet werden. Dabei muss die (festgesetzte) Länge angegeben werden. In den geschweiften Klammern kann mit dem Schlüsselwort `it` der Index des zu füllenden Elements abgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.96",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "#### Veränderbar & Unveränderbar\nBei der Betrachtung des obigen Beispiels könnten einige Fragen aufgekommen sein, die mit der Veränderbarkeit der Listen und deren Variablen zutun hat. Deswegen folgt hier noch eine ausführlichere Erklärung.<br />\nBeginnen wir mit einer Betrachtung der Listentypen: \n- Eine Liste der Klasse `List` können Sie sich vorstellen wie eine Liste mit einer, bei Inititalisierung festgelegter, Länge. In der Liste sind Variablen des Typs `val` gespeichert. Diese können also nicht verändert werden. \n- Eine Liste der Klasse `MutableList` hat keine festgelegte Länge und kann folglich beliebig verlängert oder verkürzt werden. Die Elemente sind Variablen des Typs `var` und können verändert werden.\n\nGespeichert werden die Listen in eigenen Variablen, die wiederum verschieden veränderbar sein können:\n- Wird eine beliebige in einer Variable des Typs `val` gespeichert, kann der Variable keine neue Liste zugewiesen werden. Dies hat jedoch **keinen** Einfluss auf den Typ der Liste.\n- Wird eine beliebige in einer Variable des Typs `var` gespeichert, kann die gespeicherte Liste durch eine Andere ersetzt werden. Die Variable ist veränderbar. Falls jedoch eine unveränderbare Liste in einer veränderbaren Variable gespeichert wird, kann die Liste dennoch nicht bearbeitet werden.\n\nZusammenfassung:\n\n|     | List                                                      | MutableList                                                     |\n|-----|-----------------------------------------------------------|-----------------------------------------------------------------|\n| val | Variable und Liste können nicht verändert werden          | Variable kann nicht verändert werden, die Liste hingegen schon. |\n| val | Variable kann verändert werden, die Liste hingegen nicht. | Variable und Liste können verändert werden                      |"
    }
   ]
  },
  {
   "artifact_name": "m.97",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "#### Ausgewählte Operationen\nIm folgenden werden einige ausgewählte Operationen vorgestellt, mit denen Listen bearbeitet werden können.\n##### Zugriff auf ein Element\nDer Zugriff auf ein Element kann entweder wie bei einem Array mit dem Index erfolgen oder mit der Methode `get()` und dem Index als Parameter."
    }
   ]
  },
  {
   "artifact_name": "m.98",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "##### Länge\nDie Länge einer Liste kann mit der Variable `size` abgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.99",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "##### Konvertierung\nListen können untereinander mit `toList()` konvertiert werden. Außerdem können auch andere Datenstrukturen mit dieser Methode zu einer Liste konvertiert werden."
    }
   ]
  },
  {
   "artifact_name": "m.100",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "##### Füllen und Leeren\nEine veränderbare Liste kann mit `fill()` mit dem übergebenden Element gefüllt werden. `clear()` hingegen löscht alle Elemente aus der Liste."
    }
   ]
  },
  {
   "artifact_name": "m.101",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "##### Hinzufügen und Löschen\nEiner veränderbaren Liste können Elemente mit `add()` hinzugefügt werden. Wird nur das Element übergeben, wird dieses am Ende angehängt. Wenn zusätzlich noch ein Index angegeben wird, wird das Element an diesem Index eingefügt.<br />\nMit `remove()` beziehungsweise `removeAt()` kann ein bestimmtes Element oder ein Element an einem bestimmten Index entfernt werden.<br />\nFür eine bessere Übersitlichkeit kann das Hinzufügen beziehungsweise Löschen mit Operatoren abgekürzt werden. Diese ersetzen aber lediglich die einfachen Methoden `add` und `remove`."
    }
   ]
  },
  {
   "artifact_name": "m.102",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "##### Teilliste\nEine Teilliste kann mit der Methode `subList()` erstellt werden. Dabei müssen als Parameter der Startindex (inklusive) und Endindex (exklusive) angegeben werden.<br />\nEine neue Liste mit den ersten n Elementen einer Liste kann mit `take(n)` erzeugt werden. Sollen hingegen die letzten n Elemente zurückgegeben werden findet `takeLast(n)` Anwendung.<br />\nEine Liste ohne die ersten n Elemente kann mit der Methode `drop(n)` erlangt werden."
    }
   ]
  },
  {
   "artifact_name": "m.103",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "##### Suchen\nMit dem Schlüsselwort `in` kann ein Element in einer Liste gesucht werden. Zurückgegeben wird `true`, falls es gefunden wurde, ansonsten `false`.<br />\nWenn statt der Information, ob das Element vorhanden ist, zusätzlich noch der Index gesucht ist, kann die Methode `indexOf()` benutzt werden. Falls das übergebene Element nicht in der Liste vorhanden ist, wird `-1` zurückgegeben."
    }
   ]
  },
  {
   "artifact_name": "m.104",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "##### Anordnen und Zufall\nEin zufälliges Element einer Liste kann mit `random()` erhalten werden.<br />\nSoll eine veränderbaren Liste durchmischt werden, findet `shuffle()` Anwendung.<br />\nDas sortieren einer veränderbaren Liste funktioniert unter Anderem mit `sort()`. [Genauere Informationen](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort.html) zum Sortieren"
    }
   ]
  },
  {
   "artifact_name": "m.105",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### Set\nSets sind primitivere Listen. Ihre Elemente sind ungeordnet und besitzen keine Duplikate. Nur ein `MutableSet` kann nur vergrößert oder verkleinert werden. Erzeugen kann man sie mit `setOf()` beziehungsweise `mutableSetOf()`."
    }
   ]
  },
  {
   "artifact_name": "m.106",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Ein Vorteil an Sets ist, dass einfache Operationen mit Mengen ermöglicht werden. Mit `union` oder `+` können zwei Sets vereinigt werden, `intersect` gibt eine Schnittmenge zurück und `subtract` entfernt alle Elemente der ersten Menge aus der Zweiten."
    }
   ]
  },
  {
   "artifact_name": "m.107",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "### Map\nMaps sind eine Liste von Paaren von Elementen. Ein Paar besteht aus einem Schlüssel (key) und einem Wert (value). Der Schlüssel ist dabei der \"Index\" eines Werts. Eine unveränderbare Map gehört der Klasse `Map` an und kann mit `mapOf()` erzeugt werden, während eine Veränderbare der Klasse `MutableMap` zugeordnet wird und mit Hilfe von `mutableMapOf()` initialisiert werden. Ein Eintrag in der Map wird mit dem Schlüssel und dem Wert verbunden mit `to` gekennzeichnet. Zu einer veränderbaren Map kann mit der Methode `put()` ein Eintrag hinzugefügt werden. Dazu müssen der Schlüssel und der Wert mit Komma getrennt übergeben werden. Ein Eintrag kann mit `remove()` und der übergabe des Schlüssels entfernt werden."
    }
   ]
  },
  {
   "artifact_name": "m.108",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "Eine Map kann mit einer `for`-Schleife einfach durchlaufen werden:"
    }
   ]
  },
  {
   "artifact_name": "m.109",
   "versions": [
    {
     "start_checkpoint": 1616857853381,
     "parent": "n.0.61",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/>\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br "
    }
   ]
  },
  {
   "artifact_name": "m.110",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "# Abschnitt 1 - Grundlagen\n## Einführung"
    }
   ]
  },
  {
   "artifact_name": "m.111",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.72",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dabei wird an der Konsole der String \"Hello World\" ausgegeben. Die Implementierung in Java und Kotlin im Vergleich:<br />\n```java\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java.\")\n    }\n}\n```\n```kotlin\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin.\")\n}\n```\n\nIm direkten Vergleich sind einige Unterschiede festzustellen:\n- Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden.\n- Methodensyntax: Methoden werden mit dem Schlüsselbegriff `fun` gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch `void`) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.\n- Hauptprogramm: Das Argument der `main`-Methode (in Java `String[] args`) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.\n- `Println`: Die Bibliotheksmethode `println` befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.<br />\n\nDie Methode kann, wie in Java, mit ihrem Namen aufgerufen werden:"
    }
   ]
  },
  {
   "artifact_name": "m.112",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "### Erweiterung\nDas \"Hello World\"-Programm wird nun so erweitert, dass dem \"Hello World\"-String eine Variable angehängt wird."
    },
    {
     "start_checkpoint": 1617025559423,
     "parent": "n.0.102",
     "markdown": "### Erweiterung\nDas \"Hello World\"-Programm soll nun so erweitert werden, dass der Ausgabe eine Variable angehängt wird."
    }
   ]
  },
  {
   "artifact_name": "m.113",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.72",
     "markdown": "Der Methodenkopf und -aufruf verändern sich nicht. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt ein Wert zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;`. Während in Java nach jeder Anweisung ein Semikolon folgen muss, ist das in Kotlin nur noch der Fall, wenn mehrere Anweisungen in eine Zeile geschrieben werden. Ansonsten ist kein Semikolon notwendig.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n    \n| Java                                         | Kotlin                                       |\n|----------------------------------------------|----------------------------------------------|\n| <pre lang=\"java\"> \"Hello World\" + name </pre> | <pre lang=\"kotlin\"> \"Hello World \\$name\" </pre> |\n| <pre lang=\"java\"> String.format(\"Hello World %s\", name)</pre> |  |\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert bzw. angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    }
   ]
  },
  {
   "artifact_name": "m.114",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "## Lektion 2 - Variablen\nDiese Lektion behandelt Variablen, Datentypen und Vergleiche.\n### Variablen\nVariablen lassen sich in Kotlin in 2 Arten unterglieder: **(Illustration)**\n- `val` (value): Beschreibt eine Variable mit **lesenden** Zugriff. Bei Deklarierung muss ihr direkt ein Wert zugewiesen werden, welcher nicht mehr verädnert werdne kann. Eine `val`-Variable in Kotlin ist mit einer `final`-Variable in Java zu vergleichen.\n- `var` (variable): Beschreibt eine Variable mit **lesenden** und **schreibenden** Zugriff. Ihr Wert kann beliebig oft verändert werden und muss nicht direkt bei Deklarierung gesetzt werden. Dies entspricht einer normalen Variable in Java.\n\nBeispiel:"
    }
   ]
  },
  {
   "artifact_name": "m.115",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.72",
     "markdown": "Die Untergliederung der Variablen in `val` und `var` hat den Hintergrund, dass der funktionale Programmierstil, welcher einfacher zu verstehen ist, gefördert wird. Es herrscht der Grundsatz: Überall wo es geht `val` statt `var`. **(andere Formulierung)**<br />\nDer Syntax (Wissensstand jetzt) der Deklarierung und Initialsisierung ist folgendermaßen: <br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> (\"var\"|\"val\") name \":\" Datentyp \"=\" Wert.<br />\nEine weitere Besonderheit bei Variablen ist der Umgang mit `null`. Variablen, die mit dem eben kennengelernten Syntax initialisiert und deklariert werden, können nicht den Wert `null` annehmen:\n```kotlin \nvar test_null : Int = null //-> Null can not be a value of a non-null type Int\n```\nGenauer werden wir uns den Umgang mit `null` in Abschnitt 2 beschäftigen.<br />\n<br />\nKonstanten werden in Kotlin sind Variablen der Kategorie `val`, denen das Schlüsselwort `const` vorangestellt wird. Sie dürfen nur auf der Top-Level-Ebene oder in Objekten (näheres dazu in Abschnitt 3) deklariert werden:\n```kotlin \nconst val constant : Int = 24\n```\nAuf den ersten Blick scheinen schreibgeschützte Variablen und Konstanten den gleichen Nutzen haben: Einen unveränderlichen Wert speichern und zur Verfügung stellen. Im Grunde ist das richtig, jedoch gibt es einen großen Unterschied. Während `val`-Variablen als so genannte runtime constants angesehen werden, sind Konstenten compile-time constants. Praktisch bedeutet dies, dass eine Konstante immer den zugewiesenen Wert besitzt, während eine schreibgeschützte Variable bei jedem Ausführen einen unterschiedlichen, aber unveränderlichen Wert annehmen kann."
    },
    {
     "start_checkpoint": 1617008269323,
     "parent": "n.0.73",
     "markdown": "Die Untergliederung der Variablen in `val` und `var` hat den Hintergrund, dass der funktionale Programmierstil, welcher einfacher zu verstehen ist, gefördert wird. Es herrscht der Grundsatz: Überall wo es geht `val` statt `var`. **(andere Formulierung)**<br />\nDer Syntax (Wissensstand jetzt) der Deklarierung und Initialsisierung ist folgendermaßen: <br />\nVariable :\n    \"var\" name \":\" Datentyp<br />\nVariable -> (\"var\"|\"val\") name \":\" Datentyp \"=\" Wert.<br />\nEine weitere Besonderheit bei Variablen ist der Umgang mit `null`. Variablen, die mit dem eben kennengelernten Syntax initialisiert und deklariert werden, können nicht den Wert `null` annehmen:\n```kotlin \nvar test_null : Int = null //-> Null can not be a value of a non-null type Int\n```\nGenauer werden wir uns den Umgang mit `null` in Abschnitt 2 beschäftigen.<br />\n<br />\nKonstanten werden in Kotlin sind Variablen der Kategorie `val`, denen das Schlüsselwort `const` vorangestellt wird. Sie dürfen nur auf der Top-Level-Ebene oder in Objekten (näheres dazu in Abschnitt 3) deklariert werden:\n```kotlin \nconst val constant : Int = 24\n```\nAuf den ersten Blick scheinen schreibgeschützte Variablen und Konstanten den gleichen Nutzen haben: Einen unveränderlichen Wert speichern und zur Verfügung stellen. Im Grunde ist das richtig, jedoch gibt es einen großen Unterschied. Während `val`-Variablen als so genannte runtime constants angesehen werden, sind Konstenten compile-time constants. Praktisch bedeutet dies, dass eine Konstante immer den zugewiesenen Wert besitzt, während eine schreibgeschützte Variable bei jedem Ausführen einen unterschiedlichen, aber unveränderlichen Wert annehmen kann."
    },
    {
     "start_checkpoint": 1617008281926,
     "parent": "n.0.74",
     "markdown": "Die Untergliederung der Variablen in `val` und `var` hat den Hintergrund, dass der funktionale Programmierstil, welcher einfacher zu verstehen ist, gefördert wird. Es herrscht der Grundsatz: Überall wo es geht `val` statt `var`. **(andere Formulierung)**<br />\nDer Syntax (Wissensstand jetzt) der Deklarierung und Initialsisierung ist folgendermaßen: <br />\nVariable :<br />\n    \"var\" name \":\" Datentyp<br />\nVariable -> (\"var\"|\"val\") name \":\" Datentyp \"=\" Wert.<br />\nEine weitere Besonderheit bei Variablen ist der Umgang mit `null`. Variablen, die mit dem eben kennengelernten Syntax initialisiert und deklariert werden, können nicht den Wert `null` annehmen:\n```kotlin \nvar test_null : Int = null //-> Null can not be a value of a non-null type Int\n```\nGenauer werden wir uns den Umgang mit `null` in Abschnitt 2 beschäftigen.<br />\n<br />\nKonstanten werden in Kotlin sind Variablen der Kategorie `val`, denen das Schlüsselwort `const` vorangestellt wird. Sie dürfen nur auf der Top-Level-Ebene oder in Objekten (näheres dazu in Abschnitt 3) deklariert werden:\n```kotlin \nconst val constant : Int = 24\n```\nAuf den ersten Blick scheinen schreibgeschützte Variablen und Konstanten den gleichen Nutzen haben: Einen unveränderlichen Wert speichern und zur Verfügung stellen. Im Grunde ist das richtig, jedoch gibt es einen großen Unterschied. Während `val`-Variablen als so genannte runtime constants angesehen werden, sind Konstenten compile-time constants. Praktisch bedeutet dies, dass eine Konstante immer den zugewiesenen Wert besitzt, während eine schreibgeschützte Variable bei jedem Ausführen einen unterschiedlichen, aber unveränderlichen Wert annehmen kann."
    },
    {
     "start_checkpoint": 1617008296329,
     "parent": "n.0.76",
     "markdown": "Die Untergliederung der Variablen in `val` und `var` hat den Hintergrund, dass der funktionale Programmierstil, welcher einfacher zu verstehen ist, gefördert wird. Es herrscht der Grundsatz: Überall wo es geht `val` statt `var`. **(andere Formulierung)**<br />\nDer Syntax (Wissensstand jetzt) der Deklarierung und Initialsisierung ist folgendermaßen: <br />\nVariable :<br />\n     \"var\" name \":\" Datentyp<br />\nVariable -> (\"var\"|\"val\") name \":\" Datentyp \"=\" Wert.<br />\nEine weitere Besonderheit bei Variablen ist der Umgang mit `null`. Variablen, die mit dem eben kennengelernten Syntax initialisiert und deklariert werden, können nicht den Wert `null` annehmen:\n```kotlin \nvar test_null : Int = null //-> Null can not be a value of a non-null type Int\n```\nGenauer werden wir uns den Umgang mit `null` in Abschnitt 2 beschäftigen.<br />\n<br />\nKonstanten werden in Kotlin sind Variablen der Kategorie `val`, denen das Schlüsselwort `const` vorangestellt wird. Sie dürfen nur auf der Top-Level-Ebene oder in Objekten (näheres dazu in Abschnitt 3) deklariert werden:\n```kotlin \nconst val constant : Int = 24\n```\nAuf den ersten Blick scheinen schreibgeschützte Variablen und Konstanten den gleichen Nutzen haben: Einen unveränderlichen Wert speichern und zur Verfügung stellen. Im Grunde ist das richtig, jedoch gibt es einen großen Unterschied. Während `val`-Variablen als so genannte runtime constants angesehen werden, sind Konstenten compile-time constants. Praktisch bedeutet dies, dass eine Konstante immer den zugewiesenen Wert besitzt, während eine schreibgeschützte Variable bei jedem Ausführen einen unterschiedlichen, aber unveränderlichen Wert annehmen kann."
    }
   ]
  },
  {
   "artifact_name": "m.116",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "### Datentypen\nKotlin ist - wie Java - eine statisch typisierte Programmiersprache. Das bedeutet, dass jeder Variable, jeder Ausdruck einen statischen Typ besitzt, der bei der Deklarierung festgelegt werden und bei Kompilierung erkennbar sein muss. Dies kann entweder explizit durch eine Datentypzuweisung (wie wir es bis jetzt gemacht haben) oder implizit durch eine direkte aussagekräftige Initialisierung erfolgen. In diesem Fall wird vom Compiler ein zum Wert passender Datentyp der Variable zugewiesen."
    }
   ]
  },
  {
   "artifact_name": "m.117",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen erweitert werden:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick der wichtigsten Datentypen:\n\n| Kotlin  | Werte                                                    | Java    |\n|---------|----------------------------------------------------------|---------|\n| Byte    | -128 bis 127                                             | byte    |\n| Short   | -32768 bis 32767                                         | short   |\n| Int     | -2.147.483.648 bis 2.147.483.647                         | int     |\n| Long    | -9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808 | long    |\n| Float   | 6 bis 7 Dezimalstellen                                   | float   |\n| Double  | 15 bis 16 Dezimalstellen                                 | double  |\n| Boolean | `true` oder `false`                                      | boolean |\n| Char    | 16-Bit-Unicode-Zeichen                                   | char    |\n| String  | Folge von Zeichen                                        | String  |\n\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.<br />\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 20%; text-align: center\">\n\n### Vergleiche\nVergleiche in Kotlin sind einfacher und intuitiver als in Java. Der Grund dafür ist, dass nicht mehr zwischen elementaren und nicht-elementaren Datentypen unterschieden wird. Alle von Kotlin bereitgestellte Datentypen implementieren das `Comparable`-Interface und können somit mit `compareTo` verglichen werden. Jedoch muss man nicht die Methode zum Vergleichen aufrufen, sondern kann dies mit den bekannten Vergleichszeichen bewerkstelligen. Der Vorteil ist in Kotlin mit `==` immer der Inhalt der Variable, des Parameters verglichen wird und nicht wie in Java die Referenz. Außerdem sind dadurch auch einfach kleiner und größer Vergleiche möglich. Für einen Vergleich der Refernzen wurde in Kotlin das `===` eingeführt."
    }
   ]
  },
  {
   "artifact_name": "m.118",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin und wählen Sie passende Variablen.\n```java\nfinal static float PI = 3.14159f;\nint a = 50;\nint b = 20;\nint res;\nfinal boolean bool = false;\na = a + 30;\nres = a - b;\nString output = \"a - b ist: \" + res + \".\";\nSystem.out.println(output);\n```"
    }
   ]
  },
  {
   "artifact_name": "m.119",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden die Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht viel von einer Mehtode in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 700px; text-align: center\">\n\nBeginnend mit dem Schlüsselwort `fun`, das eine Methode angkündigt, folgt der Name. Danach werden in runden Klammern, falls benötigt, die Parameter angegeben. Bevor der Methodenrumpf durch `{` beginnt, ist noch ein optionaler Rückgabetyp zu finden. Es ergibt sich folgender Syntax: <br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nFalls ein Rückgabetyp angegeben ist, muss etwas zurückgegeben werden. Dies wird mit `return` eingeleitet. Falls der Rückgabetyp fehlt, gibt die Methode nichts zurück, kann aber mit `return` beendet werden. Das Hauptprogramm besitzt den Methodenkopf:\n```kotlin\nfun main(){ ... }\n//oder\nfun main(args: Array) { ... }\n```"
    }
   ]
  },
  {
   "artifact_name": "m.120",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "### Parameter\nEs können einer Methode beliebig viele Parameter übergeben werden. Dabei wird zuerst der Name und danach der Datentyp angegeben. Sie sind mit einem Doppelpunkt getrennt. Außerdem kann jedem Parameter ein default-Wert zugewiesen werden. Wird der Parameter bei Methodenaufruf weggelassen wird er auf diesen gesetzt. Falls kein default-Wert festgelegt wurde, wird der Parameter mit dem default-Wert des Datentyps gefüllt. Es können auch bestimmte Parameter mit deren Namen im Methodenaufrug angesprochen werden. Dann ist die Reihenfolge der mit Namen genannten Übergabeparameer unwichtig. Es sollte jedoch nur eine Form der Übergabe angewendet werden, da dies sonst zu einer falschen Positionierung führen kann.<br />\nSyntax der Parameter:<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />"
    }
   ]
  },
  {
   "artifact_name": "m.121",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Kollektion (zum Beispiel ein Array) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:80%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl 42 ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falschhe Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 20%; float:left\">\n\n\n### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen, und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ (falls, Kontrollstrukturen vorkommen) implizit ermittelt."
    }
   ]
  },
  {
   "artifact_name": "m.122",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "#### Überladen\nDas Überladen von Methoden ist auch in Kotlin möglich. Einzige Einschränkung ist, dass der Compiler - genauso wie in Java - das Parameterprofil der unterschiedlichen Methoden voeinander unterscheiden kann."
    }
   ]
  },
  {
   "artifact_name": "m.123",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "## Lektion 4 - Kontrollstrukturen\nIn dieser Lektion werden die Kontrollstrukturen in Kotlin behandelt und Ranges eingeführt."
    }
   ]
  },
  {
   "artifact_name": "m.124",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "### `if`-Verzweigung\nDie simpelste Art der Verzweigung ist `if`. In Verbindung mit `else` und `else if` können so mehrere Fälle definiert, geprüft und nach deren Ergebnis gehandelt werden. Falls nur eine Anweisung einem Fall zugeordnet wird, können die geschweiften Klammern weggelassen werden.\n```kotlin\nfun foo(a: Int): String {\n    if (a < 10) \n        return \"kleiner 10\"\n    else if (a == 10) \n        return \"gleich 10\"\n    else {\n        val b = 20\n        return \"groeßer 10\"\n    }\n}\n```\nEine Neuerung ist, dass falls eine `if`-Verzweigung einen Wert zurückgibt dieser auch direkt einer Variable zugewiesen werden kann oder bei einer Methode zurückgegeben werden kann."
    }
   ]
  },
  {
   "artifact_name": "m.125",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.67",
     "markdown": "### `when`-Verzweigung\nEine weitere Art der Verzweigung ist `when`. Diese ähnelt von der Funktionalität an Javas `switch`. Das Schlüsselwort mit dem ein `when`-Block eingeleitet wird, ist `when`. In runden Klammern muss daraufhin die zu untersuchende Variable folgen. In dem Block steht links der Vergleichswert (die Vergleichswerte mit Komma getrennt) und rechts die Anweisung. Diese kann als Einzeiler ohne geschweifte Klammern geschrieben werden oder als Block mit. Getrennt werden die Seite mit mit `->`. Anders als in Java muss nicht nach jedem Block ein `break` stehen. Standardmäßig wird nach dem Ausführen der rechten Seite der `when`-Block verlassen. Ein \"Durchrustschen\" geschieht nicht.\n"
    },
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.76",
     "markdown": "### `when`-Verzweigung\nEine weitere Art der Verzweigung ist `when`. Diese ähnelt von der Funktionalität an Javas `switch`. Das Schlüsselwort mit dem ein `when`-Block eingeleitet wird, ist `when`. In runden Klammern muss daraufhin die zu untersuchende Variable folgen. In dem Block steht links der Vergleichswert (die Vergleichswerte mit Komma getrennt) und rechts die Anweisung. Diese kann als Einzeiler ohne geschweifte Klammern geschrieben werden oder als Block mit. Getrennt werden die Seite mit mit `->`. Anders als in Java muss nicht nach jedem Block ein `break` stehen. Standardmäßig wird nach dem Ausführen der rechten Seite der `when`-Block verlassen. Ein \"Durchrustschen\" geschieht nicht. Der default-Fall wird mit `else` auf der linken Seite gekennzeichnet."
    }
   ]
  },
  {
   "artifact_name": "m.126",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "Es können aber auch weiterführende Vergleiche angestellt werden. Mit `is` kann überprüft werden, ob die zu untersuchende Variable einen bestimmten Datentyp besitzt. `in` hingegen sucht die Variable in einer Datenstruktur."
    }
   ]
  },
  {
   "artifact_name": "m.127",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.76",
     "markdown": "Außerdem kann `when` auch ein Ersatz für `if` sein. Dies bietet sich vor Allem an, wenn die `if`-Verzweigung mehr als 2 Fälle besitzt. Dabei wird die zu untersuchende Variable nicht zu Beginn, sondern auf die linken Seite mit einem boolschen Ausdruck geschrieben. Folgender Code mit einer `if`-Verzweigung soll nun mit einer `when`-Verzweigung ersetzt werden:\n```kotlin\nval a = 10\nif (a < 10) \n   println(\"gleich 10\")\nelse if (a < 10) \n   println(\"kleiner 10\")\nelse \n   println(\"groeßer 10\")\n```"
    }
   ]
  },
  {
   "artifact_name": "m.128",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "### `for`-Schleife\nAuch sind `for`-Schleifen in Kotlin zu finden. Jedoch weicht ihr Syntax stark von dem in Java ab. Der normale Aufbau einer `for`-Schleife mit 3 Teilen fällt weg und wird durch Breiche oder auch Ranges ersetzt.\n#### Bereiche\nBereiche sind eine Folge von Elementen, die einen definierten Start- und Endpunkt besitzen. Die beiden Werte werden durch `..` getrennt. Kotlin stellt Bereiche des Typs `Int`, `Long` und `Char` bereit. Der Endwert ist dabei immer der letzte Wert des Bereichs.\nDer Startwert kann mit `first` und der Endwert mit `last` adressiert werden. Ein Bereich des Datentyps `Range` ist aufsteigend mit einer Schrittweite von 1. Alle anderen Bereiche besitzen den Datentyp `Progression` und sind mächtiger. So kann ein Bereich entweder mit `reversed()` oder mit dem Schlüsselwort `downTo` statt `..` erzeugt werden. Soll die Obergrenze exklusiv sein, hilft zudem das Schlüsselwort `until` anstelle von `..`. Zur schöneren Darstellung oder zum Erzeugen einfacher Listen können Bereiche in Listen oder Sets umgewandelt werden mit `toList()` beziehungsweise `toSet()` (näheres zu Datenstrukturen in [Lektion 6](#Lektion-6---Datenstrukturen))."
    }
   ]
  },
  {
   "artifact_name": "m.129",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "#### Schleife\nDie aus Java bekannte 3 gliedrige `for`-Schleife wird in Kotlin durch eine Schleife über einen Bereich ersetzt. Das benötigt Schlüsselwort lautet `in`."
    }
   ]
  },
  {
   "artifact_name": "m.130",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "Anstelle über eine Range kann aber auch über eine Kollektion (zum Beispiel eine Liste) iteriert werden."
    }
   ]
  },
  {
   "artifact_name": "m.131",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "Dabei ist aber zu beachten, dass das Element nicht in der Schleife verändert werden kann. Dies geht nur mit einem Bereich und Zugriff auf den Index an der aktuellen Stelle."
    }
   ]
  },
  {
   "artifact_name": "m.132",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "Eine elegantere Lösung ist die Option über die Liste und den aktuellen Index zu iterieren. Dies ist mit Hilfe von `.withIndex()` möglich. Ein ähnlicher Fall ist die Itereriung über Maps. Dies wird in [Lektion 6](#Lektion-6---Datenstrukturen) behandelt."
    }
   ]
  },
  {
   "artifact_name": "m.133",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "#### `break`\nIn Kotlin kann mit Hilfe von `break` die aktuelle oder eine bestimmte Schleife abgebrochen werden. Der 2. Fall benötigt eine Bezeichnung der abzubrechenden Schleife. Dies kann mit `@` gefolgt von dem Namen vor der Schleife gemacht werden. Der Name der Schleife inklusive dem `@` wird in der Schleife dem `break` angehängt."
    }
   ]
  },
  {
   "artifact_name": "m.134",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "### `while`-Schleife\nDie `while`-Schleife ist identisch zu der in Java. Zusätzlich zu der normalen `while`-Schleife gibt es auch die `do-while`-Schleife."
    }
   ]
  },
  {
   "artifact_name": "m.135",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.70",
     "markdown": "### `repeat`-Schleife\nDie `repeat`-Schleife ist vor Allem an Anfänger:innen gerichtet. Es wird lediglich ein exklusiver Endwert angegeben, zu dem von 0 aus hochgezählt wird. In der Schleife kann auf den aktuelle Durchlauf mit `it` zugegriffen werden."
    },
    {
     "start_checkpoint": 1616861593906,
     "parent": "n.0.102",
     "markdown": "### `repeat`-Schleife\nDie `repeat`-Schleife ist vor Allem an Anfänger:innen gerichtet. Es wird lediglich ein exklusiver Endwert angegeben, zu dem von 0 aus hochgezählt wird. In der Schleife kann auf die aktuelle Durchlaufzahl mit `it` zugegriffen werden."
    }
   ]
  },
  {
   "artifact_name": "m.136",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "## Lektion 5 - Weitere Methodentypen\nIn dieser Lektion werden weitere Methodentypen behandelt.\n### Erweiterungsmethoden\nErweiterungsfunktionen können eine bestehende Klasse einfach durch eine Methode, die außerhalb der Klasse definiert wird, erweitern. Dies findet vor Allem Anwendung bei Klassen, der keine Objektmethode hinzugefügt werden kann. Beispielsweise die Klassen der Datentypen. Im folgenden Beispiel wird die Klasse `Int` mit einer Methode erweitert, die die Zehnerstelle zurückgibt:"
    }
   ]
  },
  {
   "artifact_name": "m.137",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "In dem Beispiel wird der Klasse `Int` eine Erweiterungsmethode `zehner` hinzugefügt. Dies wird dadruch gekennzeichnet, dass die zu erweiternde Klasse (hier: `Int`) mit `.` getrennt vor dem Namen der Methode (hier: `zehner`) steht. Da keine weiteren Parameter benötigt werden, bleiben diese leer. Auf das Objekt, auf den die Methode aufgerufen wird, kann mit `this` zugegriffen werden.<br />\nEs ist außerdem zu beachten, dass Erweiterungsmethoden **immer** von Objektmethoden überdeckt werden. "
    }
   ]
  },
  {
   "artifact_name": "m.138",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "#### Aufgabe\nErweitern Sie die Klasse `String` mit der Methode `addNewLine`, die am Ende des Strings einem Zeilenumbruch (`'\\n'`) hinzufügt. Vervollständigen Sie dazu das folgende Grundgerüst:"
    }
   ]
  },
  {
   "artifact_name": "m.139",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "### `infix`-Methoden\nBereits kennengelertne Beispiele von `infix`-Methoden sind bei Bereichen zu finden. Anstelle von konkreten Methodenaufrufen werden Schlüsselworte bereitgestellt, die auf eine bestimmte `infix`-Methode verweisen. Dadurch wird der Code näher an den Sprachgebrauch angegliedert, was die Verständlichkeit fördert. Diesen Methoden wird das Schlüsselwort `infix` vorangestellt. Vor den Methodenname getrennt mit einem `.` wird der Datentyp des ersten Objekts angegeben, ähnlich zu eienr Erweiterungsmethode. In den Parametern der des Zweiten zusammen mit dem Namen des Parameters. Auf den \"ersten\" Parameter kann wieder mit `this` zugegriffen werden.\n```kotlin\n5 until 10 //infix\n5.until(10) //umgewandelt\ninfix fun Int.until(to: Int): IntRange //Methodenkopf\n```\nEs können beliebige `infix`-Methoden implementiert werden, falls das Schlüsselwort noch nicht besetzt ist."
    }
   ]
  },
  {
   "artifact_name": "m.140",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "#### Aufgabe\nEine weit verbreitete Operation ist das Addieren der Inhalt 2er Listen. Schreiben Sie eine `infix`-Methode mit der 2 Listen vom Typ `MutableList<Int>` mit dem Schlüsselwort `addAllElements` elementweise addiert und als neue Liste vom Typ `List<Int>` zurückgegeben werden. Es kann angenommen werden, dass beide Listen gleich viele Elemente besitzen."
    }
   ]
  },
  {
   "artifact_name": "m.141",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "### `operator`-Methoden\nEinige Anweisungen shene auf den ersten Block nach `infix`-Methoden aus, sind aber keine. Dies ist immer der Fall, wenn mathematische Zeichen im Spiel sind. Für diese gibt es keine `infix`-Methoden, da sie auf sogenannte `operator`-Methoden abgebildet werden. Sie werden auf Methoden mit bestimmten Namen abgebildet. So wird aus `5 + 10` im Hintergund `5.plus(10)` aufgerufen. Weitere Beispiele:\n\n| Ausdruck | Aufruf         |\n|----------|----------------|\n| +a       | a.unaryPlus()  |\n| a++    | a.inc()       |\n| -a       | a.unaryMinus() |\n| a--    | a.dec()       |\n| !a       | a.not()        |\n| a + b    | a.plus(b)      |\n| a - b    | a.minus(b)     |\n| a * b    | a.times(b)     |\n| a / b    | a.div(b)       |\n| a..b     | a.rangeTo(b)   |\n\nDer Methodenkopf einer `operator`-Methode ähnelt dem einer `infix`-Methode. Statt dem Schlüsselword `infix` wird nun aber `operator` benutzt. Im Folgenden wird eine Datenklasse (näheres dazu in Abschnitt 3) `Punkt` definiert und den unären Operator `-` implementiert.\n"
    }
   ]
  },
  {
   "artifact_name": "m.142",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "#### Aufgabe\nErweitern Sie die Datenklasse `Punkt`, sodass zwei Punkte mit dem Operator `+`addiert werden können."
    }
   ]
  },
  {
   "artifact_name": "m.143",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "## Lektion 6 - Datenstrukturen\nIn dieser Lektion werden ausgewählte Datenstrukturen in Kotlin vorgestellt."
    },
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "## Lektion 6 - Datenstrukturen\nIn dieser Lektion werden ausgewählte Datenstrukturen vorgestellt."
    }
   ]
  },
  {
   "artifact_name": "m.144",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "### Array\nDie Datenstruktur des Arrays sollte bereits umfänglich bekannt sein. Die Funktionsweise unterscheidet sich nicht von Java, abgesehen von der Inititalisierung. Diese kann entweder mit dem Schlüselwort `arrayOf` erfolgen, falls alle Werte bereits vorliegen. Ansonsten kann ein leeres Array mit einer festgelegten Länge mit dem Ausdruck `Array(Länge) {Standardwert}` definiert werden.\n```kotlin\nval array1 = arrayOf(1,2,3,4) //[1, 2, 3, 4] -> Int-Array\nprintln(array1[2]) //3\nprintln(array1.size) //4\n\nval array2 = Array(6) {0.0} //[0.0, 0.0, 0.0, 0.0, 0.0, 0.0] -> Double-Array\nprintln(array2[2]) //0.0\nprintln(array2.size) //6\narray2[3] = 5.0 //[0.0, 0.0, 0.0, 5.0, 0.0, 0.0]\nprintln(array2[3]) //5.0\n```\n\nMehrdimensionale Arrays können, wie in Java, erstellt werden, indem in ein Element eines eindimensionales Arrays ein weiteres Array zu finden ist.\n```kotlin\nval arrayDim2 = Array(5) { Array(5) {\"Eintrag\"} } //Erzeugt ein 2 dimensionales String-Array der Größe 5x5, welches gefüllt ist mit \"Eintrag\"\nprintln(arrayDim2[0][3]) //\"Eintrag\"\n````\n\n[Weiterführende Informationen](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/)"
    },
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.84",
     "markdown": "### Array\nDie Aufbau eines Arrays sollte bereits umfänglich bekannt sein. Die Funktionsweise in Kotlin unterscheidet sich nicht stark von der Java, abgesehen von der Inititalisierung. Diese kann entweder mit dem Schlüsselwort `arrayOf` erfolgen, falls alle Werte bereits vorliegen, oder mit dem Ausdruck `Array(Länge) {Standardwert}`. Dann wird ein leeres Array mit einer festgelegten Länge erzeugt.\n```kotlin\nval array1 = arrayOf(1,2,3,4) //[1, 2, 3, 4] -> Int-Array\nprintln(array1[2]) //3\nprintln(array1.size) //4\n\nval array2 = Array(6) {0.0} //[0.0, 0.0, 0.0, 0.0, 0.0, 0.0] -> Double-Array\nprintln(array2[2]) //0.0\nprintln(array2.size) //6\narray2[3] = 5.0 //[0.0, 0.0, 0.0, 5.0, 0.0, 0.0]\nprintln(array2[3]) //5.0\n```\n\nMehrdimensionale Arrays können, wie in Java, erstellt werden, indem in ein Element eines eindimensionales Arrays ein weiteres Array zu finden ist.\n```kotlin\nval arrayDim2 = Array(5) { Array(5) {\"Eintrag\"} } //Erzeugt ein 2 dimensionales String-Array der Größe 5x5, welches gefüllt ist mit \"Eintrag\"\nprintln(arrayDim2[0][3]) //\"Eintrag\"\n````\n\n[Weiterführende Informationen](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-array/)"
    }
   ]
  },
  {
   "artifact_name": "m.145",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "### Liste\nAufgrund einer größeren Flexibilität und besseren Implementierung in Kotlin sind Listen gegenüber Arrays zu bevorzugen. Ähnlich zu den zwei verschiedene Variablentypen (`val`/`var`), sind Listen ebenso in Veränderbare (`MutableList`) und Unveränderbare (`List`) aufgeteilt. Währund die `MutableList` an eine klassische `List` in Java erinnert, können die Einträge einer Kotlin-`List` im Nachhinein nicht verändert werden. Außerdem können in einer Liste nur Elemente eines Typs gespeichert werden.\n#### Inititalisierung\nEine Liste kann, ähnlich zu einem Array, mit der Methode `listOf()` beziehungsweise `mutableListOf()` erzeugt werden. Als Parameter können die Listeneinträge übergeben werden. Falls sie leer sind, muss der Datentyp der Elemente der Liste angegeben werden. Außerdem kann auch der bereits bei Arrays kennengelernte Konstruktor angewendet werden. Dabei muss die (festgesetzte) Länge angegeben werden. In den geschweiften Klammern kann mit dem Schlüsselwort `it` der Index des zu füllenden Elements abgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.146",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "#### Veränderbar & Unveränderbar\nBei der Betrachtung des obigen Beispiels könnten einige Fragen aufgekommen sein, die mit der Veränderbarkeit der Listen und deren Variablen zutun hat. Deswegen folgt hier noch eine ausführlichere Erklärung.<br />\nBeginnen wir mit einer Betrachtung der Listentypen: \n- Eine Liste der Klasse `List` können Sie sich vorstellen wie eine Liste mit einer, bei Inititalisierung festgelegter, Länge. In der Liste sind Variablen des Typs `val` gespeichert. Diese können also nicht verändert werden. \n- Eine Liste der Klasse `MutableList` hat keine festgelegte Länge und kann folglich beliebig verlängert oder verkürzt werden. Die Elemente sind Variablen des Typs `var` und können verändert werden.\n\nGespeichert werden die Listen in eigenen Variablen, die wiederum verschieden veränderbar sein können:\n- Wird eine beliebige in einer Variable des Typs `val` gespeichert, kann der Variable keine neue Liste zugewiesen werden. Dies hat jedoch **keinen** Einfluss auf den Typ der Liste.\n- Wird eine beliebige in einer Variable des Typs `var` gespeichert, kann die gespeicherte Liste durch eine Andere ersetzt werden. Die Variable ist veränderbar. Falls jedoch eine unveränderbare Liste in einer veränderbaren Variable gespeichert wird, kann die Liste dennoch nicht bearbeitet werden.\n\nZusammenfassung:\n\n|     | List                                                      | MutableList                                                     |\n|-----|-----------------------------------------------------------|-----------------------------------------------------------------|\n| val | Variable und Liste können nicht verändert werden          | Variable kann nicht verändert werden, die Liste hingegen schon. |\n| val | Variable kann verändert werden, die Liste hingegen nicht. | Variable und Liste können verändert werden                      |"
    }
   ]
  },
  {
   "artifact_name": "m.147",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "#### Ausgewählte Operationen\nIm folgenden werden einige ausgewählte Operationen vorgestellt, mit denen Listen bearbeitet werden können.\n##### Zugriff auf ein Element\nDer Zugriff auf ein Element kann entweder wie bei einem Array mit dem Index erfolgen oder mit der Methode `get()` und dem Index als Parameter."
    }
   ]
  },
  {
   "artifact_name": "m.148",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "##### Länge\nDie Länge einer Liste kann mit der Variable `size` abgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.149",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "##### Konvertierung\nListen können untereinander mit `toList()` konvertiert werden. Außerdem können auch andere Datenstrukturen mit dieser Methode zu einer Liste konvertiert werden."
    }
   ]
  },
  {
   "artifact_name": "m.150",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "##### Füllen und Leeren\nEine veränderbare Liste kann mit `fill()` mit dem übergebenden Element gefüllt werden. `clear()` hingegen löscht alle Elemente aus der Liste."
    }
   ]
  },
  {
   "artifact_name": "m.151",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "##### Hinzufügen und Löschen\nEiner veränderbaren Liste können Elemente mit `add()` hinzugefügt werden. Wird nur das Element übergeben, wird dieses am Ende angehängt. Wenn zusätzlich noch ein Index angegeben wird, wird das Element an diesem Index eingefügt.<br />\nMit `remove()` beziehungsweise `removeAt()` kann ein bestimmtes Element oder ein Element an einem bestimmten Index entfernt werden.<br />\nFür eine bessere Übersitlichkeit kann das Hinzufügen beziehungsweise Löschen mit Operatoren abgekürzt werden. Diese ersetzen aber lediglich die einfachen Methoden `add` und `remove`."
    }
   ]
  },
  {
   "artifact_name": "m.152",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "##### Teilliste\nEine Teilliste kann mit der Methode `subList()` erstellt werden. Dabei müssen als Parameter der Startindex (inklusive) und Endindex (exklusive) angegeben werden.<br />\nEine neue Liste mit den ersten n Elementen einer Liste kann mit `take(n)` erzeugt werden. Sollen hingegen die letzten n Elemente zurückgegeben werden findet `takeLast(n)` Anwendung.<br />\nEine Liste ohne die ersten n Elemente kann mit der Methode `drop(n)` erlangt werden."
    }
   ]
  },
  {
   "artifact_name": "m.153",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "##### Suchen\nMit dem Schlüsselwort `in` kann ein Element in einer Liste gesucht werden. Zurückgegeben wird `true`, falls es gefunden wurde, ansonsten `false`.<br />\nWenn statt der Information, ob das Element vorhanden ist, zusätzlich noch der Index gesucht ist, kann die Methode `indexOf()` benutzt werden. Falls das übergebene Element nicht in der Liste vorhanden ist, wird `-1` zurückgegeben."
    }
   ]
  },
  {
   "artifact_name": "m.154",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "##### Anordnen und Zufall\nEin zufälliges Element einer Liste kann mit `random()` erhalten werden.<br />\nSoll eine veränderbaren Liste durchmischt werden, findet `shuffle()` Anwendung.<br />\nDas sortieren einer veränderbaren Liste funktioniert unter Anderem mit `sort()`. [Genauere Informationen](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort.html) zum Sortieren"
    }
   ]
  },
  {
   "artifact_name": "m.155",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "### Set\nSets sind primitivere Listen. Ihre Elemente sind ungeordnet und besitzen keine Duplikate. Nur ein `MutableSet` kann nur vergrößert oder verkleinert werden. Erzeugen kann man sie mit `setOf()` beziehungsweise `mutableSetOf()`."
    }
   ]
  },
  {
   "artifact_name": "m.156",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "Ein Vorteil an Sets ist, dass einfache Operationen mit Mengen ermöglicht werden. Mit `union` oder `+` können zwei Sets vereinigt werden, `intersect` gibt eine Schnittmenge zurück und `subtract` entfernt alle Elemente der ersten Menge aus der Zweiten."
    }
   ]
  },
  {
   "artifact_name": "m.157",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.84",
     "markdown": "### Map\nMaps sind eine Liste von Paaren von Elementen. Ein Paar besteht aus einem Schlüssel (key) und einem Wert (value). Der Schlüssel ist dabei der \"Index\" eines Werts. Eine unveränderbare Map gehört der Klasse `Map` an und kann mit `mapOf()` erzeugt werden, während eine Veränderbare der Klasse `MutableMap` zugeordnet wird und mit Hilfe von `mutableMapOf()` initialisiert werden. Ein Eintrag in der Map wird mit dem Schlüssel und dem Wert verbunden mit `to` gekennzeichnet. Zu einer veränderbaren Map kann mit der Methode `put()` ein Eintrag hinzugefügt werden. Dazu müssen der Schlüssel und der Wert mit Komma getrennt übergeben werden. Ein Eintrag kann mit `remove()` und der übergabe des Schlüssels entfernt werden."
    }
   ]
  },
  {
   "artifact_name": "m.158",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.102",
     "markdown": "Eine Map kann mit einer `for`-Schleife einfach durchlaufen werden:"
    }
   ]
  },
  {
   "artifact_name": "m.159",
   "versions": [
    {
     "start_checkpoint": 1616858354622,
     "parent": "n.0.66",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort"
    }
   ]
  },
  {
   "artifact_name": "m.160",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "n.0.67",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben."
    }
   ]
  },
  {
   "artifact_name": "m.161",
   "versions": [
    {
     "start_checkpoint": 1616859318783,
     "parent": "n.0.70",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben. Wenn ein Anweisungsblock ausgeführt wurde, wird der `when`-Block verlassen und nicht weiter ausgeführt."
    },
    {
     "start_checkpoint": 1616861593906,
     "parent": "n.0.76",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\nVariable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben. Wenn ein Anweisungsblock ausgeführt wurde, wird der `when`-Block verlassen und nicht weiter ausgeführt.<br />\nDie `for`-Schleife iteriert über Bereiche. Diese werden durch einen Start- und Endpunkt definiert getrennt von `..`. Die von Kotlin bereitgestellten Bereiche sind von den Typen `Int`, `Long` und `Char`. Soll ein Bereich absteigend sein, muss statt `..` `downTo` verwendet werden. Bei einem Bereich mit dem Schlüsselwort `until` ist der Endwert explizit. Nach dem Endwert kann noch ein `step` mit anschließender Schrittweite angegeben werden.<br />\nDie normale Iteration über einen Bereich wird mit dem Schlüsselwort `in` herbeigeführt. Ebenso kann aber mit diesem auch über eine Datenstruktur (zum Beispiel eine Liste) iteriert werden. In diesem Fall wird in der Laufvariable das Element der Liste gespeichert. Dieses kann nicht verändert werden. Hängt man der Liste `withIndex()` an, so wird ein Paar aus Index und Element bei jedem Durchlauf belegt.<br />\nSoll eine bestimmte Schleife beendet werden, kann dies mit dem Schlüsselwort `break` passieren. Diesem wird getrennt mit einem `@` der Name der Schleife angegeben. Zuvor muss dieser Name dieser aber zugewiesen werden. Dies erfolgt mit name`@` vor dem Schleifenkopf.<br />\nEine weitere Schleife ist die `while`-Schleife. Diese ist identisch zu der Umsetzung in Java. Außerdem wird ebenfalls die `do-while`-Schleife unterstützt.<br />\nFür einfache Zwecke ist die `repeat`-Schleife vorteilhaft. Dieser wird als Parameter ein positiver `Int`-Wert übergeben, bis zu dem von 0 aus iteriert wird. In der Schleife kann auf die aktuelle Durchlaufzahl mit `it` zugegriffen werden.<br /><br />"
    }
   ]
  },
  {
   "artifact_name": "m.162",
   "versions": [
    {
     "start_checkpoint": 1617025435363,
     "parent": "n.0.102",
     "markdown": "<div class=\"alert alert-block alert-info\">\n<b>Tip:</b> Use blue boxes (alert-info) for tips and notes. \nIf it’s a note, you don’t have to include the word “Note”.\n</div>\n<div class=\"alert alert-block alert-warning\">\n<b>Example:</b> Use yellow boxes for examples that are not \ninside code cells, or use for mathematical formulas if needed.\n</div>\n<div class=\"alert alert-block alert-success\">\n<b>Up to you:</b> Use green boxes sparingly, and only for some specific \npurpose that the other boxes can't cover. For example, if you have a lot \nof related content to link to, maybe you decide to use green boxes for \nrelated links from each section of a notebook.\n</div>\n<div class=\"alert alert-block alert-danger\">\n<b>Just don't:</b> In general, avoid the red boxes. These should only be\nused for actions that might cause data loss or another major issue.\n</div>"
    }
   ]
  },
  {
   "artifact_name": "m.163",
   "versions": [
    {
     "start_checkpoint": 1617025435363,
     "parent": "n.0.76",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dieses gibt in der Konsole den String \"Hello World\" aus.<br />\n<div style=\"float: left; width: 50%\">\n    <pre lang=\"java\">\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java.\")\n    }\n}\n</pre>\n</div>\n<div style=\"float: left; width: 50%\">\n<pre lang=\"kotlin\">\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin.\")\n}\n</pre>\n</div>\n<div style=\"clear:both\">\n    \nIm direkten Vergleich sind einige Unterschiede festzustellen:\n<ul>    \n<li> Klasse: Es können Methoden auf der höchste Ebene deklariert und aufgerufen werden. </li>\n    <li> Methodensyntax: Methoden werden mit dem Schlüsselbegriff <code>fun</code> gekenntzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch <code>void</code>) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.</li>\n<li> Hauptprogramm: Das Argument der <code>main</code>-Methode (in Java <code>String[] args</code>) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.</li>\n<li> <code>Println</code>: Die Bibliotheksmethode <code>println()</code> befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.</li>\n</ul>    \nDie Methode kann, wie in Java, mit ihrem Namen aufgerufen werden:"
    },
    {
     "start_checkpoint": 1617025559423,
     "parent": "n.0.102",
     "markdown": "## Lektion 1 - Hello World\n### Grundgerüst\nDer Start des Erlernens einer neuen Programmiersprache ist traditionell ein \"Hello World\"-Programm. Dieses gibt in der Konsole den String \"Hello World\" aus.<br />\n<div style=\"float: left; width: 50%\">\n    <pre lang=\"java\">\n//Java\npublic class Main{\n    public static void main(String[] args){\n        System.out.println(\"Hello World Java.\")\n    }\n}\n</pre>\n</div>\n<div style=\"float: left; width: 50%\">\n<pre lang=\"kotlin\">\n//Kotlin\nfun main(){\n    println(\"Hello World Kotlin.\")\n}\n</pre>\n</div>\n<div style=\"clear:both\">\n    \nIm direkten Vergleich sind einige Unterschiede festzustellen:\n<ul>    \n<li> Klasse: Es können Methoden auf der höchste Ebene (top-level) deklariert und aufgerufen werden. </li>\n<li> Methodensyntax: Methoden werden mit dem Schlüsselbegriff <code>fun</code> gekennzeichnet. Falls die Methode keinen Rückgabetyp (in Java gekennzeichnet durch <code>void</code>) besitzt, wird die explizite Angabe des Rückgabetyps weggelassen.</li>\n<li> Hauptprogramm: Das Argument der <code>main</code>-Methode (in Java <code>String[] args</code>) muss nicht übergeben werden und wird, falls es nicht existiert, von Kotlin ergänzt.</li>\n<li> <code>println()</code>: Die Bibliotheksmethode <code>println()</code> befindet sich in der Standardbibliothek von Kotlin, weswegen sie direkt ausgerufen werden kann.</li>\n</ul>    \nEine Methode kann, wie in Java, mit ihrem Namen aufgerufen werden:"
    }
   ]
  },
  {
   "artifact_name": "m.164",
   "versions": [
    {
     "start_checkpoint": 1617025435363,
     "parent": "n.0.76",
     "markdown": "Der Methodenkopf und -aufruf verändern sich nicht. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt ein Wert zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;`. Während in Java nach jeder Anweisung ein Semikolon folgen muss, ist das in Kotlin nur noch der Fall, wenn mehrere Anweisungen in eine Zeile geschrieben werden. Ansonsten ist kein Semikolon notwendig.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n\n<table style=\"width:800px; font-size:18px\">\n<tr>\n<th>Java</th>\n<th>Kotlin</th>\n</tr>\n\n<tr>\n<td>\"Hello World\" + name</td>\n<td>\"Hello World \\$name\" </td>\n</tr>\n\n<tr>\n<td>String.format(\"Hello World %s\", name)</td>\n<td></td>\n</tr>\n</table>\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert bzw. angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    },
    {
     "start_checkpoint": 1617025559423,
     "parent": "n.0.77",
     "markdown": "Bei dem Methodenkopf und -aufruf ist kein Unterschied zu erkennen. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt der Wert '\"Max\"' zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;`. Während in Java nach jeder Anweisung ein Semikolon folgen muss, ist das in Kotlin nur noch der Fall, wenn mehrere Anweisungen in eine Zeile geschrieben werden. Ansonsten ist kein Semikolon notwendig.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n\n<table style=\"width:800px; font-size:18px\">\n<tr>\n<th>Java</th>\n<th>Kotlin</th>\n</tr>\n\n<tr>\n<td>\"Hello World\" + name</td>\n<td>\"Hello World \\$name\" </td>\n</tr>\n\n<tr>\n<td>String.format(\"Hello World %s\", name)</td>\n<td></td>\n</tr>\n</table>\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert bzw. angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    },
    {
     "start_checkpoint": 1617025660878,
     "parent": "n.0.78",
     "markdown": "Bei dem Methodenkopf und -aufruf ist kein Unterschied zu erkennen. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt der Wert `\"Max\"` zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;`. Während in Java nach jeder Anweisung ein Semikolon folgen muss, ist das in Kotlin nur noch der Fall, wenn mehrere Anweisungen in eine Zeile geschrieben werden. Ansonsten ist kein Semikolon notwendig.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n\n<table style=\"width:800px; font-size:18px\">\n<tr>\n<th>Java</th>\n<th>Kotlin</th>\n</tr>\n\n<tr>\n<td>\"Hello World\" + name</td>\n<td>\"Hello World \\$name\" </td>\n</tr>\n\n<tr>\n<td>String.format(\"Hello World %s\", name)</td>\n<td></td>\n</tr>\n</table>\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert bzw. angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    },
    {
     "start_checkpoint": 1617025751985,
     "parent": "n.0.79",
     "markdown": "Bei dem Methodenkopf und -aufruf ist kein Unterschied zu erkennen. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt der Wert `\"Max\"` zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;` nach jeder Anweisung. Dieses wird in Kotlin nur noch benutzt, wenn mehrere Anweisungen in eine Zeile geschrieben werden.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n\n<table style=\"width:800px; font-size:18px\">\n<tr>\n<th>Java</th>\n<th>Kotlin</th>\n</tr>\n\n<tr>\n<td>\"Hello World\" + name</td>\n<td>\"Hello World \\$name\" </td>\n</tr>\n\n<tr>\n<td>String.format(\"Hello World %s\", name)</td>\n<td></td>\n</tr>\n</table>\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert bzw. angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    },
    {
     "start_checkpoint": 1617025756251,
     "parent": "n.0.80",
     "markdown": "Bei dem Methodenkopf und -aufruf ist kein Unterschied zu erkennen. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt der Wert `\"Max\"` zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;` nach jeder Anweisung. Dieses wird in Kotlin nur noch benutzt, wenn mehrere Anweisungen in eine Zeile geschrieben werden.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n<table style=\"width:800px; font-size:18px\">\n<tr>\n<th>Java</th>\n<th>Kotlin</th>\n</tr>\n\n<tr>\n<td>\"Hello World\" + name</td>\n<td>\"Hello World \\$name\" </td>\n</tr>\n\n<tr>\n<td>String.format(\"Hello World %s\", name)</td>\n<td></td>\n</tr>\n</table>\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert bzw. angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    },
    {
     "start_checkpoint": 1617025773471,
     "parent": "n.0.81",
     "markdown": "Bei dem Methodenkopf und -aufruf ist kein Unterschied zu erkennen. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt der Wert `\"Max\"` zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;` nach jeder Anweisung. Dieses wird in Kotlin nur noch benutzt, wenn mehrere Anweisungen in eine Zeile geschrieben werden.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n<table style=\"width:800px; font-size:18px\">\n<tr>\n<th>Java</th>\n<th>Kotlin</th>\n</tr>\n\n<tr>\n<td>\"Hello World\" + name</td>\n<td>\"Hello World \\$name\" </td>\n</tr>\n\n<tr>\n<td>String.format(\"Hello World %s\", name)</td>\n<td></td>\n</tr>\n</table>\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert beziehungsweise angehängt werden, können diese in Kotlin direkt in String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    },
    {
     "start_checkpoint": 1617025783710,
     "parent": "n.0.82",
     "markdown": "Bei dem Methodenkopf und -aufruf ist kein Unterschied zu erkennen. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt der Wert `\"Max\"` zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;` nach jeder Anweisung. Dieses wird in Kotlin nur noch benutzt, wenn mehrere Anweisungen in eine Zeile geschrieben werden.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n<table style=\"width:800px; font-size:18px\">\n<tr>\n<th>Java</th>\n<th>Kotlin</th>\n</tr>\n\n<tr>\n<td>\"Hello World\" + name</td>\n<td>\"Hello World \\$name\" </td>\n</tr>\n\n<tr>\n<td>String.format(\"Hello World %s\", name)</td>\n<td></td>\n</tr>\n</table>\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert beziehungsweise angehängt werden, können diese in Kotlin direkt in einen String mit `$` integriert werden.<br />\nFalls ein Methodenaufruf mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    },
    {
     "start_checkpoint": 1617025822464,
     "parent": "n.0.102",
     "markdown": "Bei dem Methodenkopf und -aufruf ist kein Unterschied zu erkennen. <br>\nIn der Methode hingegen wurde eine neue Variable `name` deklariert und dieser direkt der Wert `\"Max\"` zugewiesen. Das hier verwendete Stichwort zur Deklaration der Variable ist `val` (näheres dazu in [Lektion 2](#Lektion-2---Variablen)). Der Datentyp der Variable wird hinter deren Namen mit einem `:` getrennt angegeben. Eine weitere Auffälligkeit ist das Fehlen von `;` nach jeder Anweisung. Dieses wird in Kotlin nur noch benutzt, wenn mehrere Anweisungen in eine Zeile geschrieben werden.<br>\nEin weiterer Unterschied zwischen Kotlin und Java ist die Verwendung von Variablen in Strings:\n<table style=\"width:800px; font-size:18px\">\n<tr>\n<th>Java</th>\n<th>Kotlin</th>\n</tr>\n\n<tr>\n<td>\"Hello World\" + name</td>\n<td>\"Hello World \\$name\" </td>\n</tr>\n\n<tr>\n<td>String.format(\"Hello World %s\", name)</td>\n<td></td>\n</tr>\n</table>\n\nWährend in Java die Variablen mit `+` oder `String.format()` in einen String eingegliedert beziehungsweise angehängt werden, können diese in Kotlin direkt in einen String mit `$` integriert werden.<br />\nFalls die Rückgabe einer Anweisung mit `print()` ausgegeben werden soll, müssen zusätzlich geschweifte Klammern um diesen. "
    }
   ]
  },
  {
   "artifact_name": "m.165",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "<div class=\"alert alert-block alert-info\">\n    In Jupyter Notebooks wird ein Code Block als Hauptprogramm angesehen, das bei Run (Shift+Enter) ausgeführt wird. Deswegen kann der Methodenkopf weggelassen werden.\n</div>"
    }
   ]
  },
  {
   "artifact_name": "m.166",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "## Lektion 2 - Variablen\nDiese Lektion behandelt Variablen, Datentypen und Vergleiche.\n### Variablen\nVariablen lassen sich in Kotlin in 2 Arten unterglieder: \n<div style=\"width: calc(100% - 500px); float:left\">\n    <ul>\n        <li> <code>val</code> (value): Beschreibt eine Variable mit <b>lesenden</b> Zugriff. Bei Deklarierung muss ihr direkt ein Wert zugewiesen werden, welcher nicht mehr verädnert werdne kann. Eine `val`-Variable in Kotlin ist mit einer `final`-Variable in Java zu vergleichen.</li>\n        <li> <code>var</code> (variable): Beschreibt eine Variable mit <b>lesenden</b> und <b>schreibenden</b> Zugriff. Ihr Wert kann beliebig oft verändert werden und muss nicht direkt bei Deklarierung gesetzt werden. Dies entspricht einer normalen Variable in Java.</li>\n    </ul>\n</div>\n<img title=\"Variablen\" alt=\"Variablen\" src=\"images/variablen.png\" style=\"width: 500px; float: left\">\n\nEin Beispiel:"
    }
   ]
  },
  {
   "artifact_name": "m.167",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "Die Untergliederung der Variablen in `val` und `var` hat den Hintergrund, dass der funktionale Programmierstil, welcher einfacher zu verstehen ist, gefördert werden soll. Außerdem soll der Code verständlicher werden, da klar ist, ob die Variable verändert wird oder nicht. Es herrscht der Grundsatz: `val` vor `var`.<br />\nDer Syntax einer zu initialisiernden Variable folgendermaßen:\n>Variable -> (\"var\"|\"val\") name \":\" Datentyp \"=\" Wert.<br />\n\nEine weitere Besonderheit bei Variablen ist der Umgang mit `null`. Variablen, die mit dem eben kennengelernten Syntax initialisiert und deklariert werden, können nicht den Wert `null` annehmen. Genaueres dazu in Abschnitt 2.\n```kotlin \nvar test_null : Int = null //-> Null can not be a value of a non-null type Int\n```\n### Kostanten\nKonstanten sind Variablen der Kategorie `val`, denen das Schlüsselwort `const` vorangestellt wird. Sie dürfen nur auf der Top-Level-Ebene oder in Objekten (näheres dazu in Abschnitt 3) deklariert werden:\n```kotlin \nconst val constant : Int = 24\n```\n\nSomit kann der Syntax erweitert werden:<br />\n>Variable -> \"var\" name \":\" Datentyp \"=\" Wert.<br />\nVariable -> [const] (\"var\"|\"val\") name \":\" Datentyp \"=\" Wert.<br />\n\nAuf den ersten Blick scheinen schreibgeschützte Variablen und Konstanten den gleichen Nutzen haben: Einen unveränderlichen Wert speichern und zur Verfügung stellen. Im Grunde ist das richtig, jedoch gibt es einen großen Unterschied. Während `val`-Variablen als sogenannte \"runtime constants\" angesehen werden, sind Konstenten \"compile-time constants\". Praktisch bedeutet dies, dass eine Konstante immer den bei der Kompilierung zugewiesenen Wert besitzt, während eine schreibgeschützte Variable bei jedem Ausführen einen unterschiedlichen, aber unveränderlichen Wert annehmen kann."
    }
   ]
  },
  {
   "artifact_name": "m.168",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "<div class=\"alert alert-block alert-warning\">\nDa jeder Block als Bestandteil eines Hauptprogramms angesehen wird, können in Jupyter Notebooks keine Konstanten verwendet werden.\n</div>"
    }
   ]
  },
  {
   "artifact_name": "m.169",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "### Datentypen\nKotlin ist, wie Java auch, eine statisch typisierte Programmiersprache. Das bedeutet, dass jeder Variable, jeder Ausdruck einem statischen Typ besitzt, der bei Deklarierung festgelegt wird und bei Kompilierung erkennbar sein muss. Dies kann entweder explizit durch eine Datentypzuweisung oder implizit durch eine direkte aussagekräftige Initialisierung erfolgen. In diesem Fall wird der Variable vom Compiler ein, zum Wert passender, Datentyp zugewiesen."
    }
   ]
  },
  {
   "artifact_name": "m.170",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "Dadurch kann der bisher kennengelernte Syntax von Variablen vervollständigt werden:<br />\n>Variable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nÜberblick über die wichtigsten Datentypen:\n\n<table style=\"font-size:18px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Werte</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Byte</td>\n    <td>-128 bis 127</td>\n    <td>byte</td>\n  </tr>\n  <tr>\n    <td>Short</td>\n    <td>-32768 bis 32767</td>\n    <td>short</td>\n  </tr>\n  <tr>\n    <td>Int</td>\n    <td>-2.147.483.648 bis 2.147.483.647</td>\n    <td>int</td>\n  </tr>\n  <tr>\n    <td>Long</td>\n    <td>-9.223.372.036.854.775.808 bis 9.223.372.036.854.775.808</td>\n    <td>long</td>\n  </tr>\n  <tr>\n    <td>Float</td>\n    <td>6 bis 7 Dezimalstellen</td>\n    <td>float</td>\n  </tr>\n  <tr>\n    <td>Double</td>\n    <td>15 bis 16 Dezimalstellen</td>\n    <td>double</td>\n  </tr>\n  <tr>\n    <td>Boolean</td>\n    <td>`true` oder `false`</td>\n    <td>boolean</td>\n  </tr>\n  <tr>\n    <td>Char</td>\n    <td>16-Bit-Unicode-Zeichen</td>\n    <td>char</td>\n  </tr>\n  <tr>\n    <td>String</td>\n    <td>Folge von Zeichen</td>\n    <td>String</td>\n  </tr>\n</tbody>\n</table>\n<div style=\"float:left; width: calc(100% - 500px)\">\nAnders als in Java wird nicht zwischen primitiven und nicht-premitiven Datentypen entschieden. Alle Datentypen repräsentieren eine Klasse. Dadurch kann eine Typhierarchie aufgebaut werden. Dazu müssen aber zunächst 2 neue Typen eingeführt werden: `Any` und `Nothing`. Sie beschreiben das extreme Datentypen.`Any` ist der allgemeinste Datentyp und somit die Super-Klasse aller anderen Typen. `Nothing` hingegen ist der kleinste Datentyp und die Sub-Klasse aller anderen Typen.<br />\n</div>\n<img title=\"Typhierarchie\" alt=\"Typhierarchie\" src=\"images/typhierarchie.png\" style=\"width: 500px; float:left\">\n<div style=\"clear: left\" />\n\n\n### Vergleiche\nVergleiche sind in Kotlin einfacher und intuitiver als in Java. Der Grund dafür ist, dass nicht mehr zwischen elementaren und nicht-elementaren Datentypen unterschieden wird. Alle von Kotlin bereitgestellte Datentypen implementieren das `Comparable`-Interface und können somit mit `compareTo()` verglichen werden. Jedoch muss nicht die Methode zum Vergleichen aufrufen, sondern lediglich bekannten Vergleichszeichen verwendet werden. Dabei wird in Kotlin mit `==` der Inhalt der Variable verglichen und nicht wie in Java die Referenz. Für einen Vergleich der Refernzen wurde in Kotlin das Zeichen `===` eingeführt. `<`und `>` entsprechen dem Rückgabewert `-1` beziehungsweise `1` von `compareTo()`."
    }
   ]
  },
  {
   "artifact_name": "m.171",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "### Aufgabe\nÜbersetzen Sie folgenden Java-Code nach Kotlin und wählen Sie passende Variablentypen.\n```java\nfinal static float PI = 3.14159f;\nint a = 50;\nint b = 20;\nint res;\nfinal boolean bool = false;\na = a + 30;\nres = a - b;\nString output = \"a - b ist: \" + res + \".\";\nSystem.out.println(output);\n```"
    }
   ]
  },
  {
   "artifact_name": "m.172",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "## Lektion 3 - Methoden\nIn dieser Lektion werden Methoden näher beleuchtet.\n### Grundlagen\nEine Methode in Kotlin unterscheidet sich in der Grundstruktur nicht stark von einer in Java.<br />\n<img title=\"Struktur einer Methode\" alt=\"Struktur einer Methode\" src=\"images/methoden_struktur.png\" style=\"width: 700px; text-align: center\">\n\nDer Methodenkopf beginnt mit dem Schlüsselwort `fun` gefolgt von deren Name. Danach werden in runden Klammern, falls benötigt, die Parameter angegeben. Ansonsten werden diese leer gelassen. Bevor der Methodenrumpf mit `{` beginnt, ist noch der Rückgabetyp, der von den Parameterklammern durch einen `:` getrennt wird, zu finden. Dieser kann weggelassen werden, falls die Methode keine Rückgabe besitzt (in Java mit `void` gekennzeichnet). <br />\nEs ergibt sich folgender Syntax: <br />\n>Funktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"\n\nFalls ein Rückgabetyp angegeben ist, muss etwas zurückgegeben werden. Dies wird mit `return` eingeleitet. Falls der Rückgabetyp fehlt, gibt die Methode nichts zurück, kann aber mit `return` beendet werden. Das Hauptprogramm besitzt den Methodenkopf:\n```kotlin\nfun main(){ ... }\n//oder\nfun main(args: Array) { ... }\n```"
    }
   ]
  },
  {
   "artifact_name": "m.173",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "### Parameter\nEs können einer Methode beliebig viele Parameter übergeben werden. Dabei wird zuerst der Name und danach der Datentyp angegeben. Sie werden mit einem Doppelpunkt getrennt. Außerdem kann jedem Parameter ein default-Wert zugewiesen werden. Wird der Parameter bei Methodenaufruf weggelassen wird er auf diesen gesetzt. **Falls kein default-Wert festgelegt wurde, wird der Parameter mit dem default-Wert des Datentyps gefüllt. ÜBERPRÜFEN** Es können auch bestimmte Parameter mit deren Namen im Methodenaufruf direkt angesprochen werden. Dann ist die Reihenfolge der mit Namen genannten Übergabeparameter unwichtig. Es sollte jedoch nur eine Form der Übergabe angewendet werden, da dies sonst zu einer falschen Positionierung führen kann.<br />\nSyntax der Parameter:<br />\n>Parameter -> Name \":\" Datentyp [\"=\" default-Wert] {\",\" Parameter}<br />"
    }
   ]
  },
  {
   "artifact_name": "m.174",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "### Rückgabe\nEine Methode kann, falls ein Rückgabetyp definiert ist, einen Wert zurückgeben. Falls mehrere Wert zurückgegeben sollen, muss eine Datenstruktur (zum Beispiel ein Array, näheres dazu in [Lektion 6](#Lektion-6---Datenstrukturen)) oder eine eigens definierte Datenklasse (näheres dazu in Abschnitt 3) erstellt werden. Ist kein Rückgabetyp definiert, wird implizit `Unit` zurückgegeben. Dies ist das Gegenstück zu dem Schlüsselwort `void` in Java. Jedoch könnte auch das bereits kennengelernte `Nothing` signalisieren, dass nichts zurückgegeben wird. Der Unterschied ist, dass `Unit` signalsisiert, dass keine wichtigen Daten zurückgegeben werden. `Nothing` hingegen bedeutet jedoch, dass nichts zurückgegeben wird beziehungsweise die Methode nicht terminieren wird. Der einzig praktische Anwendungsfall ist, wenn die Methode immer einen Fehler wirft.\n```kotlin\n//Fall 1\nfun loop(): Nothing{\n    while(true){ ... }\n}\n//Fall 2\nfun fail(message: String): Nothing{\n    throw Exception(message)\n}\n```\nSchauen wir uns den 2. Fall genauer an. Der Methode `fail` wird eine Nachricht übergeben, die durch einen geworfenen Fehler ausgegeben wird. Ein konkreter Anwendungsfall wäre zum Beispiel:\n```kotlin\nfun foo(num: Int) : Int{\n    if (num == 42){\n        return 42\n    }\n    else{\n        return fail(\"Falsch\")\n    }\n}\n```\n<div style=\"width:80%; float:left\">Ziel der Methode ist es, herauszufinden, ob eine übergebe Zahl gleich <code>42</code><code>42</code> ist, falls nicht soll eine Fehlermeldung geworfen werden. Optimaler Rückgabetyp ist deswegen <code>Int</code>. Falls <code>42</code> übergeben wird, gibt die Methode den Wert <code>42</code> vom Typ <code>Int</code> zurück. Jedoch könnte auch eine falsche Zahl übergeben werden. Dann würde man in den <code>else</code>-Fall kommen und die Methode <code>fail</code> aufrufen, die einen Fehler wirft und <code>Nothing</code> zurückgibt. In Lektion 2 wurde <code>Nothing</code> bereits als Sub-Typ aller Datentypen eingeführt. Eine Methode besitzt immer den größten gemeinsamen Rückgabetyp aller return-Statements. In diesem Beispiel ist der Datentyp des if-Blocks <code>Int</code> und der des else-Blocks <code>Nothing</code>. Da <code>Nothing</code> der Sub-Typ von <code>Int</code> ist, ist der größte gemeinsame Datentyp <code>Int</code>. Würde die Methode <code>fail</code> jedoch <code>Unit</code> zurückgeben, dürfte der Rückgabetyp von <code>foo</code> nicht <code>Int</code> sein, da der größte gemeinsame Datentyp <code>Any</code> wäre.</div>\n<img title=\"Nothing & Util\" alt=\"Nothing & Util\" src=\"images/nothing_util.png\" style=\"width: 20%; float:left\">\n\n\n"
    }
   ]
  },
  {
   "artifact_name": "m.175",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "### Besonderheiten\n#### Kurzschreibweise\nBestimmte Arten von Methoden können in einer Kurzschreibweise geschrieben werden. Besonders praktisch ist dies für Methoden, die nur wenige Zeilen umfassen und etwas zurückgeben. Dabei wird der Methodenrumpf mit `=` getrennt direkt hinter den Methodenkopf geschrieben. Auch wird das Schlüsselwort `return` weggelassen. Der Rückgabetyp wird nach dem Prinzip des größten gemeinsamen Typ implizit vom Compiler ermittelt."
    }
   ]
  },
  {
   "artifact_name": "m.176",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "#### Überladen\nDas Überladen von Methoden ist auch in Kotlin möglich. Einzige Einschränkung ist, dass der Compiler - genauso wie in Java - das Parameterprofil der unterschiedlichen Methoden voneinander unterscheiden kann."
    }
   ]
  },
  {
   "artifact_name": "m.177",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "### `if`-Verzweigung\nDie gängiste Art einer Verzweigung ist eine mit `if`. In Verbindung mit `else` und `else if` können so mehrere Fälle definiert, geprüft und entsprechende Anweisungen ausgeführt werden. Falls nur eine Anweisung einem Fall zugeordnet wird, können die geschweiften Klammern weggelassen werden.\n```kotlin\nfun foo(a: Int): String {\n    if (a < 10) \n        return \"kleiner 10\"\n    else if (a == 10) \n        return \"gleich 10\"\n    else {\n        val b = 20\n        return \"groeßer 10\"\n    }\n}\n```\nEine Neuerung ist, dass die `if`-Verzweigung als eine Art eigene Methode angesehen wird. Deswegen kann einer Variable eine `if`-Verzweigung zugewiesen werden, falls jeder Fall einen Wert zurückgibt. Dies kann man weiter vereinfachen, indem das `return` nicht vor jeden Rückgabewert sondern vor das `if` geschrieben wird. In den Fällen wird das Schlüsselwort dann weggelassen."
    }
   ]
  },
  {
   "artifact_name": "m.178",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "### `when`-Verzweigung\nEine weitere Art der Verzweigung ist `when`. Diese ähnelt von der Funktionalität an Javas `switch`. Das Schlüsselwort mit dem diese Verzweigung eingeleitet wird, ist `when`. In runden Klammern muss daraufhin die zu untersuchende Variable folgen. In dem Block steht links ein Vergleichswert (die Vergleichswerte mit Komma getrennt) und rechts eine Anweisung (mehrere Anweisungen in einem `{ ... }`-Block). Getrennt werden die beiden Seite mit `->`. Anders als in Java muss nicht nach jedem Block ein `break` stehen, falls die Verzweigung verlassen werden soll. Standardmäßig wird nach dem Ausführen der rechten Seite der `when`-Block verlassen. Ein \"Durchrutschen\" geschieht nicht. Der default-Fall wird mit `else` auf der linken Seite gekennzeichnet."
    }
   ]
  },
  {
   "artifact_name": "m.179",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "`when` findet vor Allem dann an, wenn mehr als 2 Fälle zu untersuchen sind. Dann ist es `if` vorzuziehen. <br />\nNäher an `if` kann es durch eine weitere Erweitung kommen. Wird die zu untersuchende Variable im Kopf weggelassen, können auf der linken Seite boolsche Ausdrücke definiert werden. Folgender Code mit einer `if`-Verzweigung soll nun mit einer `when`-Verzweigung ersetzt werden:\n```kotlin\nval a = 10\nif (a < 10) \n   println(\"gleich 10\")\nelse if (a < 10) \n   println(\"kleiner 10\")\nelse \n   println(\"groeßer 10\")\n```"
    }
   ]
  },
  {
   "artifact_name": "m.180",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.102",
     "markdown": "#### Aufgabe\n1. Schreiben sie eine Methode `typCheckerIf`, die den Datentyp der übergebenen Variable als String mit Hilfe einer `if`-Verzweifung zurückgibt. Als Vereinfachung soll nur zwischen den Datentypen `Int`, `Double` und `Long` unterschieden werden. Sollte keiner dieser Datentypen zutreffe soll `Sonstiges` zurückgegeben werden.\n2. Schreiben Sie nun eine zweite Methode `typCheckerWhen`, die die `if`-Verzweigung durch eine `when`-Verzweigung ersetzt."
    }
   ]
  },
  {
   "artifact_name": "m.181",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "n.0.84",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\n>Variable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben. Wenn ein Anweisungsblock ausgeführt wurde, wird der `when`-Block verlassen und nicht weiter ausgeführt.<br />\nDie `for`-Schleife iteriert über Bereiche. Diese werden durch einen Start- und Endpunkt definiert getrennt von `..`. Die von Kotlin bereitgestellten Bereiche sind von den Typen `Int`, `Long` und `Char`. Soll ein Bereich absteigend sein, muss statt `..` `downTo` verwendet werden. Bei einem Bereich mit dem Schlüsselwort `until` ist der Endwert explizit. Nach dem Endwert kann noch ein `step` mit anschließender Schrittweite angegeben werden.<br />\nDie normale Iteration über einen Bereich wird mit dem Schlüsselwort `in` herbeigeführt. Ebenso kann aber mit diesem auch über eine Datenstruktur (zum Beispiel eine Liste) iteriert werden. In diesem Fall wird in der Laufvariable das Element der Liste gespeichert. Dieses kann nicht verändert werden. Hängt man der Liste `withIndex()` an, so wird ein Paar aus Index und Element bei jedem Durchlauf belegt.<br />\nSoll eine bestimmte Schleife beendet werden, kann dies mit dem Schlüsselwort `break` passieren. Diesem wird getrennt mit einem `@` der Name der Schleife angegeben. Zuvor muss dieser Name dieser aber zugewiesen werden. Dies erfolgt mit name`@` vor dem Schleifenkopf.<br />\nEine weitere Schleife ist die `while`-Schleife. Diese ist identisch zu der Umsetzung in Java. Außerdem wird ebenfalls die `do-while`-Schleife unterstützt.<br />\nFür einfache Zwecke ist die `repeat`-Schleife vorteilhaft. Dieser wird als Parameter ein positiver `Int`-Wert übergeben, bis zu dem von 0 aus iteriert wird. In der Schleife kann auf die aktuelle Durchlaufzahl mit `it` zugegriffen werden.<br /><br />"
    }
   ]
  },
  {
   "artifact_name": "m.182",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.91",
     "markdown": "### Typumwandlung\nDatentypen können mit dem Schlüsselwort `as` umgewandelt werden. Dabei ist zu beachten, dass der Wert der Variable bereits für den neuen Datentyp gültig sein muss. Eine Umwandlung von `Int` zu `Float` ist damit nicht möglich. In diesem Fall würde die Methode `toFloat()` Anwendung finden."
    }
   ]
  },
  {
   "artifact_name": "m.183",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "### Array\nDie Aufbau eines Arrays sollte bereits umfänglich bekannt sein. Die Funktionsweise in Kotlin unterscheidet sich nicht stark von der Java, abgesehen von der Inititalisierung. Diese kann entweder mit dem Schlüsselwort `arrayOf` erfolgen, falls alle Werte bereits vorliegen, oder mit dem Ausdruck `Array(Länge) {Standardwert}`. Dann wird ein leeres Array mit einer festgelegten Länge erzeugt."
    }
   ]
  },
  {
   "artifact_name": "m.184",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "Mehrdimensionale Arrays können, wie in Java, erstellt werden, indem in ein Element eines eindimensionales Arrays ein weiteres Array zu finden ist.\n\n\n"
    }
   ]
  },
  {
   "artifact_name": "m.185",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "#### Aufgabe\nVervollständigen Sie folgendes Codegerüst, sodass das 2 dimensionale Array `array` formatiert ausgegeben wird."
    }
   ]
  },
  {
   "artifact_name": "m.186",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "### Liste\nAufgrund einer größeren Flexibilität und besseren Implementierung sind in Kotlin Listen gegenüber Arrays zu bevorzugen. Ähnlich zu den zwei verschiedene Variablentypen (`val`/`var`), sind Listen ebenso in veränderbare (`MutableList`) und unveränderbare (`List`) Listen aufgeteilt. Während die `MutableList` an eine klassische `List` in Java erinnert, können die Einträge einer Kotlin-`List` im nachhinein nicht verändert werden. In einer Liste nur Elemente eines Typs gespeichert werden.\n\n_Quizfrage: Wie kann ich eine Liste erzeugen, in der alle Datentypen gespeichert werden können? -> Any_\n#### Inititalisierung\nEine Liste kann, ähnlich zu einem Array, mit der Methode `listOf()` beziehungsweise `mutableListOf()` erzeugt werden. Als Parameter können die Listeneinträge übergeben werden. Falls eine leere `MutableList` initialisiert werden soll, muss außerdem der Datentyp der Elemente angegeben werden. Des Weiteren kann auch der bereits bei Arrays kennengelernte Konstruktor angewendet werden. Dabei muss eine (bei `List` festgesetzte) Länge angegeben werden. In den geschweiften Klammern kann mit dem Schlüsselwort `it` der Index des zu füllenden Elements abgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.187",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "#### Veränderbar & Unveränderbar\nBei der Betrachtung des obigen Beispiels könnten einige Fragen aufgekommen sein, die mit der Veränderbarkeit der Listen und deren Variablen zutun hat. Deswegen folgt hier noch eine ausführlichere Erklärung.<br />\nBeginnen wir mit einer Betrachtung der Listentypen: \n- Eine Liste der Klasse `List` können Sie sich vorstellen wie eine Liste mit einer, bei Inititalisierung festgelegter, Länge. In der Liste sind Variablen des Typs `val` gespeichert. Diese können also nicht verändert werden. \n- Eine Liste der Klasse `MutableList` hat keine festgelegte Länge und kann folglich beliebig verlängert oder verkürzt werden. Die Elemente sind Variablen des Typs `var` und können verändert werden.\n\nGespeichert werden die Listen in eigenen Variablen, die wiederum verschieden veränderbar sein können:\n- Wird eine Liste in einer Variable des Typs `val` gespeichert, kann der Variable keine neue Liste zugewiesen werden. Dies hat jedoch **keinen** Einfluss auf den Typ der Liste.\n- Wird eine Liste in einer Variable des Typs `var` gespeichert, kann die gespeicherte Liste durch eine Andere ersetzt werden. Die Variable ist veränderbar. Falls jedoch eine unveränderbare Liste in einer veränderbaren Variable gespeichert wird, kann die Liste dennoch nicht bearbeitet werden.\n\nZusammenfassung:\n\n<table>\n<thead>\n  <tr>\n    <th></th>\n    <th>List</th>\n    <th>MutableList</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>val</td>\n    <td>Variable und Liste können nicht verändert werden</td>\n    <td>Variable kann nicht verändert werden, die Liste hingegen schon.</td>\n  </tr>\n  <tr>\n    <td>val</td>\n    <td>Variable kann verändert werden, die Liste hingegen nicht.</td>\n    <td>Variable und Liste können verändert werden</td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.188",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "#### Ausgewählte Operationen\nIm folgenden werden einige ausgewählte Operationen vorgestellt, mit denen Listen bearbeitet werden können.\n##### Zugriff auf ein Element\nDer Zugriff auf ein Element kann entweder, wie bei einem Array, mit dem Index erfolgen oder mit der Methode `get()` und dem Index als Parameter."
    }
   ]
  },
  {
   "artifact_name": "m.189",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "##### Konvertierung\nListen können untereinander mit `toList()` beziehungsweise `toMutableList()` konvertiert werden. Außerdem können auch andere Datenstrukturen mit dieser Methode zu einer Liste konvertiert werden. Dies ist vor Allem hilfreich, wenn Datenstrukturen ausgegeben werden sollen. "
    }
   ]
  },
  {
   "artifact_name": "m.190",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "##### Füllen und Leeren\nEine veränderbare Liste kann durch `fill()` mit dem übergebenden Element gefüllt werden. `clear()` hingegen löscht alle Elemente aus der Liste."
    }
   ]
  },
  {
   "artifact_name": "m.191",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "##### Anordnen und Zufall\nEin zufälliges Element einer Liste (oder auch von einem Bereich) kann mit `random()` erhalten werden.<br />\nSoll eine veränderbare Liste durchmischt werden, findet `shuffle()` Anwendung.<br />\nDas sortieren einer veränderbaren Liste funktioniert unter Anderem mit `sort()`. [Genauere Informationen](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sort.html) zum Sortieren"
    }
   ]
  },
  {
   "artifact_name": "m.192",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.96",
     "markdown": "#### Aufgabe TODO "
    }
   ]
  },
  {
   "artifact_name": "m.193",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "### Set\nSets sind primitivere Listen. Ihre Elemente sind ungeordnet und besitzen keine Duplikate. Nur ein `MutableSet` kann vergrößert oder verkleinert werden. Erzeugt können sie mit `setOf()` beziehungsweise `mutableSetOf()` werden."
    }
   ]
  },
  {
   "artifact_name": "m.194",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.102",
     "markdown": "### Map\nMaps sind eine Liste von Paaren. Ein Paar besteht aus einem Schlüssel (key) und einem Wert (value). Der Schlüssel ist dabei der _Index_ eines Werts. Eine unveränderbare Map gehört der Klasse `Map` an und kann mit `mapOf()` erzeugt werden, während eine Veränderbare der Klasse `MutableMap` zugeordnet und mit Hilfe von `mutableMapOf()` initialisiert wird. Ein Eintrag in einer Map wird mit einem Schlüssel und einem Wert verbunden mit `to` gekennzeichnet. Zu einer veränderbaren Map kann mit der Methode `put()` ein Eintrag hinzugefügt werden. Dazu müssen der Schlüssel und der Wert übergeben werden. Ein Eintrag kann mit `remove()` und der Angabe des Schlüssels entfernt werden."
    }
   ]
  },
  {
   "artifact_name": "m.195",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "n.0.96",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\n>Variable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben. Wenn ein Anweisungsblock ausgeführt wurde, wird der `when`-Block verlassen und nicht weiter ausgeführt.<br />\nDie `for`-Schleife iteriert über Bereiche. Diese werden durch einen Start- und Endpunkt definiert getrennt von `..`. Die von Kotlin bereitgestellten Bereiche sind von den Typen `Int`, `Long` und `Char`. Soll ein Bereich absteigend sein, muss statt `..` `downTo` verwendet werden. Bei einem Bereich mit dem Schlüsselwort `until` ist der Endwert explizit. Nach dem Endwert kann noch ein `step` mit anschließender Schrittweite angegeben werden.<br />\nDie normale Iteration über einen Bereich wird mit dem Schlüsselwort `in` herbeigeführt. Ebenso kann aber mit diesem auch über eine Datenstruktur (zum Beispiel eine Liste) iteriert werden. In diesem Fall wird in der Laufvariable das Element der Liste gespeichert. Dieses kann nicht verändert werden. Hängt man der Liste `withIndex()` an, so wird ein Paar aus Index und Element bei jedem Durchlauf belegt.<br />\nSoll eine bestimmte Schleife beendet werden, kann dies mit dem Schlüsselwort `break` passieren. Diesem wird getrennt mit einem `@` der Name der Schleife angegeben. Zuvor muss dieser Name dieser aber zugewiesen werden. Dies erfolgt mit name`@` vor dem Schleifenkopf.<br />\nEine weitere Schleife ist die `while`-Schleife. Diese ist identisch zu der Umsetzung in Java. Außerdem wird ebenfalls die `do-while`-Schleife unterstützt.<br />\nFür einfache Zwecke ist die `repeat`-Schleife vorteilhaft. Dieser wird als Parameter ein positiver `Int`-Wert übergeben, bis zu dem von 0 aus iteriert wird. In der Schleife kann auf die aktuelle Durchlaufzahl mit `it` zugegriffen werden.<br /><br />\n**Weitere Methodentypen TODO**<br /><br />\n\n\n\nEin weiteres wichtiges Themenfeld sind Datenstrukturen.<br />\nEine bekannte, aber rudimentäre, Datenstruktur ist das **Array**.  Sie zeichnet sich dadurch aus, dass die Länge des Elementspeichers bei Initialisierung festgesetzt wird. Dies kann entweder implizit geschehen, indem das Array mit Elementen durch `arrayOf()`, oder expilizit, wenn ein leeres Array mit dem Konstruktor `Array(Länge) {Standardwert}` erzeugt wird. Auf das n-te Element eines Arrays `array` kann mit `array[n]` und die Länge mit `array.size` zugegriffen werden. Mehrdimensionale Arrays sind ineinader geschachtelte Arrays.<br />\nDie beliebeste Datenstruktur ist die **Liste**. Diese lässt sich in Kotlin in zwei Arten aufsplitten: `List` beschreibt eine unveränderbare, `MutableList` eine veränderbare Liste. Beide speichern nur Elemente eines Datentyps. Erzeugt könne diese mit dem Schlüsselwort `listOf` oder `mutableListOf`. Des Weiteren ist eine Initialisierung mit dem Konstruktoraufruf möglich (analog zum Array): `List(Länge) {Standardwert}`. Soll eine leere Liste erzeugt werden, muss zusätzlich der Datentyp angegeben werden: `listOf<Datentyp>()` oder `mutableListOf<Datentyp>()`.<br />\nSoll auf ein Element an Index `n` einer Liste zugegriffen werden, kann entweder der bereits bekannte Syntax eines Arrays angewendet werden (`liste[n]`) oder die `get(n)`-Methode benutzt werden. Auf die Länge kann mit `size` zugegriffen werden. Soll eine veränderbare Liste mit einem bestimmten Wert gefüllt werden, findet die Methode `fill()` Anwendung. `clear()` hingegen leert die Liste. Um ein Element zu einer Liste hinzuzufügen, ist die `add`-Methode zu verwenden. Ist nur das Element angegeben, wird es hinten angestellt. Wird zusätzlich ein Index übergeben, wird das Element dort eingefügt. Kotlin bietet zusätzlich zu dem einfachen `add()` mit `+=` eine Kurzschreibweise. Mit `remove()` kann ein übergebenes Element aus der Liste gelöscht werden. Soll jedoch das Element an Index `n` entfernt werden, ist die Methode `removeAt(n)` zu verwenden.<br />\nAuf eine Teilliste kann mit `subList(von, bis)` zugegriffen werden. Soll geprüft werden, ob ein Element in einer Liste vorhanden ist, kann dies mit `in` bewerkstelligt werden. Soll anstelle eines Wahrheitswertes der Index des Elements zurückgegeben werden, liefert diesen `indexOf()`. Ein weitere wichtige Methode ist `random()`. Diese liefert ein zufälliges Element aus einer Liste oder auch einem Bereich.<br />\nEine Vereinfachung der Liste ist das **Set**. Die listenähnliche Datenstruktur verzichtet auf Doppelungen und Ordnung und stellt eine Menge dar. Während ein veränderbares Set von der Klasse `MutableSet` ist und mit `mutableSetOf()` erzeugt werden kann, ist ein unveränderbares Set von der Klasse `Set` und wird mit `setOf()` initialisiert.<br />\nAuf Sets können klassische Mengenoperationen angewendet werden. Eine Vereinignung ist mit `union` oder `+` möglich, `intersect` gibt eine Schnittmenge zurück und `subtract` entfernt alle Elemente der ersten Menge aus der Zweiten.<br />\nEine Liste auf Paaren beschreibt die Datenstruktur **Map**. Bei dieser wird jedem Wert ein Schlüssel zugeordnet, mit dem auf diesen wie beim Array oder der Liste zugegriffen werden kann. Bei der Initialsierung werden diese mit einem `to` getrennt. Während bei einer `Map` die Erzeugung mit `mapOf()` stattfindet und keine Änderungen vorgenommen werden können, initialisiert `mutableMapOf()` eine veränderbare Map der Klasse `MutableMap`. Ein Paar kann einer `MutableMap` mit `put()` hinzugefügt und mit `remove()` gelöscht werden."
    },
    {
     "start_checkpoint": 1618238458279,
     "parent": "n.0.97",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\n>Variable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben. Wenn ein Anweisungsblock ausgeführt wurde, wird der `when`-Block verlassen und nicht weiter ausgeführt.<br />\nDie `for`-Schleife iteriert über Bereiche. Diese werden durch einen Start- und Endpunkt definiert getrennt von `..`. Die von Kotlin bereitgestellten Bereiche sind von den Typen `Int`, `Long` und `Char`. Soll ein Bereich absteigend sein, muss statt `..` `downTo` verwendet werden. Bei einem Bereich mit dem Schlüsselwort `until` ist der Endwert explizit. Nach dem Endwert kann noch ein `step` mit anschließender Schrittweite angegeben werden.<br />\nDie normale Iteration über einen Bereich wird mit dem Schlüsselwort `in` herbeigeführt. Ebenso kann aber mit diesem auch über eine Datenstruktur (zum Beispiel eine Liste) iteriert werden. In diesem Fall wird in der Laufvariable das Element der Liste gespeichert. Dieses kann nicht verändert werden. Hängt man der Liste `withIndex()` an, so wird ein Paar aus Index und Element bei jedem Durchlauf belegt.<br />\nSoll eine bestimmte Schleife beendet werden, kann dies mit dem Schlüsselwort `break` passieren. Diesem wird getrennt mit einem `@` der Name der Schleife angegeben. Zuvor muss dieser Name dieser aber zugewiesen werden. Dies erfolgt mit name`@` vor dem Schleifenkopf.<br />\nEine weitere Schleife ist die `while`-Schleife. Diese ist identisch zu der Umsetzung in Java. Außerdem wird ebenfalls die `do-while`-Schleife unterstützt.<br />\nFür einfache Zwecke ist die `repeat`-Schleife vorteilhaft. Dieser wird als Parameter ein positiver `Int`-Wert übergeben, bis zu dem von 0 aus iteriert wird. In der Schleife kann auf die aktuelle Durchlaufzahl mit `it` zugegriffen werden.<br /><br />\nAbgesehen von den normalen, statischen Top-Level-Methoden, die nur mit dem Schlüsselwort `fun` eingeleitet werden, gibt es noch einiger weitere Methodentypen.<br />\n**Erweiterungsmethoden** können Klassen weitere objektmethodenähnliche Methoden hinzufügen. Dies findet vor Allem bei bestehenden Klassen, zum Beispiel aus einer Bibliothek, Anwendung. Der Kopf einer Erweiterungsmethode besitzt folgenden Syntax:<br />\n>Erweiterungsmethode -> \"fun \" Datentyp \".\" Name \"(\" Parameter \")\" \n\nObjektmethoden überlagern jedoch Erweiterungsmethoden immer.\n\n\n\nEin weiteres wichtiges Themenfeld sind Datenstrukturen.<br />\nEine bekannte, aber rudimentäre, Datenstruktur ist das **Array**.  Sie zeichnet sich dadurch aus, dass die Länge des Elementspeichers bei Initialisierung festgesetzt wird. Dies kann entweder implizit geschehen, indem das Array mit Elementen durch `arrayOf()`, oder expilizit, wenn ein leeres Array mit dem Konstruktor `Array(Länge) {Standardwert}` erzeugt wird. Auf das n-te Element eines Arrays `array` kann mit `array[n]` und die Länge mit `array.size` zugegriffen werden. Mehrdimensionale Arrays sind ineinader geschachtelte Arrays.<br />\nDie beliebeste Datenstruktur ist die **Liste**. Diese lässt sich in Kotlin in zwei Arten aufsplitten: `List` beschreibt eine unveränderbare, `MutableList` eine veränderbare Liste. Beide speichern nur Elemente eines Datentyps. Erzeugt könne diese mit dem Schlüsselwort `listOf` oder `mutableListOf`. Des Weiteren ist eine Initialisierung mit dem Konstruktoraufruf möglich (analog zum Array): `List(Länge) {Standardwert}`. Soll eine leere Liste erzeugt werden, muss zusätzlich der Datentyp angegeben werden: `listOf<Datentyp>()` oder `mutableListOf<Datentyp>()`.<br />\nSoll auf ein Element an Index `n` einer Liste zugegriffen werden, kann entweder der bereits bekannte Syntax eines Arrays angewendet werden (`liste[n]`) oder die `get(n)`-Methode benutzt werden. Auf die Länge kann mit `size` zugegriffen werden. Soll eine veränderbare Liste mit einem bestimmten Wert gefüllt werden, findet die Methode `fill()` Anwendung. `clear()` hingegen leert die Liste. Um ein Element zu einer Liste hinzuzufügen, ist die `add`-Methode zu verwenden. Ist nur das Element angegeben, wird es hinten angestellt. Wird zusätzlich ein Index übergeben, wird das Element dort eingefügt. Kotlin bietet zusätzlich zu dem einfachen `add()` mit `+=` eine Kurzschreibweise. Mit `remove()` kann ein übergebenes Element aus der Liste gelöscht werden. Soll jedoch das Element an Index `n` entfernt werden, ist die Methode `removeAt(n)` zu verwenden.<br />\nAuf eine Teilliste kann mit `subList(von, bis)` zugegriffen werden. Soll geprüft werden, ob ein Element in einer Liste vorhanden ist, kann dies mit `in` bewerkstelligt werden. Soll anstelle eines Wahrheitswertes der Index des Elements zurückgegeben werden, liefert diesen `indexOf()`. Ein weitere wichtige Methode ist `random()`. Diese liefert ein zufälliges Element aus einer Liste oder auch einem Bereich.<br />\nEine Vereinfachung der Liste ist das **Set**. Die listenähnliche Datenstruktur verzichtet auf Doppelungen und Ordnung und stellt eine Menge dar. Während ein veränderbares Set von der Klasse `MutableSet` ist und mit `mutableSetOf()` erzeugt werden kann, ist ein unveränderbares Set von der Klasse `Set` und wird mit `setOf()` initialisiert.<br />\nAuf Sets können klassische Mengenoperationen angewendet werden. Eine Vereinignung ist mit `union` oder `+` möglich, `intersect` gibt eine Schnittmenge zurück und `subtract` entfernt alle Elemente der ersten Menge aus der Zweiten.<br />\nEine Liste auf Paaren beschreibt die Datenstruktur **Map**. Bei dieser wird jedem Wert ein Schlüssel zugeordnet, mit dem auf diesen wie beim Array oder der Liste zugegriffen werden kann. Bei der Initialsierung werden diese mit einem `to` getrennt. Während bei einer `Map` die Erzeugung mit `mapOf()` stattfindet und keine Änderungen vorgenommen werden können, initialisiert `mutableMapOf()` eine veränderbare Map der Klasse `MutableMap`. Ein Paar kann einer `MutableMap` mit `put()` hinzugefügt und mit `remove()` gelöscht werden."
    },
    {
     "start_checkpoint": 1618239400984,
     "parent": "n.0.98",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\n>Variable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben. Wenn ein Anweisungsblock ausgeführt wurde, wird der `when`-Block verlassen und nicht weiter ausgeführt.<br />\nDie `for`-Schleife iteriert über Bereiche. Diese werden durch einen Start- und Endpunkt definiert getrennt von `..`. Die von Kotlin bereitgestellten Bereiche sind von den Typen `Int`, `Long` und `Char`. Soll ein Bereich absteigend sein, muss statt `..` `downTo` verwendet werden. Bei einem Bereich mit dem Schlüsselwort `until` ist der Endwert explizit. Nach dem Endwert kann noch ein `step` mit anschließender Schrittweite angegeben werden.<br />\nDie normale Iteration über einen Bereich wird mit dem Schlüsselwort `in` herbeigeführt. Ebenso kann aber mit diesem auch über eine Datenstruktur (zum Beispiel eine Liste) iteriert werden. In diesem Fall wird in der Laufvariable das Element der Liste gespeichert. Dieses kann nicht verändert werden. Hängt man der Liste `withIndex()` an, so wird ein Paar aus Index und Element bei jedem Durchlauf belegt.<br />\nSoll eine bestimmte Schleife beendet werden, kann dies mit dem Schlüsselwort `break` passieren. Diesem wird getrennt mit einem `@` der Name der Schleife angegeben. Zuvor muss dieser Name dieser aber zugewiesen werden. Dies erfolgt mit name`@` vor dem Schleifenkopf.<br />\nEine weitere Schleife ist die `while`-Schleife. Diese ist identisch zu der Umsetzung in Java. Außerdem wird ebenfalls die `do-while`-Schleife unterstützt.<br />\nFür einfache Zwecke ist die `repeat`-Schleife vorteilhaft. Dieser wird als Parameter ein positiver `Int`-Wert übergeben, bis zu dem von 0 aus iteriert wird. In der Schleife kann auf die aktuelle Durchlaufzahl mit `it` zugegriffen werden.<br /><br />\nAbgesehen von den normalen, statischen Top-Level-Methoden, die nur mit dem Schlüsselwort `fun` eingeleitet werden, gibt es noch einiger weitere Methodentypen.<br />\n**Erweiterungsmethoden** können Klassen weitere objektmethodenähnliche Methoden hinzufügen. Dies findet vor Allem bei bestehenden Klassen, zum Beispiel aus einer Bibliothek, Anwendung. Der Kopf einer Erweiterungsmethode besitzt folgenden Syntax:<br />\n>Erweiterungsmethode -> \"fun \" Datentyp \".\" Name \"(\" Parameter \")\" \n\nObjektmethoden einer Klasse überlagern jedoch immer die Erweiterungsmethoden. In der Methode kann mit dem Schlüsselwort `this` auf das Objekt, auf dem die Methode ausgeführt wird, zugegriffen werden. Aufgerufen werden die Erweiterungsmethoden genauso wie Objektmethoden.<br />\nEine weitere Methodenart sind die sogenannten `infix`-Methoden. Das besondere an ihnen ist, dass anstelle eines Methodenaufrufs ein Schlüsselwort, der Name der Methode, benutzt wird, das auf die Methode verweist. Meist sind dabei zwei Objekte involviert, die durch das Schlüsselwort getrennt werden. Im Hintergrund wird die Methode auf dem ersten Objekt aufgerufen. Das Zweite wird der Methode übergeben. Ein gängiges Beispiel ist die Methode `util()`. Der Aufruf `0 until 10` wird im Hintergrund zu `0.until(10)`. Der Syntax des Kopfes einer `infix`-Methode ist:\n>infix-Methode -> \"infix fun\" Datentyp \".\" Name \"(\" Parameter \")\"\n\nWährend auf den ersten Parameter wieder mit `this` zugegriffen werden kann, muss dem Zweiten ein Name zugewiesen werden.<br />\nDie letzte Art der Methode in dieser Lektion wird leicht mit den `infix`-Methoden verwechselt, sind jedoch von einer anderen Natur. Ein Beispiel für diese Art ist die Addition `+`. In einer Anweisung wird das Symbol wie eine `infix`-Mehthode behandelt, jedoch gibt es keine Methode mit dem Namen `+`. Deswegen wird diese Klasse der Methoden `operator`-Methoden genannt. Sie bilden einen Operator, der in einer `infix`-Form verwendet werden kann, auf vordefinierte Methoden ab. Bei einer Addition wird beispielsweise die Methode `a.plus(b)` aufgerufen, bei `!a` hingegen `a.not()`. Es können keine neuen `operator`-Methoden implemenitert werden, jedoch eigene Klassen mit diesen ausgestattet werden. Der Syntax des Methodenkopf sieht folgendermaßen aus:\n>operator-Methode -> \"operator fun\" Datentyp \".\" Name \"(\" Parameter \")\"\n\n<br /><br />\n\nEin weiteres wichtiges Themenfeld sind Datenstrukturen.<br />\nEine bekannte, aber rudimentäre, Datenstruktur ist das **Array**.  Sie zeichnet sich dadurch aus, dass die Länge des Elementspeichers bei Initialisierung festgesetzt wird. Dies kann entweder implizit geschehen, indem das Array mit Elementen durch `arrayOf()`, oder expilizit, wenn ein leeres Array mit dem Konstruktor `Array(Länge) {Standardwert}` erzeugt wird. Auf das n-te Element eines Arrays `array` kann mit `array[n]` und die Länge mit `array.size` zugegriffen werden. Mehrdimensionale Arrays sind ineinader geschachtelte Arrays.<br />\nDie beliebeste Datenstruktur ist die **Liste**. Diese lässt sich in Kotlin in zwei Arten aufsplitten: `List` beschreibt eine unveränderbare, `MutableList` eine veränderbare Liste. Beide speichern nur Elemente eines Datentyps. Erzeugt könne diese mit dem Schlüsselwort `listOf` oder `mutableListOf`. Des Weiteren ist eine Initialisierung mit dem Konstruktoraufruf möglich (analog zum Array): `List(Länge) {Standardwert}`. Soll eine leere Liste erzeugt werden, muss zusätzlich der Datentyp angegeben werden: `listOf<Datentyp>()` oder `mutableListOf<Datentyp>()`.<br />\nSoll auf ein Element an Index `n` einer Liste zugegriffen werden, kann entweder der bereits bekannte Syntax eines Arrays angewendet werden (`liste[n]`) oder die `get(n)`-Methode benutzt werden. Auf die Länge kann mit `size` zugegriffen werden. Soll eine veränderbare Liste mit einem bestimmten Wert gefüllt werden, findet die Methode `fill()` Anwendung. `clear()` hingegen leert die Liste. Um ein Element zu einer Liste hinzuzufügen, ist die `add`-Methode zu verwenden. Ist nur das Element angegeben, wird es hinten angestellt. Wird zusätzlich ein Index übergeben, wird das Element dort eingefügt. Kotlin bietet zusätzlich zu dem einfachen `add()` mit `+=` eine Kurzschreibweise. Mit `remove()` kann ein übergebenes Element aus der Liste gelöscht werden. Soll jedoch das Element an Index `n` entfernt werden, ist die Methode `removeAt(n)` zu verwenden.<br />\nAuf eine Teilliste kann mit `subList(von, bis)` zugegriffen werden. Soll geprüft werden, ob ein Element in einer Liste vorhanden ist, kann dies mit `in` bewerkstelligt werden. Soll anstelle eines Wahrheitswertes der Index des Elements zurückgegeben werden, liefert diesen `indexOf()`. Ein weitere wichtige Methode ist `random()`. Diese liefert ein zufälliges Element aus einer Liste oder auch einem Bereich.<br />\nEine Vereinfachung der Liste ist das **Set**. Die listenähnliche Datenstruktur verzichtet auf Doppelungen und Ordnung und stellt eine Menge dar. Während ein veränderbares Set von der Klasse `MutableSet` ist und mit `mutableSetOf()` erzeugt werden kann, ist ein unveränderbares Set von der Klasse `Set` und wird mit `setOf()` initialisiert.<br />\nAuf Sets können klassische Mengenoperationen angewendet werden. Eine Vereinignung ist mit `union` oder `+` möglich, `intersect` gibt eine Schnittmenge zurück und `subtract` entfernt alle Elemente der ersten Menge aus der Zweiten.<br />\nEine Liste auf Paaren beschreibt die Datenstruktur **Map**. Bei dieser wird jedem Wert ein Schlüssel zugeordnet, mit dem auf diesen wie beim Array oder der Liste zugegriffen werden kann. Bei der Initialsierung werden diese mit einem `to` getrennt. Während bei einer `Map` die Erzeugung mit `mapOf()` stattfindet und keine Änderungen vorgenommen werden können, initialisiert `mutableMapOf()` eine veränderbare Map der Klasse `MutableMap`. Ein Paar kann einer `MutableMap` mit `put()` hinzugefügt und mit `remove()` gelöscht werden."
    },
    {
     "start_checkpoint": 1618239409109,
     "parent": "n.0.99",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\n>Variable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben. Wenn ein Anweisungsblock ausgeführt wurde, wird der `when`-Block verlassen und nicht weiter ausgeführt.<br />\nDie `for`-Schleife iteriert über Bereiche. Diese werden durch einen Start- und Endpunkt definiert getrennt von `..`. Die von Kotlin bereitgestellten Bereiche sind von den Typen `Int`, `Long` und `Char`. Soll ein Bereich absteigend sein, muss statt `..` `downTo` verwendet werden. Bei einem Bereich mit dem Schlüsselwort `until` ist der Endwert explizit. Nach dem Endwert kann noch ein `step` mit anschließender Schrittweite angegeben werden.<br />\nDie normale Iteration über einen Bereich wird mit dem Schlüsselwort `in` herbeigeführt. Ebenso kann aber mit diesem auch über eine Datenstruktur (zum Beispiel eine Liste) iteriert werden. In diesem Fall wird in der Laufvariable das Element der Liste gespeichert. Dieses kann nicht verändert werden. Hängt man der Liste `withIndex()` an, so wird ein Paar aus Index und Element bei jedem Durchlauf belegt.<br />\nSoll eine bestimmte Schleife beendet werden, kann dies mit dem Schlüsselwort `break` passieren. Diesem wird getrennt mit einem `@` der Name der Schleife angegeben. Zuvor muss dieser Name dieser aber zugewiesen werden. Dies erfolgt mit name`@` vor dem Schleifenkopf.<br />\nEine weitere Schleife ist die `while`-Schleife. Diese ist identisch zu der Umsetzung in Java. Außerdem wird ebenfalls die `do-while`-Schleife unterstützt.<br />\nFür einfache Zwecke ist die `repeat`-Schleife vorteilhaft. Dieser wird als Parameter ein positiver `Int`-Wert übergeben, bis zu dem von 0 aus iteriert wird. In der Schleife kann auf die aktuelle Durchlaufzahl mit `it` zugegriffen werden.<br /><br />\nAbgesehen von den normalen, statischen Top-Level-Methoden, die nur mit dem Schlüsselwort `fun` eingeleitet werden, gibt es noch einiger weitere Methodentypen.<br />\n**Erweiterungsmethoden** können Klassen weitere objektmethodenähnliche Methoden hinzufügen. Dies findet vor Allem bei bestehenden Klassen, zum Beispiel aus einer Bibliothek, Anwendung. Der Kopf einer Erweiterungsmethode besitzt folgenden Syntax:<br />\n>Erweiterungsmethode -> \"fun \" Datentyp \".\" Name \"(\" Parameter \")\" \n\nObjektmethoden einer Klasse überlagern jedoch immer die Erweiterungsmethoden. In der Methode kann mit dem Schlüsselwort `this` auf das Objekt, auf dem die Methode ausgeführt wird, zugegriffen werden. Aufgerufen werden die Erweiterungsmethoden genauso wie Objektmethoden.<br />\nEine weitere Methodenart sind die sogenannten `infix`-Methoden. Das besondere an ihnen ist, dass anstelle eines Methodenaufrufs ein Schlüsselwort, der Name der Methode, benutzt wird, das auf die Methode verweist. Meist sind dabei zwei Objekte involviert, die durch das Schlüsselwort getrennt werden. Im Hintergrund wird die Methode auf dem ersten Objekt aufgerufen. Das Zweite wird der Methode übergeben. Ein gängiges Beispiel ist die Methode `util()`. Der Aufruf `0 until 10` wird im Hintergrund zu `0.until(10)`. Der Syntax des Kopfes einer `infix`-Methode ist:\n>infix-Methode -> \"infix fun\" Datentyp \".\" Name \"(\" Parameter \")\"\n\nWährend auf den ersten Parameter wieder mit `this` zugegriffen werden kann, muss dem Zweiten ein Name zugewiesen werden.<br />\nDie letzte Art der Methode in dieser Lektion wird leicht mit den `infix`-Methoden verwechselt, sind jedoch von einer anderen Natur. Ein Beispiel für diese Art ist die Addition `+`. In einer Anweisung wird das Symbol wie eine `infix`-Mehthode behandelt, jedoch gibt es keine Methode mit dem Namen `+`. Deswegen wird diese Klasse der Methoden `operator`-Methoden genannt. Sie bilden einen Operator, der in einer `infix`-Form verwendet werden kann, auf vordefinierte Methoden ab. Bei einer Addition wird beispielsweise die Methode `a.plus(b)` aufgerufen, bei `!a` hingegen `a.not()`. Es können keine neuen `operator`-Methoden implemenitert werden, jedoch eigene Klassen mit diesen ausgestattet werden. Der Syntax des Methodenkopf sieht folgendermaßen aus:\n>operator-Methode -> \"operator fun\" Datentyp \".\" Name \"(\" Parameter \")\"\n\n<br />\nEin weiteres wichtiges Themenfeld sind Datenstrukturen.<br />\nEine bekannte, aber rudimentäre, Datenstruktur ist das **Array**.  Sie zeichnet sich dadurch aus, dass die Länge des Elementspeichers bei Initialisierung festgesetzt wird. Dies kann entweder implizit geschehen, indem das Array mit Elementen durch `arrayOf()`, oder expilizit, wenn ein leeres Array mit dem Konstruktor `Array(Länge) {Standardwert}` erzeugt wird. Auf das n-te Element eines Arrays `array` kann mit `array[n]` und die Länge mit `array.size` zugegriffen werden. Mehrdimensionale Arrays sind ineinader geschachtelte Arrays.<br />\nDie beliebeste Datenstruktur ist die **Liste**. Diese lässt sich in Kotlin in zwei Arten aufsplitten: `List` beschreibt eine unveränderbare, `MutableList` eine veränderbare Liste. Beide speichern nur Elemente eines Datentyps. Erzeugt könne diese mit dem Schlüsselwort `listOf` oder `mutableListOf`. Des Weiteren ist eine Initialisierung mit dem Konstruktoraufruf möglich (analog zum Array): `List(Länge) {Standardwert}`. Soll eine leere Liste erzeugt werden, muss zusätzlich der Datentyp angegeben werden: `listOf<Datentyp>()` oder `mutableListOf<Datentyp>()`.<br />\nSoll auf ein Element an Index `n` einer Liste zugegriffen werden, kann entweder der bereits bekannte Syntax eines Arrays angewendet werden (`liste[n]`) oder die `get(n)`-Methode benutzt werden. Auf die Länge kann mit `size` zugegriffen werden. Soll eine veränderbare Liste mit einem bestimmten Wert gefüllt werden, findet die Methode `fill()` Anwendung. `clear()` hingegen leert die Liste. Um ein Element zu einer Liste hinzuzufügen, ist die `add`-Methode zu verwenden. Ist nur das Element angegeben, wird es hinten angestellt. Wird zusätzlich ein Index übergeben, wird das Element dort eingefügt. Kotlin bietet zusätzlich zu dem einfachen `add()` mit `+=` eine Kurzschreibweise. Mit `remove()` kann ein übergebenes Element aus der Liste gelöscht werden. Soll jedoch das Element an Index `n` entfernt werden, ist die Methode `removeAt(n)` zu verwenden.<br />\nAuf eine Teilliste kann mit `subList(von, bis)` zugegriffen werden. Soll geprüft werden, ob ein Element in einer Liste vorhanden ist, kann dies mit `in` bewerkstelligt werden. Soll anstelle eines Wahrheitswertes der Index des Elements zurückgegeben werden, liefert diesen `indexOf()`. Ein weitere wichtige Methode ist `random()`. Diese liefert ein zufälliges Element aus einer Liste oder auch einem Bereich.<br />\nEine Vereinfachung der Liste ist das **Set**. Die listenähnliche Datenstruktur verzichtet auf Doppelungen und Ordnung und stellt eine Menge dar. Während ein veränderbares Set von der Klasse `MutableSet` ist und mit `mutableSetOf()` erzeugt werden kann, ist ein unveränderbares Set von der Klasse `Set` und wird mit `setOf()` initialisiert.<br />\nAuf Sets können klassische Mengenoperationen angewendet werden. Eine Vereinignung ist mit `union` oder `+` möglich, `intersect` gibt eine Schnittmenge zurück und `subtract` entfernt alle Elemente der ersten Menge aus der Zweiten.<br />\nEine Liste auf Paaren beschreibt die Datenstruktur **Map**. Bei dieser wird jedem Wert ein Schlüssel zugeordnet, mit dem auf diesen wie beim Array oder der Liste zugegriffen werden kann. Bei der Initialsierung werden diese mit einem `to` getrennt. Während bei einer `Map` die Erzeugung mit `mapOf()` stattfindet und keine Änderungen vorgenommen werden können, initialisiert `mutableMapOf()` eine veränderbare Map der Klasse `MutableMap`. Ein Paar kann einer `MutableMap` mit `put()` hinzugefügt und mit `remove()` gelöscht werden."
    },
    {
     "start_checkpoint": 1618239457092,
     "parent": "n.0.100",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\n>Variable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben. Wenn ein Anweisungsblock ausgeführt wurde, wird der `when`-Block verlassen und nicht weiter ausgeführt.<br />\nDie `for`-Schleife iteriert über Bereiche. Diese werden durch einen Start- und Endpunkt definiert getrennt von `..`. Die von Kotlin bereitgestellten Bereiche sind von den Typen `Int`, `Long` und `Char`. Soll ein Bereich absteigend sein, muss statt `..` `downTo` verwendet werden. Bei einem Bereich mit dem Schlüsselwort `until` ist der Endwert explizit. Nach dem Endwert kann noch ein `step` mit anschließender Schrittweite angegeben werden.<br />\nDie normale Iteration über einen Bereich wird mit dem Schlüsselwort `in` herbeigeführt. Ebenso kann aber mit diesem auch über eine Datenstruktur (zum Beispiel eine Liste) iteriert werden. In diesem Fall wird in der Laufvariable das Element der Liste gespeichert. Dieses kann nicht verändert werden. Hängt man der Liste `withIndex()` an, so wird ein Paar aus Index und Element bei jedem Durchlauf belegt.<br />\nSoll eine bestimmte Schleife beendet werden, kann dies mit dem Schlüsselwort `break` passieren. Diesem wird getrennt mit einem `@` der Name der Schleife angegeben. Zuvor muss dieser Name dieser aber zugewiesen werden. Dies erfolgt mit name`@` vor dem Schleifenkopf.<br />\nEine weitere Schleife ist die `while`-Schleife. Diese ist identisch zu der Umsetzung in Java. Außerdem wird ebenfalls die `do-while`-Schleife unterstützt.<br />\nFür einfache Zwecke ist die `repeat`-Schleife vorteilhaft. Dieser wird als Parameter ein positiver `Int`-Wert übergeben, bis zu dem von 0 aus iteriert wird. In der Schleife kann auf die aktuelle Durchlaufzahl mit `it` zugegriffen werden.<br /><br />\nAbgesehen von den normalen, statischen Top-Level-Methoden, die nur mit dem Schlüsselwort `fun` eingeleitet werden, gibt es noch einiger weitere Methodentypen.<br />\n**Erweiterungsmethoden** können Klassen weitere objektmethodenähnliche Methoden hinzufügen. Dies findet vor Allem bei bestehenden Klassen, zum Beispiel aus einer Bibliothek, Anwendung. Der Kopf einer Erweiterungsmethode besitzt folgenden Syntax:<br />\n>Erweiterungsmethode -> \"fun \" Datentyp \".\" Name \"(\" Parameter \")\" \n\nObjektmethoden einer Klasse überlagern jedoch immer die Erweiterungsmethoden. In der Methode kann mit dem Schlüsselwort `this` auf das Objekt, auf dem die Methode ausgeführt wird, zugegriffen werden. Aufgerufen werden die Erweiterungsmethoden genauso wie Objektmethoden.<br />\nEine weitere Methodenart sind die sogenannten **`infix`-Methoden**. Das besondere an ihnen ist, dass anstelle eines Methodenaufrufs ein Schlüsselwort, der Name der Methode, benutzt wird, das auf die Methode verweist. Meist sind dabei zwei Objekte involviert, die durch das Schlüsselwort getrennt werden. Im Hintergrund wird die Methode auf dem ersten Objekt aufgerufen. Das Zweite wird der Methode übergeben. Ein gängiges Beispiel ist die Methode `util()`. Der Aufruf `0 until 10` wird im Hintergrund zu `0.until(10)`. Der Syntax des Kopfes einer `infix`-Methode ist:\n>infix-Methode -> \"infix fun\" Datentyp \".\" Name \"(\" Parameter \")\"\n\nWährend auf den ersten Parameter wieder mit `this` zugegriffen werden kann, muss dem Zweiten ein Name zugewiesen werden.<br />\nDie letzte Art der Methode in dieser Lektion wird leicht mit den `infix`-Methoden verwechselt, sind jedoch von einer anderen Natur. Ein Beispiel für diese Art ist die Addition `+`. In einer Anweisung wird das Symbol wie eine `infix`-Mehthode behandelt, jedoch gibt es keine Methode mit dem Namen `+`. Deswegen wird diese Klasse der Methoden **`operator`-Methoden** genannt. Sie bilden einen Operator, der in einer `infix`-Form verwendet werden kann, auf vordefinierte Methoden ab. Bei einer Addition wird beispielsweise die Methode `a.plus(b)` aufgerufen, bei `!a` hingegen `a.not()`. Es können keine neuen `operator`-Methoden implemenitert werden, jedoch eigene Klassen mit diesen ausgestattet werden. Der Syntax des Methodenkopf sieht folgendermaßen aus:\n>operator-Methode -> \"operator fun\" Datentyp \".\" Name \"(\" Parameter \")\"\n\nEin weiteres wichtiges Themenfeld sind Datenstrukturen.<br />\nEine bekannte, aber rudimentäre, Datenstruktur ist das **Array**.  Sie zeichnet sich dadurch aus, dass die Länge des Elementspeichers bei Initialisierung festgesetzt wird. Dies kann entweder implizit geschehen, indem das Array mit Elementen durch `arrayOf()`, oder expilizit, wenn ein leeres Array mit dem Konstruktor `Array(Länge) {Standardwert}` erzeugt wird. Auf das n-te Element eines Arrays `array` kann mit `array[n]` und die Länge mit `array.size` zugegriffen werden. Mehrdimensionale Arrays sind ineinader geschachtelte Arrays.<br />\nDie beliebeste Datenstruktur ist die **Liste**. Diese lässt sich in Kotlin in zwei Arten aufsplitten: `List` beschreibt eine unveränderbare, `MutableList` eine veränderbare Liste. Beide speichern nur Elemente eines Datentyps. Erzeugt könne diese mit dem Schlüsselwort `listOf` oder `mutableListOf`. Des Weiteren ist eine Initialisierung mit dem Konstruktoraufruf möglich (analog zum Array): `List(Länge) {Standardwert}`. Soll eine leere Liste erzeugt werden, muss zusätzlich der Datentyp angegeben werden: `listOf<Datentyp>()` oder `mutableListOf<Datentyp>()`.<br />\nSoll auf ein Element an Index `n` einer Liste zugegriffen werden, kann entweder der bereits bekannte Syntax eines Arrays angewendet werden (`liste[n]`) oder die `get(n)`-Methode benutzt werden. Auf die Länge kann mit `size` zugegriffen werden. Soll eine veränderbare Liste mit einem bestimmten Wert gefüllt werden, findet die Methode `fill()` Anwendung. `clear()` hingegen leert die Liste. Um ein Element zu einer Liste hinzuzufügen, ist die `add`-Methode zu verwenden. Ist nur das Element angegeben, wird es hinten angestellt. Wird zusätzlich ein Index übergeben, wird das Element dort eingefügt. Kotlin bietet zusätzlich zu dem einfachen `add()` mit `+=` eine Kurzschreibweise. Mit `remove()` kann ein übergebenes Element aus der Liste gelöscht werden. Soll jedoch das Element an Index `n` entfernt werden, ist die Methode `removeAt(n)` zu verwenden.<br />\nAuf eine Teilliste kann mit `subList(von, bis)` zugegriffen werden. Soll geprüft werden, ob ein Element in einer Liste vorhanden ist, kann dies mit `in` bewerkstelligt werden. Soll anstelle eines Wahrheitswertes der Index des Elements zurückgegeben werden, liefert diesen `indexOf()`. Ein weitere wichtige Methode ist `random()`. Diese liefert ein zufälliges Element aus einer Liste oder auch einem Bereich.<br />\nEine Vereinfachung der Liste ist das **Set**. Die listenähnliche Datenstruktur verzichtet auf Doppelungen und Ordnung und stellt eine Menge dar. Während ein veränderbares Set von der Klasse `MutableSet` ist und mit `mutableSetOf()` erzeugt werden kann, ist ein unveränderbares Set von der Klasse `Set` und wird mit `setOf()` initialisiert.<br />\nAuf Sets können klassische Mengenoperationen angewendet werden. Eine Vereinignung ist mit `union` oder `+` möglich, `intersect` gibt eine Schnittmenge zurück und `subtract` entfernt alle Elemente der ersten Menge aus der Zweiten.<br />\nEine Liste auf Paaren beschreibt die Datenstruktur **Map**. Bei dieser wird jedem Wert ein Schlüssel zugeordnet, mit dem auf diesen wie beim Array oder der Liste zugegriffen werden kann. Bei der Initialsierung werden diese mit einem `to` getrennt. Während bei einer `Map` die Erzeugung mit `mapOf()` stattfindet und keine Änderungen vorgenommen werden können, initialisiert `mutableMapOf()` eine veränderbare Map der Klasse `MutableMap`. Ein Paar kann einer `MutableMap` mit `put()` hinzugefügt und mit `remove()` gelöscht werden."
    },
    {
     "start_checkpoint": 1618239470410,
     "parent": "n.0.102",
     "markdown": "## Zusammenfassung\nIn diesem Abschnitt wurden die Grundlagen von Kotlin vorgestellt. Dabei wurde Bezug auf ihre Umsetzung in Java genommen.<br/><br />\nDie `main`-Methode wird standardmäßig beim Ausfüühren eines Programms aufgerufen und kann mit (`fun main(args: Array) { ... }`) oder ohne (`fun main() { ... }`) Kommandizeilenargumente aufgerufen werden.<br />\nEine Variable oder ein Ausdruck kann mit `$` beziehungsweise `${ ... }` in einen `String` eingebaut werden.<br /><br />\nVariablen werden in Kotlin in zwei Arten unterteilt. `val` beschreibt eine schreibgeschützte Variable, während eine `var`-Variable beliebig oft verändert werden kann. Der Datentyp kann mit `:` getrennt nach dem Variablennamen angegeben werden, kann aber bei einer direkten Wertzuweisung weggelassen werden. Dann wird implizit vom Kompiler ein Datentyp zugewiesen. Aktuell kann kein bekannter Datentyp den Wert `null` annehmen. Eine Konstante besitzt den Typ `val` und wird `const`  vorangestellt. Syntax von Variablen:<br />\n>Variable -> \"var\" name \":\" Datentyp.<br />\nVariable -> [const] (\"var\"|\"val\") name [\":\" Datentyp] \"=\" Wert.<br />\n\nKotlin unterscheidet nicht zwischen primitiven und komplexen (Klassen) Datentypen. Alle Datentypen besitzen eine Klasse und werden somit groß geschrieben. Zusätzlich zu den bereits bekannten Datentypen aus Java kommen `Any`, `Nothing` und `Unit` dazu. `Any` beschreibt den Super-Typ, während `Nothing` der Sub-Typ aller Datentypen ist. `Unit` kommt bei Methoden zum Einsatz, die in Java den Rückgabetyp `void` besitzen. Er gibt an, dass nichts interessantes zurückgegeben wird.<br />\nVergleiche finden standardmäßig auf der Inhaltsebene statt. Mit `===` kann ein Vergleich auf der Referenzebene angestellt werden.<br /><br />\nMethoden besitzen in Kotlin folgenden Syntax:<br />\nFunktion -> \"fun\" name \"(\" Parameter \")\" [\":\" Rückgabetyp] \"{\" ... \"}\"<br />\nParameter -> Name \":\" Datentyp [\"=\" defaukt-Wert] {\",\" Parameter}<br />\nParametern kann ein default-Wert zugewiesen werden, der Anwendung findet, wenn dieser Parameter nicht ünergeben wird. Ansonsten wird der default-Wert des Datentyps angewendet. Parameter können außerdem mit ihrem Namen übergeben werden.<br />\nFalls ein Rückgabetyp vorhanden ist, muss ein Element dieses Typs zurückgegeben werden. Das Zurückgeben mehrerer Elemente ist nicht möglich. Falls nichts zurückgegeben werden soll, wird `Unit` als Rückgabetyp angegeben oder dieser komplett weggelassen. Terminiert die Methode nie oder wirft immer einen Fehler ist `Nothing` als Rückgabetyp zu präferieren.<br />\nFalls die Methode kurz ist, kann die Kurzschreibweise angewendet werden. Dabei wird der Rückgabetyp implizit vom Kompiler bestimmt.<br /><br />\nDie Kontrollstrukturen in Kotlin ähneln den in Java. <br />\nWird bei einer `if`-Verzweigung in allen Fällen ein Wert zurückgegeben, kann das `return` vor das `if` geschrieben und in den Fällen weggelassen werden.<br />\nDie `when`-Verzweigung ist ähnlich zu `switch-case` in Java und ist bei Verzweigungen mit mehr als zwei Fällen zu bevorzugen. Es wird im vergleich zu `switch` das Schlüsselwort im Kopf mit `when` ausgetauscht. Jeder Fall wird in eine rechte und eine linke Seite aufgeteilt. Während links ein Vergleichswert oder ein Wahrheitsausdruck zu finden ist, wird rechts die Folge in Form einer Anweisung hingeschrieben. Wenn ein Anweisungsblock ausgeführt wurde, wird der `when`-Block verlassen und nicht weiter ausgeführt.<br />\nDie `for`-Schleife iteriert über Bereiche. Diese werden durch einen Start- und Endpunkt definiert getrennt von `..`. Die von Kotlin bereitgestellten Bereiche sind von den Typen `Int`, `Long` und `Char`. Soll ein Bereich absteigend sein, muss statt `..` `downTo` verwendet werden. Bei einem Bereich mit dem Schlüsselwort `until` ist der Endwert explizit. Nach dem Endwert kann noch ein `step` mit anschließender Schrittweite angegeben werden.<br />\nDie normale Iteration über einen Bereich wird mit dem Schlüsselwort `in` herbeigeführt. Ebenso kann aber mit diesem auch über eine Datenstruktur (zum Beispiel eine Liste) iteriert werden. In diesem Fall wird in der Laufvariable das Element der Liste gespeichert. Dieses kann nicht verändert werden. Hängt man der Liste `withIndex()` an, so wird ein Paar aus Index und Element bei jedem Durchlauf belegt.<br />\nSoll eine bestimmte Schleife beendet werden, kann dies mit dem Schlüsselwort `break` passieren. Diesem wird getrennt mit einem `@` der Name der Schleife angegeben. Zuvor muss dieser Name dieser aber zugewiesen werden. Dies erfolgt mit name`@` vor dem Schleifenkopf.<br />\nEine weitere Schleife ist die `while`-Schleife. Diese ist identisch zu der Umsetzung in Java. Außerdem wird ebenfalls die `do-while`-Schleife unterstützt.<br />\nFür einfache Zwecke ist die `repeat`-Schleife vorteilhaft. Dieser wird als Parameter ein positiver `Int`-Wert übergeben, bis zu dem von 0 aus iteriert wird. In der Schleife kann auf die aktuelle Durchlaufzahl mit `it` zugegriffen werden.<br /><br />\nAbgesehen von den normalen, statischen Top-Level-Methoden, die nur mit dem Schlüsselwort `fun` eingeleitet werden, gibt es noch einiger weitere Methodentypen.<br />\n**Erweiterungsmethoden** können Klassen weitere objektmethodenähnliche Methoden hinzufügen. Dies findet vor Allem bei bestehenden Klassen, zum Beispiel aus einer Bibliothek, Anwendung. Der Kopf einer Erweiterungsmethode besitzt folgenden Syntax:<br />\n>Erweiterungsmethode -> \"fun \" Datentyp \".\" Name \"(\" Parameter \")\" \n\nObjektmethoden einer Klasse überlagern jedoch immer die Erweiterungsmethoden. In der Methode kann mit dem Schlüsselwort `this` auf das Objekt, auf dem die Methode ausgeführt wird, zugegriffen werden. Aufgerufen werden die Erweiterungsmethoden genauso wie Objektmethoden.<br />\nEine weitere Methodenart sind die sogenannten **`infix`-Methoden**. Das besondere an ihnen ist, dass anstelle eines Methodenaufrufs ein Schlüsselwort, der Name der Methode, benutzt wird, das auf die Methode verweist. Meist sind dabei zwei Objekte involviert, die durch das Schlüsselwort getrennt werden. Im Hintergrund wird die Methode auf dem ersten Objekt aufgerufen. Das Zweite wird der Methode übergeben. Ein gängiges Beispiel ist die Methode `util()`. Der Aufruf `0 until 10` wird im Hintergrund zu `0.until(10)`. Der Syntax des Kopfes einer `infix`-Methode ist:\n>infix-Methode -> \"infix fun\" Datentyp \".\" Name \"(\" Parameter \")\"\n\nWährend auf den ersten Parameter wieder mit `this` zugegriffen werden kann, muss dem Zweiten ein Name zugewiesen werden.<br />\nDie letzte Art der Methode in dieser Lektion wird leicht mit den `infix`-Methoden verwechselt, sind jedoch von einer anderen Natur. Ein Beispiel für diese Art ist die Addition `+`. In einer Anweisung wird das Symbol wie eine `infix`-Mehthode behandelt, jedoch gibt es keine Methode mit dem Namen `+`. Deswegen wird diese Klasse der Methoden **`operator`-Methoden** genannt. Sie bilden einen Operator, der in einer `infix`-Form verwendet werden kann, auf vordefinierte Methoden ab. Bei einer Addition wird beispielsweise die Methode `a.plus(b)` aufgerufen, bei `!a` hingegen `a.not()`. Es können keine neuen `operator`-Methoden implemenitert werden, jedoch eigene Klassen mit diesen ausgestattet werden. Der Syntax des Methodenkopf sieht folgendermaßen aus:\n>operator-Methode -> \"operator fun\" Datentyp \".\" Name \"(\" Parameter \")\"\n\n<br />Ein weiteres wichtiges Themenfeld sind Datenstrukturen.<br />\nEine bekannte, aber rudimentäre, Datenstruktur ist das **Array**.  Sie zeichnet sich dadurch aus, dass die Länge des Elementspeichers bei Initialisierung festgesetzt wird. Dies kann entweder implizit geschehen, indem das Array mit Elementen durch `arrayOf()`, oder expilizit, wenn ein leeres Array mit dem Konstruktor `Array(Länge) {Standardwert}` erzeugt wird. Auf das n-te Element eines Arrays `array` kann mit `array[n]` und die Länge mit `array.size` zugegriffen werden. Mehrdimensionale Arrays sind ineinader geschachtelte Arrays.<br />\nDie beliebeste Datenstruktur ist die **Liste**. Diese lässt sich in Kotlin in zwei Arten aufsplitten: `List` beschreibt eine unveränderbare, `MutableList` eine veränderbare Liste. Beide speichern nur Elemente eines Datentyps. Erzeugt könne diese mit dem Schlüsselwort `listOf` oder `mutableListOf`. Des Weiteren ist eine Initialisierung mit dem Konstruktoraufruf möglich (analog zum Array): `List(Länge) {Standardwert}`. Soll eine leere Liste erzeugt werden, muss zusätzlich der Datentyp angegeben werden: `listOf<Datentyp>()` oder `mutableListOf<Datentyp>()`.<br />\nSoll auf ein Element an Index `n` einer Liste zugegriffen werden, kann entweder der bereits bekannte Syntax eines Arrays angewendet werden (`liste[n]`) oder die `get(n)`-Methode benutzt werden. Auf die Länge kann mit `size` zugegriffen werden. Soll eine veränderbare Liste mit einem bestimmten Wert gefüllt werden, findet die Methode `fill()` Anwendung. `clear()` hingegen leert die Liste. Um ein Element zu einer Liste hinzuzufügen, ist die `add`-Methode zu verwenden. Ist nur das Element angegeben, wird es hinten angestellt. Wird zusätzlich ein Index übergeben, wird das Element dort eingefügt. Kotlin bietet zusätzlich zu dem einfachen `add()` mit `+=` eine Kurzschreibweise. Mit `remove()` kann ein übergebenes Element aus der Liste gelöscht werden. Soll jedoch das Element an Index `n` entfernt werden, ist die Methode `removeAt(n)` zu verwenden.<br />\nAuf eine Teilliste kann mit `subList(von, bis)` zugegriffen werden. Soll geprüft werden, ob ein Element in einer Liste vorhanden ist, kann dies mit `in` bewerkstelligt werden. Soll anstelle eines Wahrheitswertes der Index des Elements zurückgegeben werden, liefert diesen `indexOf()`. Ein weitere wichtige Methode ist `random()`. Diese liefert ein zufälliges Element aus einer Liste oder auch einem Bereich.<br />\nEine Vereinfachung der Liste ist das **Set**. Die listenähnliche Datenstruktur verzichtet auf Doppelungen und Ordnung und stellt eine Menge dar. Während ein veränderbares Set von der Klasse `MutableSet` ist und mit `mutableSetOf()` erzeugt werden kann, ist ein unveränderbares Set von der Klasse `Set` und wird mit `setOf()` initialisiert.<br />\nAuf Sets können klassische Mengenoperationen angewendet werden. Eine Vereinignung ist mit `union` oder `+` möglich, `intersect` gibt eine Schnittmenge zurück und `subtract` entfernt alle Elemente der ersten Menge aus der Zweiten.<br />\nEine Liste auf Paaren beschreibt die Datenstruktur **Map**. Bei dieser wird jedem Wert ein Schlüssel zugeordnet, mit dem auf diesen wie beim Array oder der Liste zugegriffen werden kann. Bei der Initialsierung werden diese mit einem `to` getrennt. Während bei einer `Map` die Erzeugung mit `mapOf()` stattfindet und keine Änderungen vorgenommen werden können, initialisiert `mutableMapOf()` eine veränderbare Map der Klasse `MutableMap`. Ein Paar kann einer `MutableMap` mit `put()` hinzugefügt und mit `remove()` gelöscht werden."
    }
   ]
  },
  {
   "artifact_name": "m.196",
   "versions": [
    {
     "start_checkpoint": 1617617991364,
     "parent": "n.0.102",
     "markdown": "### Typumwandlung\nDatentypen können mit dem Schlüsselwort `as` umgewandelt werden. Dabei ist zu beachten, dass der Wert der Variable bereits für den neuen Datentyp gültig sein muss. Deswegen ist eine vorherige Prüfung mit `is` (in Java `instanceof`) empfohlen. Eine Umwandlung von `Int` zu `Float` ist somit nicht möglich. In diesem Fall würde die Methode `toFloat()` Anwendung finden. Umwandlungen in andere Datentypen erfolgen analog."
    }
   ]
  },
  {
   "artifact_name": "m.197",
   "versions": [
    {
     "start_checkpoint": 1617617991364,
     "parent": "n.0.102",
     "markdown": "Die Typumwandlung mit `as` kann aber auch noch vereinfacht werden. Da nach einer wahren `is`-Prüfung klar ist, dass die Variable diesen Typ besitzt, wandelt der Kompiler diese in den Typ \"smart\" um."
    }
   ]
  },
  {
   "artifact_name": "m.198",
   "versions": [
    {
     "start_checkpoint": 1618320018172,
     "parent": "n.0.102",
     "markdown": "### Paar TODO"
    }
   ]
  },
  {
   "artifact_name": "m.199",
   "versions": [
    {
     "start_checkpoint": 1618320018172,
     "parent": "n.0.102",
     "markdown": "#### Aufgabe TODO\nIn dieser Aufgabe sollen verschiedenen \"Mandalas\" gezeichnet werden.\n"
    }
   ]
  }
 ],
 "rawCells": [],
 "snippets": [],
 "output": [
  {
   "artifact_name": "o.0",
   "versions": [
    {
     "start_checkpoint": 1616498720192,
     "parent": "c.2.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Hello World\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.1",
   "versions": [
    {
     "start_checkpoint": 1616499917417,
     "parent": "c.11.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Hello World Kotlin\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.2",
   "versions": [
    {
     "start_checkpoint": 1616499976555,
     "parent": "c.13.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Hello World Kotlin\n",
       "output_type": "stream"
      }
     ]
    },
    {
     "start_checkpoint": 1616499993393,
     "parent": "c.13.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Hello World Erik\n",
       "output_type": "stream"
      }
     ]
    },
    {
     "start_checkpoint": 1616500415041,
     "parent": "c.13.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Hello World Kotlin\n",
       "output_type": "stream"
      }
     ]
    },
    {
     "start_checkpoint": 1616585226477,
     "parent": "c.13.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Hello World Kotlin.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.3",
   "versions": [
    {
     "start_checkpoint": 1616506614841,
     "parent": "c.26.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Hello World Max.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.4",
   "versions": [
    {
     "start_checkpoint": 1616507159625,
     "parent": "c.27.2",
     "raw": [
      {
       "name": "stdout",
       "text": "schreibgeschützte Variable - Test\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.5",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "c.36.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "schreibgeschützte Variable - Test\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.6",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "c.37.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_35.jupyter.kts (5:1 - 6) Const 'val' are only allowed on top level or in objects"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.7",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "c.38.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Datentyp von v1: Int, Datentyp von v2: Int\nDatentyp von string1: String, Datentyp von string2: String\n"
      }
     ]
    },
    {
     "start_checkpoint": 1616585226477,
     "parent": "c.38.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Datentyp von v1: String, Datentyp von v2: String\nDatentyp von string1: String, Datentyp von string2: String\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.8",
   "versions": [
    {
     "start_checkpoint": 1616585203580,
     "parent": "c.39.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_44.jupyter.kts (2:1 - 4) Captured member values initialization is forbidden due to possible reassignment"
      }
     ]
    },
    {
     "start_checkpoint": 1616585226477,
     "parent": "c.39.0",
     "raw": []
    }
   ]
  },
  {
   "artifact_name": "o.9",
   "versions": [
    {
     "start_checkpoint": 1616586254771,
     "parent": "c.46.1",
     "raw": [
      {
       "name": "stdout",
       "text": "a - b ist: 30 .\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.10",
   "versions": [
    {
     "start_checkpoint": 1616586320819,
     "parent": "c.46.2",
     "raw": [
      {
       "name": "stdout",
       "text": "a - b ist: 30.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.11",
   "versions": [
    {
     "start_checkpoint": 1616586339268,
     "parent": "c.46.3",
     "raw": [
      {
       "name": "stdout",
       "text": "a - b ist: 60.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.12",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.48.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "vergleicheElemente: Gleich\nvergleicheSpeicher: Ungleich\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.13",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.49.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "vergleicheStrings: Kotlin > Java\nvergleicheStrings: Java < Kotlin\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.14",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.50.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "TEST\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.15",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.51.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "a: 1, b: 2, c: 1, d: 2\na: 1, b: 2, c: 0, d: 0\na: 0, b: 0, c: 0, d: 0\na: 0, b: 2, c: 0, d: 2\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.16",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.52.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "10\n42\n0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.17",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.53.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Sum mit 2 Int-Parametern: 5\nSum mit 3 Int-Parametern: 9\nSum mit 2 Double-Parametern: 5.0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.18",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.54.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "gleich 10\ngleich 10\ngleich 10\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.19",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.55.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Umlaut\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.20",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.56.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 ist in Liste [0, 1, 2, 3]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.21",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.57.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "gleich 10\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.22",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.58.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Der Bereich 0..10 vom Typ IntRange geht von 0 bis 10 und umfasst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nDer Bereich 5..10 vom Typ IntRange geht von 5 bis 10 und umfasst [5, 6, 7, 8, 9, 10]\nDer Bereich a..e vom Typ CharRange geht von a bis e und umfasst [a, b, c, d, e]\nDer Bereich 0..9 vom Typ IntRange geht von 0 bis 9 und umfasst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nDer Bereich 10 downTo 0 step 1 vom Typ IntProgression geht von 10 bis 0 und umfasst [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\nDer Bereich 0..10 step 2 vom Typ IntProgression geht von 0 bis 10 und umfasst [0, 2, 4, 6, 8, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.23",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.59.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 1 2 3 4 5 6 7 8 9 10 \n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \n15 10 5 "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.24",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.60.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Kotlin Java C Python "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.25",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.61.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_92.jupyter.kts (3:5 - 6) Val cannot be reassigned"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.26",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.62.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "[1, 4, 9, 16, 25]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.27",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.63.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "An Stelle 0 ist 1 gespeichert\nAn Stelle 1 ist 2 gespeichert\nAn Stelle 2 ist 3 gespeichert\nAn Stelle 3 ist 4 gespeichert\nAn Stelle 4 ist 5 gespeichert\n[1, 4, 9, 16, 25]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.28",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.64.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Aktuell untersucht: 0\nAktuell untersucht: 11\nAktuell untersucht: 22\nAktuell untersucht: 33\nAktuell untersucht: 44\nAktuell untersucht: 55\nGefunden 55\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.29",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.65.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 1 2 3 4 5 6 7 8 9 10 11 10 9 8 7 6 5 4 3 2 1 0 "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.30",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.66.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 1 2 3 4 5 6 7 8 9 "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.31",
   "versions": [
    {
     "start_checkpoint": 1616763894011,
     "parent": "c.67.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "groeßer 10\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.32",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.74.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Hello World MAX.toLowerCase().\nHello World max.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.33",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.75.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Die Zehnerstelle von der Zahl 34291 lautet 9\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.34",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.76.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_27.jupyter.kts (5:10 - 20) Unresolved reference: addNewLine\nLine_27.jupyter.kts (6:30 - 40) Unresolved reference: addNewLine\nLine_27.jupyter.kts (6:51 - 61) Unresolved reference: addNewLine\nLine_27.jupyter.kts (8:29 - 39) Unresolved reference: addNewLine\nLine_27.jupyter.kts (8:50 - 60) Unresolved reference: addNewLine"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.35",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.77.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig:\nErweiterungsmethoden erweitern eine Klasse.\nErweiterungsmethoden erweitern eine Klasse.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.36",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.78.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_29.jupyter.kts (6:23 - 37) Unresolved reference: addAllElements"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.37",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.79.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig: [0, 2, 4, 6, 8]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.38",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.80.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt(x=-10, y=-20, z=-30)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.39",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.81.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_32.jupyter.kts (6:23 - 24) Unresolved reference. None of the following candidates is applicable because of receiver type mismatch: \npublic inline operator fun BigDecimal.plus(other: BigDecimal): BigDecimal defined in kotlin\npublic inline operator fun BigInteger.plus(other: BigInteger): BigInteger defined in kotlin\npublic operator fun <T> Array<TypeVariable(T)>.plus(element: TypeVariable(T)): Array<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Array<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): Array<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Array<TypeVariable(T)>.plus(elements: Collection<TypeVariable(T)>): Array<TypeVariable(T)> defined in kotlin.collections\npublic operator fun BooleanArray.plus(element: Boolean): BooleanArray defined in kotlin.collections\npublic operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray defined in kotlin.collections\npublic operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray defined in kotlin.collections\npublic operator fun ByteArray.plus(element: Byte): ByteArray defined in kotlin.collections\npublic operator fun ByteArray.plus(elements: ByteArray): ByteArray defined in kotlin.collections\npublic operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray defined in kotlin.collections\npublic inline operator fun Char.plus(other: String): String defined in kotlin.text\npublic operator fun CharArray.plus(element: Char): CharArray defined in kotlin.collections\npublic operator fun CharArray.plus(elements: CharArray): CharArray defined in kotlin.collections\npublic operator fun CharArray.plus(elements: Collection<Char>): CharArray defined in kotlin.collections\npublic operator fun DoubleArray.plus(element: Double): DoubleArray defined in kotlin.collections\npublic operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray defined in kotlin.collections\npublic operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray defined in kotlin.collections\npublic operator fun FloatArray.plus(element: Float): FloatArray defined in kotlin.collections\npublic operator fun FloatArray.plus(elements: FloatArray): FloatArray defined in kotlin.collections\npublic operator fun FloatArray.plus(elements: Collection<Float>): FloatArray defined in kotlin.collections\npublic operator fun IntArray.plus(element: Int): IntArray defined in kotlin.collections\npublic operator fun IntArray.plus(elements: IntArray): IntArray defined in kotlin.collections\npublic operator fun IntArray.plus(elements: Collection<Int>): IntArray defined in kotlin.collections\npublic operator fun LongArray.plus(element: Long): LongArray defined in kotlin.collections\npublic operator fun LongArray.plus(elements: LongArray): LongArray defined in kotlin.collections\npublic operator fun LongArray.plus(elements: Collection<Long>): LongArray defined in kotlin.collections\npublic operator fun ShortArray.plus(element: Short): ShortArray defined in kotlin.collections\npublic operator fun ShortArray.plus(elements: ShortArray): ShortArray defined in kotlin.collections\npublic operator fun ShortArray.plus(elements: Collection<Short>): ShortArray defined in kotlin.collections\npublic operator fun String?.plus(other: Any?): String defined in kotlin\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray defined in kotlin.collections\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray defined in kotlin.collections\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray defined in kotlin.collections\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray defined in kotlin.collections\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray defined in kotlin.collections\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray defined in kotlin.collections\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray defined in kotlin.collections\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray defined in kotlin.collections\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray defined in kotlin.collections\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray defined in kotlin.collections\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray defined in kotlin.collections\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(element: TypeVariable(T)): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(element: TypeVariable(T)): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pairs: Array<out Pair<TypeVariable(K), TypeVariable(V)>>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pair: Pair<TypeVariable(K), TypeVariable(V)>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pairs: Iterable<Pair<TypeVariable(K), TypeVariable(V)>>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(map: Map<out TypeVariable(K), TypeVariable(V)>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pairs: Sequence<Pair<TypeVariable(K), TypeVariable(V)>>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(element: TypeVariable(T)): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(element: TypeVariable(T)): Sequence<TypeVariable(T)> defined in kotlin.sequences\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): Sequence<TypeVariable(T)> defined in kotlin.sequences\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): Sequence<TypeVariable(T)> defined in kotlin.sequences\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): Sequence<TypeVariable(T)> defined in kotlin.sequences"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.40",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.82.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig: Punkt(x=40, y=40, z=40)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.41",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.83.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "liste1: [1, 2, 3, 4, 5, 6]\nliste2: []\nliste3: [1, 2.0, Kotlin, a, /]\nliste4: [Kotlin, Java]\nliste5: [0, 1, 2, 3, 4]\nliste6: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nliste7: [0, 0, 0, 0, 0, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.42",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.84.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "liste[1]: 1, liste.get(1): 1\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.43",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.85.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Länge der Liste [true, false, false, false, true, true]: 6\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.44",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.86.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "array ist ein Array: true\nliste1 ist eine List: true\nliste2 ist eine MutableList: true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.45",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.87.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Liste: [1, 2, 3, 4, 5, 6]\nGefüllte Liste: [100, 100, 100, 100, 100, 100]\nGeleerte Liste: []\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.46",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.88.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Liste: [a, b, c, d, e]\nListe mit hinzugefügten Elementen: [a, b, z, c, d, e, f]\nListe mit entfernten Elementen: [b, c, d, e, f]\n\nKurzschreibweise\nListe2: [a, b, c, d, e]\nListe2 mit hinzugefügten Elementen: [a, b, z, c, d, e, f]\nListe2 mit entfernten Elementen: [b, c, d, e, f]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.47",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.89.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ausgangsliste: [1, 2, 3, 4, 5, 6]\nTeilliste von 3 bis liste.size: [4, 5, 6]\nTeilliste der ersten 3 Elemente: [1, 2, 3]\nTeilliste der letzten 3 Elemente: [4, 5, 6]\nTeilliste ohne die ersten 3 Elemente: [4, 5, 6]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.48",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.90.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ist 'Java' in der Liste: true\nIst 'Javascript' in der Liste: false\nWelchen Index besitzt 'Java' in der Liste: 1\nWelchen Index besitzt 'Javascript' in der Liste: -1\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.49",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.91.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ausgangsliste: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nZufälliges Element: 6\nZufällige Anordnung: [7, 2, 6, 1, 8, 9, 4, 3, 5, 0]\nWieder sortiert: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.50",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.92.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "unveränderbares Set: [1, 2, 3, 4, 5]\nveränderbares Set: [1, 2, 3, 4, 5]\nveränderbares Set ohne 3: [1, 2, 4, 5]\nveränderbares Set mit 10: [1, 2, 4, 5, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.51",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.93.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Set1: [1, 2, 3, 4, 5], Set2: [4, 5, 6, 7, 8]\nVereinigung: [1, 2, 3, 4, 5, 6, 7, 8]\nSchnittmenge: [4, 5]\nSubtraktion: [1, 2, 3]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.52",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.94.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "unveränderbare Map: {Kotlin=0, Java=1, C=2}\nveränderbare Map: {AI1=Westfechtel, AI2=Rauber, AI3=Henrich}\nWert zum Schlüssel AI2: Rauber\nveränderbare Map mit AI4: {AI1=Westfechtel, AI2=Rauber, AI3=Henrich, AI4=Jablonski}\nveränderbare Map ohne AI2: {AI1=Westfechtel, AI3=Henrich, AI4=Jablonski}\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.53",
   "versions": [
    {
     "start_checkpoint": 1616856887897,
     "parent": "c.95.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "AI1: Westfechtel\nAI2: Rauber\nAI3: Henrich\nAI4: Jablonski\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.54",
   "versions": [
    {
     "start_checkpoint": 1616857853620,
     "parent": "c.100.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Hello World Kotlin.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.55",
   "versions": [
    {
     "start_checkpoint": 1616857853620,
     "parent": "c.101.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Hello World Max.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.56",
   "versions": [
    {
     "start_checkpoint": 1616857853620,
     "parent": "c.102.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Hello World MAX.toLowerCase().\nHello World max.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.57",
   "versions": [
    {
     "start_checkpoint": 1616857853620,
     "parent": "c.103.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "schreibgeschützte Variable - Test\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.58",
   "versions": [
    {
     "start_checkpoint": 1616857853620,
     "parent": "c.104.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_4.jupyter.kts (5:1 - 6) Const 'val' are only allowed on top level or in objects"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.59",
   "versions": [
    {
     "start_checkpoint": 1616857853620,
     "parent": "c.105.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Datentyp von v1: String, Datentyp von v2: String\nDatentyp von string1: String, Datentyp von string2: String\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.60",
   "versions": [
    {
     "start_checkpoint": 1616857853621,
     "parent": "c.106.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "vergleicheElemente: Gleich\nvergleicheSpeicher: Ungleich\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.61",
   "versions": [
    {
     "start_checkpoint": 1616857853621,
     "parent": "c.107.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "vergleicheStrings: Kotlin > Java\nvergleicheStrings: Java < Kotlin\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.62",
   "versions": [
    {
     "start_checkpoint": 1616857853621,
     "parent": "c.108.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "a - b ist: 60.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.63",
   "versions": [
    {
     "start_checkpoint": 1616857853621,
     "parent": "c.109.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "TEST\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.64",
   "versions": [
    {
     "start_checkpoint": 1616857853621,
     "parent": "c.110.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "a: 1, b: 2, c: 1, d: 2\na: 1, b: 2, c: 0, d: 0\na: 0, b: 0, c: 0, d: 0\na: 0, b: 2, c: 0, d: 2\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.65",
   "versions": [
    {
     "start_checkpoint": 1616857853621,
     "parent": "c.111.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "10\n42\n0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.66",
   "versions": [
    {
     "start_checkpoint": 1616857853621,
     "parent": "c.112.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Sum mit 2 Int-Parametern: 5\nSum mit 3 Int-Parametern: 9\nSum mit 2 Double-Parametern: 5.0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.67",
   "versions": [
    {
     "start_checkpoint": 1616857853621,
     "parent": "c.113.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "gleich 10\ngleich 10\ngleich 10\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.68",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.114.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Umlaut\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.69",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.115.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 ist in Liste [0, 1, 2, 3]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.70",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.116.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "gleich 10\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.71",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.117.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Der Bereich 0..10 vom Typ IntRange geht von 0 bis 10 und umfasst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nDer Bereich 5..10 vom Typ IntRange geht von 5 bis 10 und umfasst [5, 6, 7, 8, 9, 10]\nDer Bereich a..e vom Typ CharRange geht von a bis e und umfasst [a, b, c, d, e]\nDer Bereich 0..9 vom Typ IntRange geht von 0 bis 9 und umfasst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nDer Bereich 10 downTo 0 step 1 vom Typ IntProgression geht von 10 bis 0 und umfasst [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\nDer Bereich 0..10 step 2 vom Typ IntProgression geht von 0 bis 10 und umfasst [0, 2, 4, 6, 8, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.72",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.118.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 1 2 3 4 5 6 7 8 9 10 \n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \n15 10 5 "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.73",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.119.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Kotlin Java C Python "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.74",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.120.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_20.jupyter.kts (3:5 - 6) Val cannot be reassigned"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.75",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.121.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "[1, 4, 9, 16, 25]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.76",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.122.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "An Stelle 0 ist 1 gespeichert\nAn Stelle 1 ist 2 gespeichert\nAn Stelle 2 ist 3 gespeichert\nAn Stelle 3 ist 4 gespeichert\nAn Stelle 4 ist 5 gespeichert\n[1, 4, 9, 16, 25]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.77",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.123.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Aktuell untersucht: 0\nAktuell untersucht: 11\nAktuell untersucht: 22\nAktuell untersucht: 33\nAktuell untersucht: 44\nAktuell untersucht: 55\nGefunden 55\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.78",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.124.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 1 2 3 4 5 6 7 8 9 10 11 10 9 8 7 6 5 4 3 2 1 0 "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.79",
   "versions": [
    {
     "start_checkpoint": 1616857853622,
     "parent": "c.125.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 1 2 3 4 5 6 7 8 9 "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.80",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.126.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Die Zehnerstelle von der Zahl 34291 lautet 9\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.81",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.127.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_27.jupyter.kts (5:10 - 20) Unresolved reference: addNewLine\nLine_27.jupyter.kts (6:30 - 40) Unresolved reference: addNewLine\nLine_27.jupyter.kts (6:51 - 61) Unresolved reference: addNewLine\nLine_27.jupyter.kts (8:29 - 39) Unresolved reference: addNewLine\nLine_27.jupyter.kts (8:50 - 60) Unresolved reference: addNewLine"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.82",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.128.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig:\nErweiterungsmethoden erweitern eine Klasse.\nErweiterungsmethoden erweitern eine Klasse.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.83",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.129.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_29.jupyter.kts (6:23 - 37) Unresolved reference: addAllElements"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.84",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.130.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig: [0, 2, 4, 6, 8]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.85",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.131.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt(x=-10, y=-20, z=-30)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.86",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.132.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_32.jupyter.kts (6:23 - 24) Unresolved reference. None of the following candidates is applicable because of receiver type mismatch: \npublic inline operator fun BigDecimal.plus(other: BigDecimal): BigDecimal defined in kotlin\npublic inline operator fun BigInteger.plus(other: BigInteger): BigInteger defined in kotlin\npublic operator fun <T> Array<TypeVariable(T)>.plus(element: TypeVariable(T)): Array<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Array<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): Array<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Array<TypeVariable(T)>.plus(elements: Collection<TypeVariable(T)>): Array<TypeVariable(T)> defined in kotlin.collections\npublic operator fun BooleanArray.plus(element: Boolean): BooleanArray defined in kotlin.collections\npublic operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray defined in kotlin.collections\npublic operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray defined in kotlin.collections\npublic operator fun ByteArray.plus(element: Byte): ByteArray defined in kotlin.collections\npublic operator fun ByteArray.plus(elements: ByteArray): ByteArray defined in kotlin.collections\npublic operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray defined in kotlin.collections\npublic inline operator fun Char.plus(other: String): String defined in kotlin.text\npublic operator fun CharArray.plus(element: Char): CharArray defined in kotlin.collections\npublic operator fun CharArray.plus(elements: CharArray): CharArray defined in kotlin.collections\npublic operator fun CharArray.plus(elements: Collection<Char>): CharArray defined in kotlin.collections\npublic operator fun DoubleArray.plus(element: Double): DoubleArray defined in kotlin.collections\npublic operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray defined in kotlin.collections\npublic operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray defined in kotlin.collections\npublic operator fun FloatArray.plus(element: Float): FloatArray defined in kotlin.collections\npublic operator fun FloatArray.plus(elements: FloatArray): FloatArray defined in kotlin.collections\npublic operator fun FloatArray.plus(elements: Collection<Float>): FloatArray defined in kotlin.collections\npublic operator fun IntArray.plus(element: Int): IntArray defined in kotlin.collections\npublic operator fun IntArray.plus(elements: IntArray): IntArray defined in kotlin.collections\npublic operator fun IntArray.plus(elements: Collection<Int>): IntArray defined in kotlin.collections\npublic operator fun LongArray.plus(element: Long): LongArray defined in kotlin.collections\npublic operator fun LongArray.plus(elements: LongArray): LongArray defined in kotlin.collections\npublic operator fun LongArray.plus(elements: Collection<Long>): LongArray defined in kotlin.collections\npublic operator fun ShortArray.plus(element: Short): ShortArray defined in kotlin.collections\npublic operator fun ShortArray.plus(elements: ShortArray): ShortArray defined in kotlin.collections\npublic operator fun ShortArray.plus(elements: Collection<Short>): ShortArray defined in kotlin.collections\npublic operator fun String?.plus(other: Any?): String defined in kotlin\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray defined in kotlin.collections\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray defined in kotlin.collections\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray defined in kotlin.collections\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray defined in kotlin.collections\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray defined in kotlin.collections\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray defined in kotlin.collections\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray defined in kotlin.collections\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray defined in kotlin.collections\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray defined in kotlin.collections\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray defined in kotlin.collections\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray defined in kotlin.collections\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(element: TypeVariable(T)): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(element: TypeVariable(T)): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pairs: Array<out Pair<TypeVariable(K), TypeVariable(V)>>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pair: Pair<TypeVariable(K), TypeVariable(V)>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pairs: Iterable<Pair<TypeVariable(K), TypeVariable(V)>>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(map: Map<out TypeVariable(K), TypeVariable(V)>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pairs: Sequence<Pair<TypeVariable(K), TypeVariable(V)>>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(element: TypeVariable(T)): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(element: TypeVariable(T)): Sequence<TypeVariable(T)> defined in kotlin.sequences\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): Sequence<TypeVariable(T)> defined in kotlin.sequences\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): Sequence<TypeVariable(T)> defined in kotlin.sequences\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): Sequence<TypeVariable(T)> defined in kotlin.sequences"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.87",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.133.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig: Punkt(x=40, y=40, z=40)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.88",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.134.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "liste1: [1, 2, 3, 4, 5, 6]\nliste2: []\nliste3: [1, 2.0, Kotlin, a, /]\nliste4: [Kotlin, Java]\nliste5: [0, 1, 2, 3, 4]\nliste6: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nliste7: [0, 0, 0, 0, 0, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.89",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.135.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "liste[1]: 1, liste.get(1): 1\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.90",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.136.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Länge der Liste [true, false, false, false, true, true]: 6\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.91",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.137.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "array ist ein Array: true\nliste1 ist eine List: true\nliste2 ist eine MutableList: true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.92",
   "versions": [
    {
     "start_checkpoint": 1616857853623,
     "parent": "c.138.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Liste: [1, 2, 3, 4, 5, 6]\nGefüllte Liste: [100, 100, 100, 100, 100, 100]\nGeleerte Liste: []\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.93",
   "versions": [
    {
     "start_checkpoint": 1616857853624,
     "parent": "c.139.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Liste: [a, b, c, d, e]\nListe mit hinzugefügten Elementen: [a, b, z, c, d, e, f]\nListe mit entfernten Elementen: [b, c, d, e, f]\n\nKurzschreibweise\nListe2: [a, b, c, d, e]\nListe2 mit hinzugefügten Elementen: [a, b, z, c, d, e, f]\nListe2 mit entfernten Elementen: [b, c, d, e, f]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.94",
   "versions": [
    {
     "start_checkpoint": 1616857853624,
     "parent": "c.140.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ausgangsliste: [1, 2, 3, 4, 5, 6]\nTeilliste von 3 bis liste.size: [4, 5, 6]\nTeilliste der ersten 3 Elemente: [1, 2, 3]\nTeilliste der letzten 3 Elemente: [4, 5, 6]\nTeilliste ohne die ersten 3 Elemente: [4, 5, 6]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.95",
   "versions": [
    {
     "start_checkpoint": 1616857853624,
     "parent": "c.141.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ist 'Java' in der Liste: true\nIst 'Javascript' in der Liste: false\nWelchen Index besitzt 'Java' in der Liste: 1\nWelchen Index besitzt 'Javascript' in der Liste: -1\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.96",
   "versions": [
    {
     "start_checkpoint": 1616857853624,
     "parent": "c.142.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ausgangsliste: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nZufälliges Element: 6\nZufällige Anordnung: [7, 2, 6, 1, 8, 9, 4, 3, 5, 0]\nWieder sortiert: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.97",
   "versions": [
    {
     "start_checkpoint": 1616857853624,
     "parent": "c.143.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "unveränderbares Set: [1, 2, 3, 4, 5]\nveränderbares Set: [1, 2, 3, 4, 5]\nveränderbares Set ohne 3: [1, 2, 4, 5]\nveränderbares Set mit 10: [1, 2, 4, 5, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.98",
   "versions": [
    {
     "start_checkpoint": 1616857853624,
     "parent": "c.144.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Set1: [1, 2, 3, 4, 5], Set2: [4, 5, 6, 7, 8]\nVereinigung: [1, 2, 3, 4, 5, 6, 7, 8]\nSchnittmenge: [4, 5]\nSubtraktion: [1, 2, 3]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.99",
   "versions": [
    {
     "start_checkpoint": 1616857853624,
     "parent": "c.145.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "unveränderbare Map: {Kotlin=0, Java=1, C=2}\nveränderbare Map: {AI1=Westfechtel, AI2=Rauber, AI3=Henrich}\nWert zum Schlüssel AI2: Rauber\nveränderbare Map mit AI4: {AI1=Westfechtel, AI2=Rauber, AI3=Henrich, AI4=Jablonski}\nveränderbare Map ohne AI2: {AI1=Westfechtel, AI3=Henrich, AI4=Jablonski}\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.100",
   "versions": [
    {
     "start_checkpoint": 1616857853624,
     "parent": "c.146.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "AI1: Westfechtel\nAI2: Rauber\nAI3: Henrich\nAI4: Jablonski\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.101",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.199.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Hello World Kotlin.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.102",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.200.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Hello World Max.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.103",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.201.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Hello World MAX.toLowerCase().\nHello World max.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.104",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.202.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "schreibgeschützte Variable - Test\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.105",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.203.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_4.jupyter.kts (5:1 - 6) Const 'val' are only allowed on top level or in objects"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.106",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.204.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Datentyp von v1: String, Datentyp von v2: String\nDatentyp von string1: String, Datentyp von string2: String\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.107",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.205.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "vergleicheElemente: Gleich\nvergleicheSpeicher: Ungleich\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.108",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.206.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "vergleicheStrings: Kotlin > Java\nvergleicheStrings: Java < Kotlin\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.109",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.207.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "a - b ist: 60.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.110",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.208.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "TEST\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.111",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.209.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "a: 1, b: 2, c: 1, d: 2\na: 1, b: 2, c: 0, d: 0\na: 0, b: 0, c: 0, d: 0\na: 0, b: 2, c: 0, d: 2\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.112",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.210.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "10\n42\n0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.113",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.211.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Sum mit 2 Int-Parametern: 5\nSum mit 3 Int-Parametern: 9\nSum mit 2 Double-Parametern: 5.0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.114",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.212.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "gleich 10\ngleich 10\ngleich 10\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.115",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.213.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Umlaut\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.116",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.214.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 ist in Liste [0, 1, 2, 3]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.117",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.215.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "gleich 10\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.118",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.216.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Der Bereich 0..10 vom Typ IntRange geht von 0 bis 10 und umfasst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nDer Bereich 5..10 vom Typ IntRange geht von 5 bis 10 und umfasst [5, 6, 7, 8, 9, 10]\nDer Bereich a..e vom Typ CharRange geht von a bis e und umfasst [a, b, c, d, e]\nDer Bereich 0..9 vom Typ IntRange geht von 0 bis 9 und umfasst [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nDer Bereich 10 downTo 0 step 1 vom Typ IntProgression geht von 10 bis 0 und umfasst [10, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0]\nDer Bereich 0..10 step 2 vom Typ IntProgression geht von 0 bis 10 und umfasst [0, 2, 4, 6, 8, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.119",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.217.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 1 2 3 4 5 6 7 8 9 10 \n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 \n15 10 5 "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.120",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.218.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Kotlin Java C Python "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.121",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.219.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_20.jupyter.kts (3:5 - 6) Val cannot be reassigned"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.122",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.220.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "[1, 4, 9, 16, 25]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.123",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.221.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "An Stelle 0 ist 1 gespeichert\nAn Stelle 1 ist 2 gespeichert\nAn Stelle 2 ist 3 gespeichert\nAn Stelle 3 ist 4 gespeichert\nAn Stelle 4 ist 5 gespeichert\n[1, 4, 9, 16, 25]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.124",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.222.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Aktuell untersucht: 0\nAktuell untersucht: 11\nAktuell untersucht: 22\nAktuell untersucht: 33\nAktuell untersucht: 44\nAktuell untersucht: 55\nGefunden 55\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.125",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.223.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 1 2 3 4 5 6 7 8 9 10 11 10 9 8 7 6 5 4 3 2 1 0 "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.126",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.224.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 1 2 3 4 5 6 7 8 9 "
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.127",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.225.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Die Zehnerstelle von der Zahl 34291 lautet 9\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.128",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.226.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_27.jupyter.kts (5:10 - 20) Unresolved reference: addNewLine\nLine_27.jupyter.kts (6:30 - 40) Unresolved reference: addNewLine\nLine_27.jupyter.kts (6:51 - 61) Unresolved reference: addNewLine\nLine_27.jupyter.kts (8:29 - 39) Unresolved reference: addNewLine\nLine_27.jupyter.kts (8:50 - 60) Unresolved reference: addNewLine"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.129",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.227.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig:\nErweiterungsmethoden erweitern eine Klasse.\nErweiterungsmethoden erweitern eine Klasse.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.130",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.228.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_29.jupyter.kts (6:23 - 37) Unresolved reference: addAllElements"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.131",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.229.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig: [0, 2, 4, 6, 8]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.132",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.230.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt(x=-10, y=-20, z=-30)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.133",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.231.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_32.jupyter.kts (6:23 - 24) Unresolved reference. None of the following candidates is applicable because of receiver type mismatch: \npublic inline operator fun BigDecimal.plus(other: BigDecimal): BigDecimal defined in kotlin\npublic inline operator fun BigInteger.plus(other: BigInteger): BigInteger defined in kotlin\npublic operator fun <T> Array<TypeVariable(T)>.plus(element: TypeVariable(T)): Array<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Array<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): Array<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Array<TypeVariable(T)>.plus(elements: Collection<TypeVariable(T)>): Array<TypeVariable(T)> defined in kotlin.collections\npublic operator fun BooleanArray.plus(element: Boolean): BooleanArray defined in kotlin.collections\npublic operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray defined in kotlin.collections\npublic operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray defined in kotlin.collections\npublic operator fun ByteArray.plus(element: Byte): ByteArray defined in kotlin.collections\npublic operator fun ByteArray.plus(elements: ByteArray): ByteArray defined in kotlin.collections\npublic operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray defined in kotlin.collections\npublic inline operator fun Char.plus(other: String): String defined in kotlin.text\npublic operator fun CharArray.plus(element: Char): CharArray defined in kotlin.collections\npublic operator fun CharArray.plus(elements: CharArray): CharArray defined in kotlin.collections\npublic operator fun CharArray.plus(elements: Collection<Char>): CharArray defined in kotlin.collections\npublic operator fun DoubleArray.plus(element: Double): DoubleArray defined in kotlin.collections\npublic operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray defined in kotlin.collections\npublic operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray defined in kotlin.collections\npublic operator fun FloatArray.plus(element: Float): FloatArray defined in kotlin.collections\npublic operator fun FloatArray.plus(elements: FloatArray): FloatArray defined in kotlin.collections\npublic operator fun FloatArray.plus(elements: Collection<Float>): FloatArray defined in kotlin.collections\npublic operator fun IntArray.plus(element: Int): IntArray defined in kotlin.collections\npublic operator fun IntArray.plus(elements: IntArray): IntArray defined in kotlin.collections\npublic operator fun IntArray.plus(elements: Collection<Int>): IntArray defined in kotlin.collections\npublic operator fun LongArray.plus(element: Long): LongArray defined in kotlin.collections\npublic operator fun LongArray.plus(elements: LongArray): LongArray defined in kotlin.collections\npublic operator fun LongArray.plus(elements: Collection<Long>): LongArray defined in kotlin.collections\npublic operator fun ShortArray.plus(element: Short): ShortArray defined in kotlin.collections\npublic operator fun ShortArray.plus(elements: ShortArray): ShortArray defined in kotlin.collections\npublic operator fun ShortArray.plus(elements: Collection<Short>): ShortArray defined in kotlin.collections\npublic operator fun String?.plus(other: Any?): String defined in kotlin\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray defined in kotlin.collections\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray defined in kotlin.collections\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray defined in kotlin.collections\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray defined in kotlin.collections\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray defined in kotlin.collections\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray defined in kotlin.collections\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray defined in kotlin.collections\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray defined in kotlin.collections\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray defined in kotlin.collections\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray defined in kotlin.collections\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray defined in kotlin.collections\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(element: TypeVariable(T)): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Collection<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(element: TypeVariable(T)): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Iterable<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): List<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pairs: Array<out Pair<TypeVariable(K), TypeVariable(V)>>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pair: Pair<TypeVariable(K), TypeVariable(V)>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pairs: Iterable<Pair<TypeVariable(K), TypeVariable(V)>>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(map: Map<out TypeVariable(K), TypeVariable(V)>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <K, V> Map<out TypeVariable(K), TypeVariable(V)>.plus(pairs: Sequence<Pair<TypeVariable(K), TypeVariable(V)>>): Map<TypeVariable(K), TypeVariable(V)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(element: TypeVariable(T)): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Set<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): Set<TypeVariable(T)> defined in kotlin.collections\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(element: TypeVariable(T)): Sequence<TypeVariable(T)> defined in kotlin.sequences\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(elements: Array<out TypeVariable(T)>): Sequence<TypeVariable(T)> defined in kotlin.sequences\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(elements: Iterable<TypeVariable(T)>): Sequence<TypeVariable(T)> defined in kotlin.sequences\npublic operator fun <T> Sequence<TypeVariable(T)>.plus(elements: Sequence<TypeVariable(T)>): Sequence<TypeVariable(T)> defined in kotlin.sequences"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.134",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.232.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig: Punkt(x=40, y=40, z=40)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.135",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.233.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "liste1: [1, 2, 3, 4, 5, 6]\nliste2: []\nliste3: [1, 2.0, Kotlin, a, /]\nliste4: [Kotlin, Java]\nliste5: [0, 1, 2, 3, 4]\nliste6: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\nliste7: [0, 0, 0, 0, 0, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.136",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.234.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "liste[1]: 1, liste.get(1): 1\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.137",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.235.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Länge der Liste [true, false, false, false, true, true]: 6\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.138",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.236.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "array ist ein Array: true\nliste1 ist eine List: true\nliste2 ist eine MutableList: true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.139",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.237.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Liste: [1, 2, 3, 4, 5, 6]\nGefüllte Liste: [100, 100, 100, 100, 100, 100]\nGeleerte Liste: []\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.140",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.238.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Liste: [a, b, c, d, e]\nListe mit hinzugefügten Elementen: [a, b, z, c, d, e, f]\nListe mit entfernten Elementen: [b, c, d, e, f]\n\nKurzschreibweise\nListe2: [a, b, c, d, e]\nListe2 mit hinzugefügten Elementen: [a, b, z, c, d, e, f]\nListe2 mit entfernten Elementen: [b, c, d, e, f]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.141",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.239.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ausgangsliste: [1, 2, 3, 4, 5, 6]\nTeilliste von 3 bis liste.size: [4, 5, 6]\nTeilliste der ersten 3 Elemente: [1, 2, 3]\nTeilliste der letzten 3 Elemente: [4, 5, 6]\nTeilliste ohne die ersten 3 Elemente: [4, 5, 6]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.142",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.240.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ist 'Java' in der Liste: true\nIst 'Javascript' in der Liste: false\nWelchen Index besitzt 'Java' in der Liste: 1\nWelchen Index besitzt 'Javascript' in der Liste: -1\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.143",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.241.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ausgangsliste: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nZufälliges Element: 6\nZufällige Anordnung: [7, 2, 6, 1, 8, 9, 4, 3, 5, 0]\nWieder sortiert: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.144",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.242.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "unveränderbares Set: [1, 2, 3, 4, 5]\nveränderbares Set: [1, 2, 3, 4, 5]\nveränderbares Set ohne 3: [1, 2, 4, 5]\nveränderbares Set mit 10: [1, 2, 4, 5, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.145",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.243.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Set1: [1, 2, 3, 4, 5], Set2: [4, 5, 6, 7, 8]\nVereinigung: [1, 2, 3, 4, 5, 6, 7, 8]\nSchnittmenge: [4, 5]\nSubtraktion: [1, 2, 3]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.146",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.244.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "unveränderbare Map: {Kotlin=0, Java=1, C=2}\nveränderbare Map: {AI1=Westfechtel, AI2=Rauber, AI3=Henrich}\nWert zum Schlüssel AI2: Rauber\nveränderbare Map mit AI4: {AI1=Westfechtel, AI2=Rauber, AI3=Henrich, AI4=Jablonski}\nveränderbare Map ohne AI2: {AI1=Westfechtel, AI3=Henrich, AI4=Jablonski}\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.147",
   "versions": [
    {
     "start_checkpoint": 1616859134396,
     "parent": "c.245.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "AI1: Westfechtel\nAI2: Rauber\nAI3: Henrich\nAI4: Jablonski\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.148",
   "versions": [
    {
     "start_checkpoint": 1617008296329,
     "parent": "c.227.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Falsch:\nErweiterungsmethoden erweitern eine Klasse.Erweiterungsmethoden erweitern eine Klasse.\nRichtig wäre:\nErweiterungsmethoden erweitern eine Klasse.\nErweiterungsmethoden erweitern eine Klasse.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.149",
   "versions": [
    {
     "start_checkpoint": 1617025435363,
     "parent": "c.254.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Richtig:\nErweiterungsmethoden erweitern eine Klasse.\nErweiterungsmethoden erweitern eine Klasse.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.150",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "c.257.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Datentyp von int1: Int, Datentyp von int2: Int\nDatentyp von string1: String, Datentyp von string2: String\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.151",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "c.258.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "vergleicheStrings: Kotlin > Java. Ergebnis von compareTo(): 1. \nvergleicheStrings: Java < Kotlin. Ergebnis von compareTo(): -1. \n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.152",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "c.259.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "foo(1,2,1,2): a: 1, b: 2, c: 1, d: 2\nfoo(1,2): a: 1, b: 2, c: 0, d: 0\nfoo(): a: 0, b: 0, c: 0, d: 0\nfoo(b=2,d=2): a: 0, b: 2, c: 0, d: 2\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.153",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "c.261.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "sum(5,5): 10\nfoo(42): 42\nfoo(24): 0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.154",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "c.262.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "10 ist gleich 10\n10 ist gleich 10\n10 ist gleich 10\n10 ist gleich 10\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.155",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "c.263.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Umlaut\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.156",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "c.264.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "0 ist in Liste [0, 1, 2, 3]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.157",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "c.265.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Falsch! 1 ist vom Typ Int, Ergebnis typCheckerIf: , Ergebnis typCheckerWhen: \nFalsch! 1.0 ist vom Typ Double, Ergebnis typCheckerIf: , Ergebnis typCheckerWhen: \nFalsch! 100 ist vom Typ Long, Ergebnis typCheckerIf: , Ergebnis typCheckerWhen: \nFalsch! Test ist vom Typ String, Ergebnis typCheckerIf: , Ergebnis typCheckerWhen: \n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.158",
   "versions": [
    {
     "start_checkpoint": 1617374393763,
     "parent": "c.266.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Int\nRichtig! 1 ist vom Typ Int\nRichtig! 1.0 ist vom Typ Double\nFalsch! 100 ist vom Typ Long, Ergebnis typCheckerIf: Long, Ergebnis typCheckerWhen: Long2\nRichtig! Test ist vom Typ Sonstiges\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.159",
   "versions": [
    {
     "start_checkpoint": 1617374738478,
     "parent": "c.269.1",
     "raw": [
      {
       "name": "stdout",
       "text": "3\n4\n0.0\n6\n5.0\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.160",
   "versions": [
    {
     "start_checkpoint": 1617374793459,
     "parent": "c.269.2",
     "raw": [
      {
       "name": "stdout",
       "text": "array1: [Ljava.lang.Integer;@633dce39\narray1[2]: array1[2]\narray1.size: 4\n0.0\n6\n5.0\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.161",
   "versions": [
    {
     "start_checkpoint": 1617374818127,
     "parent": "c.269.3",
     "raw": [
      {
       "name": "stdout",
       "text": "array1: [1, 2, 3, 4]\narray1[2]: array1[2]\narray1.size: 4\n0.0\n6\n5.0\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.162",
   "versions": [
    {
     "start_checkpoint": 1617374831543,
     "parent": "c.269.4",
     "raw": [
      {
       "name": "stdout",
       "text": "array1: [1, 2, 3, 4]\narray1[2]: 3\narray1.size: 4\n0.0\n6\n5.0\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.163",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.270.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "v1: 0, Datentyp: Int\nv2: 0, Datentyp: Int\nv3: 20, Datentyp: Int\nv4: 20.0, Datentyp: Float\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.164",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.271.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "array1: [1, 2, 3, 4]\narray1[2]: 3\narray1.size: 4\n\narray2: [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]\narray2[2]: 0.0\narray2.size: 6\narray2 geändert: [0.0, 0.0, 0.0, 5.0, 0.0, 0.0]\narray2[3]: 5.0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.165",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.272.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Eintrag\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.166",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.274.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": " 2 0 20 16 6\n 16 20 2 11 12\n 10 7 16 6 14\n 4 13 15 20 5\n 10 11 11 20 12\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.167",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.275.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "array ist ein Array: true, array: [Ljava.lang.Integer;@2fc8b8c2\nliste1 ist eine List: true, liste1: [1, 2, 3, 4, 5, 6]\nliste2 ist eine MutableList: true, liste2: [1, 2, 3, 4, 5, 6, 5]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.168",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.276.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Liste: [a, b, c, d, e]\nListe mit hinzugefügten Elementen (f, z): [a, b, z, c, d, e, f]\nListe mit entfernten Elementen (e, a): [b, z, c, d, f]\n\nKurzschreibweise\nListe2: [a, b, c, d, e]\nListe2 mit hinzugefügten Elementen (f, z): [a, b, z, c, d, e, f]\nListe2 mit entfernten Elementen (e, a): [b, z, c, d, f]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.169",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.277.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ist 'Lua' in der Liste: true\nIst 'Javascript' in der Liste: false\nWelchen Index besitzt 'Lua' in der Liste: 2\nWelchen Index besitzt 'Javascript' in der Liste: -1\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.170",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.278.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Ausgangsliste: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nZufälliges Element: 4\nZufälliges Element zwischen 0 und 9: 5\nZufällige Anordnung: [7, 3, 2, 4, 8, 6, 0, 9, 1, 5]\nWieder sortiert: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.171",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.279.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "unveränderbares Set: [1, 6, 3, 4, 5, 2]\nveränderbares Set: [1, 6, 3, 4, 5, 2]\nveränderbares Set ohne 3: [1, 6, 4, 5, 2]\nveränderbares Set mit 10: [1, 6, 4, 5, 2, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.172",
   "versions": [
    {
     "start_checkpoint": 1617531200343,
     "parent": "c.280.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Unveränderbare Map: {Kotlin=0, Java=1, C=2}\n\nVeränderbare Map: {AI1=Westfechtel, AI2=Rauber, AI3=Henrich}\nWert zum Schlüssel AI2: Rauber\nVeränderbare Map mit AI4: {AI1=Westfechtel, AI2=Rauber, AI3=Henrich, AI4=Jablonski}\nVeränderbare Map ohne AI2: {AI1=Westfechtel, AI3=Henrich, AI4=Jablonski}\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.173",
   "versions": [
    {
     "start_checkpoint": 1617531350792,
     "parent": "c.270.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Int\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.174",
   "versions": [
    {
     "start_checkpoint": 1617531355599,
     "parent": "c.270.2",
     "raw": [
      {
       "name": "stdout",
       "text": "String\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.175",
   "versions": [
    {
     "start_checkpoint": 1617531362078,
     "parent": "c.270.3",
     "raw": [
      {
       "name": "stdout",
       "text": "Double\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.176",
   "versions": [
    {
     "start_checkpoint": 1617617991364,
     "parent": "c.282.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Double\nTyp von int: Int\nTyp von float: Float\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.177",
   "versions": [
    {
     "start_checkpoint": 1617617991364,
     "parent": "c.283.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Typ von v1: Double\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.178",
   "versions": [
    {
     "start_checkpoint": 1618320018172,
     "parent": "c.286.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_20.jupyter.kts (19:9 - 12) Variable 'res' is never used\nLine_20.jupyter.kts (19:51 - 54) The character literal does not conform to the expected type MutableList<Char>\nLine_20.jupyter.kts (19:51 - 54) The character literal does not conform to the expected type MutableList<Char>\nLine_20.jupyter.kts (21:1 - 2) A 'return' expression required in a function with a block body ('{...}')"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.179",
   "versions": [
    {
     "start_checkpoint": 1618400989368,
     "parent": "c.201.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Hello World OLE.toLowerCase().\nHello World ole.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.180",
   "versions": [
    {
     "start_checkpoint": 1618400997236,
     "parent": "c.201.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Hello World MAX.toLowerCase().\nHello World max.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  }
 ]
}