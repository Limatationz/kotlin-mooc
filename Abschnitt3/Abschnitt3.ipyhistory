{
 "checkpoints": [
  {
   "timestamp": 1619004012983,
   "notebook": 0,
   "targetCells": [
    {
     "cell": "m.0.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "c.0.0",
     "changeType": "added",
     "index": 1
    }
   ]
  },
  {
   "timestamp": 1619166384323,
   "notebook": 1,
   "targetCells": [
    {
     "cell": "m.1.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "c.1.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.2.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "c.2.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "m.3.0",
     "changeType": "added",
     "index": 4
    },
    {
     "cell": "c.3.0",
     "changeType": "added",
     "index": 5
    },
    {
     "cell": "m.4.0",
     "changeType": "added",
     "index": 6
    },
    {
     "cell": "c.4.0",
     "changeType": "added",
     "index": 7
    },
    {
     "cell": "m.5.0",
     "changeType": "added",
     "index": 8
    },
    {
     "cell": "c.5.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "m.6.0",
     "changeType": "added",
     "index": 10
    },
    {
     "cell": "c.6.0",
     "changeType": "added",
     "index": 11
    },
    {
     "cell": "m.7.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "c.7.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "m.8.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "c.8.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "m.9.0",
     "changeType": "added",
     "index": 16
    },
    {
     "cell": "c.9.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "c.10.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "m.10.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "c.11.0",
     "changeType": "added",
     "index": 20
    }
   ]
  },
  {
   "timestamp": 1619166409884,
   "notebook": 2,
   "targetCells": [
    {
     "cell": "c.1.0",
     "changeType": "output changed",
     "output": [
      "o.0.1"
     ],
     "index": 1
    },
    {
     "cell": "c.12.0",
     "changeType": "added",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167416345,
   "notebook": 3,
   "targetCells": [
    {
     "cell": "c.12.1",
     "changeType": "edited",
     "output": [
      "o.8.0"
     ],
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167430512,
   "notebook": 4,
   "targetCells": [
    {
     "cell": "c.12.2",
     "changeType": "edited",
     "output": [],
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167469117,
   "notebook": 5,
   "targetCells": [
    {
     "cell": "c.12.2",
     "changeType": "output changed",
     "output": [
      "o.9.0"
     ],
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167519480,
   "notebook": 6,
   "targetCells": [
    {
     "cell": "c.12.3",
     "changeType": "edited",
     "output": [],
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167525913,
   "notebook": 7,
   "targetCells": [
    {
     "cell": "c.12.4",
     "changeType": "edited",
     "output": [
      "o.10.0"
     ],
     "index": 17
    },
    {
     "cell": "m.9.1",
     "changeType": "edited",
     "index": 16
    }
   ]
  },
  {
   "timestamp": 1619273398309,
   "notebook": 8,
   "targetCells": [
    {
     "cell": "c.13.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "c.14.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "m.11.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "c.15.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "c.16.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "m.12.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "c.17.0",
     "changeType": "added",
     "index": 22
    },
    {
     "cell": "m.13.0",
     "changeType": "added",
     "index": 23
    },
    {
     "cell": "c.18.0",
     "changeType": "added",
     "index": 24
    },
    {
     "cell": "m.14.0",
     "changeType": "added",
     "index": 25
    },
    {
     "cell": "c.19.0",
     "changeType": "added",
     "index": 26
    },
    {
     "cell": "m.15.0",
     "changeType": "added",
     "index": 27
    },
    {
     "cell": "c.20.0",
     "changeType": "added",
     "index": 28
    },
    {
     "cell": "m.16.0",
     "changeType": "added",
     "index": 29
    },
    {
     "cell": "c.21.0",
     "changeType": "added",
     "index": 30
    },
    {
     "cell": "m.17.0",
     "changeType": "added",
     "index": 31
    },
    {
     "cell": "m.18.0",
     "changeType": "added",
     "index": 32
    },
    {
     "cell": "c.22.0",
     "changeType": "added",
     "index": 33
    },
    {
     "cell": "m.19.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "m.20.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "c.23.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "m.21.0",
     "changeType": "added",
     "index": 37
    },
    {
     "cell": "c.24.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "m.22.0",
     "changeType": "added",
     "index": 39
    },
    {
     "cell": "c.25.0",
     "changeType": "added",
     "index": 40
    },
    {
     "cell": "m.23.0",
     "changeType": "added",
     "index": 41
    },
    {
     "cell": "c.26.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "m.24.0",
     "changeType": "added",
     "index": 43
    },
    {
     "cell": "m.25.0",
     "changeType": "added",
     "index": 44
    },
    {
     "cell": "c.27.0",
     "changeType": "added",
     "index": 45
    },
    {
     "cell": "m.26.0",
     "changeType": "added",
     "index": 46
    },
    {
     "cell": "c.28.0",
     "changeType": "added",
     "index": 47
    },
    {
     "cell": "m.27.0",
     "changeType": "added",
     "index": 48
    },
    {
     "cell": "c.29.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "m.28.0",
     "changeType": "added",
     "index": 50
    },
    {
     "cell": "c.30.0",
     "changeType": "added",
     "index": 51
    },
    {
     "cell": "c.31.0",
     "changeType": "added",
     "index": 53
    }
   ]
  },
  {
   "timestamp": 1619273440670,
   "notebook": 9,
   "targetCells": [
    {
     "cell": "c.32.0",
     "changeType": "added",
     "index": 50
    }
   ]
  },
  {
   "timestamp": 1619273462931,
   "notebook": 10,
   "targetCells": [
    {
     "cell": "c.32.1",
     "changeType": "edited",
     "output": [
      "o.29.0"
     ],
     "index": 50
    }
   ]
  },
  {
   "timestamp": 1619344122936,
   "notebook": 11,
   "targetCells": [
    {
     "cell": "m.29.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "c.33.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "c.34.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "m.30.0",
     "changeType": "added",
     "index": 50
    },
    {
     "cell": "m.31.0",
     "changeType": "added",
     "index": 54
    },
    {
     "cell": "c.35.0",
     "changeType": "added",
     "index": 55
    },
    {
     "cell": "m.32.0",
     "changeType": "added",
     "index": 56
    },
    {
     "cell": "c.36.0",
     "changeType": "added",
     "index": 57
    },
    {
     "cell": "m.33.0",
     "changeType": "added",
     "index": 58
    },
    {
     "cell": "c.37.0",
     "changeType": "added",
     "index": 59
    },
    {
     "cell": "c.38.0",
     "changeType": "added",
     "index": 60
    },
    {
     "cell": "m.34.0",
     "changeType": "added",
     "index": 61
    },
    {
     "cell": "m.35.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "m.36.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "m.37.0",
     "changeType": "added",
     "index": 64
    },
    {
     "cell": "c.39.0",
     "changeType": "added",
     "index": 65
    }
   ]
  },
  {
   "timestamp": 1619344680409,
   "notebook": 12,
   "targetCells": [
    {
     "cell": "c.40.0",
     "changeType": "added",
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344804639,
   "notebook": 13,
   "targetCells": [
    {
     "cell": "c.40.1",
     "changeType": "edited",
     "output": [],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344843467,
   "notebook": 14,
   "targetCells": [
    {
     "cell": "c.40.2",
     "changeType": "edited",
     "output": [],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344920701,
   "notebook": 15,
   "targetCells": [
    {
     "cell": "c.40.3",
     "changeType": "edited",
     "output": [],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344948011,
   "notebook": 16,
   "targetCells": [
    {
     "cell": "c.40.4",
     "changeType": "edited",
     "output": [],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344965296,
   "notebook": 17,
   "targetCells": [
    {
     "cell": "c.40.5",
     "changeType": "edited",
     "output": [
      "o.35.0"
     ],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344997121,
   "notebook": 18,
   "targetCells": [
    {
     "cell": "c.40.6",
     "changeType": "edited",
     "output": [
      "o.36.0"
     ],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619345039116,
   "notebook": 19,
   "targetCells": [
    {
     "cell": "c.40.7",
     "changeType": "edited",
     "output": [
      "o.37.0"
     ],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619345077293,
   "notebook": 20,
   "targetCells": [
    {
     "cell": "c.40.8",
     "changeType": "edited",
     "output": [
      "o.38.0"
     ],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619345085096,
   "notebook": 21,
   "targetCells": [
    {
     "cell": "c.40.9",
     "changeType": "edited",
     "output": [
      "o.39.0"
     ],
     "index": 62
    },
    {
     "cell": "m.34.1",
     "changeType": "edited",
     "index": 61
    },
    {
     "cell": "c.41.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "c.42.0",
     "changeType": "added",
     "index": 64
    },
    {
     "cell": "c.43.0",
     "changeType": "added",
     "index": 65
    }
   ]
  },
  {
   "timestamp": 1619427664533,
   "notebook": 22,
   "targetCells": [
    {
     "cell": "m.38.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "c.44.0",
     "changeType": "added",
     "index": 60
    },
    {
     "cell": "m.39.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "c.45.0",
     "changeType": "added",
     "index": 64
    },
    {
     "cell": "m.40.0",
     "changeType": "added",
     "index": 65
    },
    {
     "cell": "c.46.0",
     "changeType": "added",
     "index": 66
    },
    {
     "cell": "m.41.0",
     "changeType": "added",
     "index": 67
    },
    {
     "cell": "c.47.0",
     "changeType": "added",
     "index": 68
    },
    {
     "cell": "m.42.0",
     "changeType": "added",
     "index": 69
    },
    {
     "cell": "c.48.0",
     "changeType": "added",
     "index": 70
    },
    {
     "cell": "m.43.0",
     "changeType": "added",
     "index": 71
    },
    {
     "cell": "c.49.0",
     "changeType": "added",
     "index": 72
    },
    {
     "cell": "m.44.0",
     "changeType": "added",
     "index": 73
    },
    {
     "cell": "c.50.0",
     "changeType": "added",
     "index": 74
    },
    {
     "cell": "m.45.0",
     "changeType": "added",
     "index": 75
    },
    {
     "cell": "c.51.0",
     "changeType": "added",
     "index": 76
    },
    {
     "cell": "m.46.0",
     "changeType": "added",
     "index": 77
    },
    {
     "cell": "c.52.0",
     "changeType": "added",
     "index": 78
    },
    {
     "cell": "m.47.0",
     "changeType": "added",
     "index": 79
    },
    {
     "cell": "c.53.0",
     "changeType": "added",
     "index": 80
    },
    {
     "cell": "c.54.0",
     "changeType": "added",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1619427699980,
   "notebook": 23,
   "targetCells": [
    {
     "cell": "m.38.1",
     "changeType": "edited",
     "index": 0
    }
   ]
  },
  {
   "timestamp": 1619530334504,
   "notebook": 24,
   "targetCells": [
    {
     "cell": "c.55.0",
     "changeType": "added",
     "index": 60
    },
    {
     "cell": "c.56.0",
     "changeType": "added",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1622203535195,
   "notebook": 25,
   "targetCells": [
    {
     "cell": "m.48.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "m.49.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "m.50.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "c.57.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "m.51.0",
     "changeType": "added",
     "index": 45
    },
    {
     "cell": "c.58.0",
     "changeType": "added",
     "index": 46
    },
    {
     "cell": "c.59.0",
     "changeType": "added",
     "index": 47
    },
    {
     "cell": "c.60.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "m.52.0",
     "changeType": "added",
     "index": 71
    },
    {
     "cell": "c.61.0",
     "changeType": "added",
     "index": 72
    },
    {
     "cell": "m.53.0",
     "changeType": "added",
     "index": 83
    },
    {
     "cell": "c.62.0",
     "changeType": "added",
     "index": 84
    },
    {
     "cell": "m.54.0",
     "changeType": "added",
     "index": 85
    },
    {
     "cell": "c.63.0",
     "changeType": "added",
     "index": 86
    },
    {
     "cell": "m.55.0",
     "changeType": "added",
     "index": 87
    },
    {
     "cell": "c.64.0",
     "changeType": "added",
     "index": 88
    },
    {
     "cell": "m.56.0",
     "changeType": "added",
     "index": 89
    },
    {
     "cell": "c.65.0",
     "changeType": "added",
     "index": 90
    }
   ]
  },
  {
   "timestamp": 1622203932351,
   "notebook": 26,
   "targetCells": [
    {
     "cell": "m.38.2",
     "changeType": "edited",
     "index": 0
    }
   ]
  },
  {
   "timestamp": 1622203944610,
   "notebook": 27,
   "targetCells": [
    {
     "cell": "m.38.3",
     "changeType": "edited",
     "index": 0
    },
    {
     "cell": "c.13.1",
     "changeType": "edited",
     "output": [
      "o.53.0"
     ],
     "index": 1
    }
   ]
  },
  {
   "timestamp": 1622204008193,
   "notebook": 28,
   "targetCells": [
    {
     "cell": "c.13.2",
     "changeType": "edited",
     "output": [
      "o.54.0"
     ],
     "index": 1
    },
    {
     "cell": "m.48.1",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1622204182191,
   "notebook": 29,
   "targetCells": [
    {
     "cell": "m.48.2",
     "changeType": "edited",
     "index": 2
    },
    {
     "cell": "m.3.1",
     "changeType": "edited",
     "index": 4
    },
    {
     "cell": "c.3.1",
     "changeType": "edited",
     "output": [
      "o.55.0"
     ],
     "index": 5
    }
   ]
  },
  {
   "timestamp": 1622204322287,
   "notebook": 30,
   "targetCells": [
    {
     "cell": "c.3.2",
     "changeType": "edited",
     "output": [],
     "index": 5
    },
    {
     "cell": "m.4.1",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204355567,
   "notebook": 31,
   "targetCells": [
    {
     "cell": "m.4.2",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204374734,
   "notebook": 32,
   "targetCells": [
    {
     "cell": "m.4.3",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204384000,
   "notebook": 33,
   "targetCells": [
    {
     "cell": "m.4.4",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204391516,
   "notebook": 34,
   "targetCells": [
    {
     "cell": "m.4.5",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204421079,
   "notebook": 35,
   "targetCells": [
    {
     "cell": "m.4.6",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204433050,
   "notebook": 36,
   "targetCells": [
    {
     "cell": "m.4.7",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204441673,
   "notebook": 37,
   "targetCells": [
    {
     "cell": "m.4.8",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204457914,
   "notebook": 38,
   "targetCells": [
    {
     "cell": "m.4.9",
     "changeType": "edited",
     "index": 6
    },
    {
     "cell": "m.5.1",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1622204477080,
   "notebook": 39,
   "targetCells": [
    {
     "cell": "m.5.2",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1622204494036,
   "notebook": 40,
   "targetCells": [
    {
     "cell": "m.5.3",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1622204513712,
   "notebook": 41,
   "targetCells": [
    {
     "cell": "m.5.4",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1622204534951,
   "notebook": 42,
   "targetCells": [
    {
     "cell": "m.5.5",
     "changeType": "edited",
     "index": 8
    },
    {
     "cell": "m.6.1",
     "changeType": "edited",
     "index": 10
    }
   ]
  },
  {
   "timestamp": 1622204907095,
   "notebook": 43,
   "targetCells": [
    {
     "cell": "c.7.1",
     "changeType": "edited",
     "output": [],
     "index": 13
    },
    {
     "cell": "c.8.1",
     "changeType": "edited",
     "output": [
      "o.56.0"
     ],
     "index": 15
    }
   ]
  },
  {
   "timestamp": 1622205474347,
   "notebook": 44,
   "targetCells": [
    {
     "cell": "m.9.2",
     "changeType": "edited",
     "index": 16
    },
    {
     "cell": "m.49.1",
     "changeType": "edited",
     "index": 18
    },
    {
     "cell": "m.12.1",
     "changeType": "edited",
     "index": 21
    }
   ]
  },
  {
   "timestamp": 1622205682750,
   "notebook": 45,
   "targetCells": [
    {
     "cell": "m.12.2",
     "changeType": "edited",
     "index": 21
    }
   ]
  },
  {
   "timestamp": 1622205747266,
   "notebook": 46,
   "targetCells": [
    {
     "cell": "m.12.3",
     "changeType": "edited",
     "index": 21
    }
   ]
  },
  {
   "timestamp": 1622208996780,
   "notebook": 47,
   "targetCells": [
    {
     "cell": "m.57.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "m.58.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "c.66.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "c.67.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "c.68.0",
     "changeType": "added",
     "index": 90
    },
    {
     "cell": "m.13.1",
     "changeType": "edited",
     "index": 23
    },
    {
     "cell": "m.14.1",
     "changeType": "edited",
     "index": 25
    }
   ]
  },
  {
   "timestamp": 1622209186075,
   "notebook": 48,
   "targetCells": [
    {
     "cell": "m.14.2",
     "changeType": "edited",
     "index": 25
    }
   ]
  },
  {
   "timestamp": 1622209235576,
   "notebook": 49,
   "targetCells": [
    {
     "cell": "m.14.3",
     "changeType": "edited",
     "index": 25
    },
    {
     "cell": "m.15.1",
     "changeType": "edited",
     "index": 27
    },
    {
     "cell": "m.16.1",
     "changeType": "edited",
     "index": 29
    }
   ]
  },
  {
   "timestamp": 1622209406266,
   "notebook": 50,
   "targetCells": [
    {
     "cell": "m.16.2",
     "changeType": "edited",
     "index": 29
    },
    {
     "cell": "c.21.1",
     "changeType": "edited",
     "output": [
      "o.58.0"
     ],
     "index": 30
    },
    {
     "cell": "m.17.1",
     "changeType": "edited",
     "index": 31
    }
   ]
  },
  {
   "timestamp": 1622209516136,
   "notebook": 51,
   "targetCells": [
    {
     "cell": "m.17.2",
     "changeType": "edited",
     "index": 31
    },
    {
     "cell": "m.18.1",
     "changeType": "edited",
     "index": 32
    }
   ]
  },
  {
   "timestamp": 1622209678258,
   "notebook": 52,
   "targetCells": [
    {
     "cell": "m.18.2",
     "changeType": "edited",
     "index": 32
    }
   ]
  },
  {
   "timestamp": 1622209719335,
   "notebook": 53,
   "targetCells": [
    {
     "cell": "m.18.3",
     "changeType": "edited",
     "index": 32
    },
    {
     "cell": "m.50.1",
     "changeType": "edited",
     "index": 34
    }
   ]
  },
  {
   "timestamp": 1622209870934,
   "notebook": 54,
   "targetCells": [
    {
     "cell": "m.50.2",
     "changeType": "edited",
     "index": 34
    },
    {
     "cell": "m.21.1",
     "changeType": "edited",
     "index": 39
    },
    {
     "cell": "c.24.1",
     "changeType": "edited",
     "output": [
      "o.59.0"
     ],
     "index": 40
    }
   ]
  },
  {
   "timestamp": 1622210144419,
   "notebook": 55,
   "targetCells": [
    {
     "cell": "c.24.2",
     "changeType": "edited",
     "output": [
      "o.60.0"
     ],
     "index": 40
    }
   ]
  },
  {
   "timestamp": 1622210151826,
   "notebook": 56,
   "targetCells": [
    {
     "cell": "c.24.3",
     "changeType": "edited",
     "output": [
      "o.61.0"
     ],
     "index": 40
    }
   ]
  },
  {
   "timestamp": 1622210205883,
   "notebook": 57,
   "targetCells": [
    {
     "cell": "c.24.4",
     "changeType": "edited",
     "output": [
      "o.62.0"
     ],
     "index": 40
    },
    {
     "cell": "m.22.1",
     "changeType": "edited",
     "index": 41
    },
    {
     "cell": "m.20.1",
     "changeType": "edited",
     "index": 37
    },
    {
     "cell": "c.25.1",
     "changeType": "edited",
     "output": [],
     "index": 42
    },
    {
     "cell": "m.23.1",
     "changeType": "edited",
     "index": 43
    }
   ]
  },
  {
   "timestamp": 1622210381391,
   "notebook": 58,
   "targetCells": [
    {
     "cell": "m.20.2",
     "changeType": "edited",
     "index": 37
    },
    {
     "cell": "m.23.2",
     "changeType": "edited",
     "index": 43
    },
    {
     "cell": "m.51.1",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210510241,
   "notebook": 59,
   "targetCells": [
    {
     "cell": "m.51.2",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210675867,
   "notebook": 60,
   "targetCells": [
    {
     "cell": "m.51.3",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210700458,
   "notebook": 61,
   "targetCells": [
    {
     "cell": "m.51.4",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210723976,
   "notebook": 62,
   "targetCells": [
    {
     "cell": "m.51.5",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210797522,
   "notebook": 63,
   "targetCells": [
    {
     "cell": "m.51.6",
     "changeType": "edited",
     "index": 45
    },
    {
     "cell": "m.25.1",
     "changeType": "edited",
     "index": 48
    },
    {
     "cell": "m.26.1",
     "changeType": "edited",
     "index": 50
    },
    {
     "cell": "c.13.2",
     "changeType": "output changed",
     "output": [
      "o.54.1"
     ],
     "index": 1
    },
    {
     "cell": "c.3.2",
     "changeType": "output changed",
     "output": [
      "o.63.0"
     ],
     "index": 5
    },
    {
     "cell": "c.7.1",
     "changeType": "output changed",
     "output": [
      "o.64.0"
     ],
     "index": 13
    },
    {
     "cell": "c.19.0",
     "changeType": "output changed",
     "output": [
      "o.17.1"
     ],
     "index": 26
    },
    {
     "cell": "c.20.1",
     "changeType": "edited",
     "output": [],
     "index": 28
    },
    {
     "cell": "c.25.1",
     "changeType": "output changed",
     "output": [
      "o.65.0"
     ],
     "index": 42
    },
    {
     "cell": "m.30.1",
     "changeType": "edited",
     "index": 52
    }
   ]
  },
  {
   "timestamp": 1622211105740,
   "notebook": 64,
   "targetCells": [
    {
     "cell": "m.30.2",
     "changeType": "edited",
     "index": 52
    },
    {
     "cell": "m.28.1",
     "changeType": "edited",
     "index": 54
    },
    {
     "cell": "c.30.1",
     "changeType": "edited",
     "output": [
      "o.66.0"
     ],
     "index": 55
    }
   ]
  },
  {
   "timestamp": 1622285607950,
   "notebook": 65,
   "targetCells": [
    {
     "cell": "c.69.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "c.70.0",
     "changeType": "added",
     "index": 53
    },
    {
     "cell": "c.71.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "c.72.0",
     "changeType": "added",
     "index": 90
    },
    {
     "cell": "m.31.1",
     "changeType": "edited",
     "index": 56
    },
    {
     "cell": "c.37.0",
     "changeType": "output changed",
     "output": [
      "o.34.1"
     ],
     "index": 61
    },
    {
     "cell": "c.61.0",
     "changeType": "output changed",
     "output": [
      "o.52.1"
     ],
     "index": 72
    },
    {
     "cell": "c.62.0",
     "changeType": "output changed",
     "output": [
      "o.67.0"
     ],
     "index": 84
    },
    {
     "cell": "c.63.0",
     "changeType": "output changed",
     "output": [
      "o.68.0"
     ],
     "index": 86
    },
    {
     "cell": "c.64.0",
     "changeType": "output changed",
     "output": [
      "o.69.0"
     ],
     "index": 88
    },
    {
     "cell": "c.35.1",
     "changeType": "edited",
     "output": [
      "o.70.0"
     ],
     "index": 57
    },
    {
     "cell": "m.32.1",
     "changeType": "edited",
     "index": 58
    }
   ]
  },
  {
   "timestamp": 1622285770045,
   "notebook": 66,
   "targetCells": [
    {
     "cell": "m.32.2",
     "changeType": "edited",
     "index": 58
    }
   ]
  },
  {
   "timestamp": 1622285787057,
   "notebook": 67,
   "targetCells": [
    {
     "cell": "m.32.3",
     "changeType": "edited",
     "index": 58
    },
    {
     "cell": "m.33.1",
     "changeType": "edited",
     "index": 60
    },
    {
     "cell": "c.71.0",
     "changeType": "removed",
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1622286007574,
   "notebook": 68,
   "targetCells": [
    {
     "cell": "m.34.2",
     "changeType": "edited",
     "index": 62
    },
    {
     "cell": "c.40.10",
     "changeType": "edited",
     "output": [
      "o.71.0"
     ],
     "index": 63
    }
   ]
  },
  {
   "timestamp": 1622286066819,
   "notebook": 69,
   "targetCells": [
    {
     "cell": "c.40.11",
     "changeType": "edited",
     "output": [
      "o.72.0"
     ],
     "index": 63
    },
    {
     "cell": "m.39.1",
     "changeType": "edited",
     "index": 64
    }
   ]
  },
  {
   "timestamp": 1622286097813,
   "notebook": 70,
   "targetCells": [
    {
     "cell": "m.39.2",
     "changeType": "edited",
     "index": 64
    },
    {
     "cell": "c.45.1",
     "changeType": "edited",
     "output": [
      "o.73.0"
     ],
     "index": 65
    }
   ]
  },
  {
   "timestamp": 1622286517509,
   "notebook": 71,
   "targetCells": [
    {
     "cell": "c.45.2",
     "changeType": "edited",
     "output": [],
     "index": 65
    }
   ]
  },
  {
   "timestamp": 1622286553284,
   "notebook": 72,
   "targetCells": [
    {
     "cell": "c.45.3",
     "changeType": "edited",
     "output": [
      "o.74.0"
     ],
     "index": 65
    },
    {
     "cell": "m.40.1",
     "changeType": "edited",
     "index": 66
    },
    {
     "cell": "c.46.1",
     "changeType": "edited",
     "output": [],
     "index": 67
    },
    {
     "cell": "m.41.1",
     "changeType": "edited",
     "index": 68
    }
   ]
  },
  {
   "timestamp": 1622286762980,
   "notebook": 73,
   "targetCells": [
    {
     "cell": "m.41.2",
     "changeType": "edited",
     "index": 68
    }
   ]
  },
  {
   "timestamp": 1622286789527,
   "notebook": 74,
   "targetCells": [
    {
     "cell": "m.41.3",
     "changeType": "edited",
     "index": 68
    }
   ]
  },
  {
   "timestamp": 1622286800210,
   "notebook": 75,
   "targetCells": [
    {
     "cell": "m.41.4",
     "changeType": "edited",
     "index": 68
    },
    {
     "cell": "m.52.1",
     "changeType": "edited",
     "index": 70
    }
   ]
  },
  {
   "timestamp": 1622286910420,
   "notebook": 76,
   "targetCells": [
    {
     "cell": "m.52.2",
     "changeType": "edited",
     "index": 70
    },
    {
     "cell": "c.61.1",
     "changeType": "edited",
     "output": [
      "o.75.0"
     ],
     "index": 71
    }
   ]
  },
  {
   "timestamp": 1622286961921,
   "notebook": 77,
   "targetCells": [
    {
     "cell": "c.61.2",
     "changeType": "edited",
     "output": [
      "o.76.0"
     ],
     "index": 71
    }
   ]
  },
  {
   "timestamp": 1622286964294,
   "notebook": 78,
   "targetCells": [
    {
     "cell": "c.61.2",
     "changeType": "output changed",
     "output": [
      "o.76.1"
     ],
     "index": 71
    }
   ]
  },
  {
   "timestamp": 1622287051823,
   "notebook": 79,
   "targetCells": [
    {
     "cell": "c.61.3",
     "changeType": "edited",
     "output": [
      "o.77.0"
     ],
     "index": 71
    }
   ]
  },
  {
   "timestamp": 1622289820200,
   "notebook": 80,
   "targetCells": [
    {
     "cell": "m.43.1",
     "changeType": "edited",
     "index": 72
    },
    {
     "cell": "c.49.1",
     "changeType": "edited",
     "output": [],
     "index": 73
    },
    {
     "cell": "m.44.1",
     "changeType": "edited",
     "index": 74
    }
   ]
  },
  {
   "timestamp": 1622290018952,
   "notebook": 81,
   "targetCells": [
    {
     "cell": "m.44.2",
     "changeType": "edited",
     "index": 74
    },
    {
     "cell": "m.46.1",
     "changeType": "edited",
     "index": 78
    },
    {
     "cell": "c.52.1",
     "changeType": "edited",
     "output": [],
     "index": 79
    },
    {
     "cell": "m.47.1",
     "changeType": "edited",
     "index": 80
    }
   ]
  },
  {
   "timestamp": 1622290123775,
   "notebook": 82,
   "targetCells": [
    {
     "cell": "m.47.2",
     "changeType": "edited",
     "index": 80
    },
    {
     "cell": "c.53.1",
     "changeType": "edited",
     "output": [
      "o.78.0"
     ],
     "index": 81
    }
   ]
  },
  {
   "timestamp": 1622290183581,
   "notebook": 83,
   "targetCells": [
    {
     "cell": "c.53.2",
     "changeType": "edited",
     "output": [
      "o.79.0"
     ],
     "index": 81
    }
   ]
  },
  {
   "timestamp": 1622290193733,
   "notebook": 84,
   "targetCells": [
    {
     "cell": "c.53.3",
     "changeType": "edited",
     "output": [
      "o.80.0"
     ],
     "index": 81
    }
   ]
  },
  {
   "timestamp": 1622290201805,
   "notebook": 85,
   "targetCells": [
    {
     "cell": "c.53.4",
     "changeType": "edited",
     "output": [],
     "index": 81
    }
   ]
  },
  {
   "timestamp": 1622290204256,
   "notebook": 86,
   "targetCells": [
    {
     "cell": "c.53.5",
     "changeType": "edited",
     "output": [
      "o.81.0"
     ],
     "index": 81
    },
    {
     "cell": "m.53.1",
     "changeType": "edited",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1622290261257,
   "notebook": 87,
   "targetCells": [
    {
     "cell": "m.53.2",
     "changeType": "edited",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1622290272824,
   "notebook": 88,
   "targetCells": [
    {
     "cell": "m.53.3",
     "changeType": "edited",
     "index": 82
    },
    {
     "cell": "c.62.0",
     "changeType": "output changed",
     "output": [
      "o.67.1"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290304056,
   "notebook": 89,
   "targetCells": [
    {
     "cell": "c.62.1",
     "changeType": "edited",
     "output": [
      "o.82.0"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290305955,
   "notebook": 90,
   "targetCells": [
    {
     "cell": "c.62.1",
     "changeType": "output changed",
     "output": [
      "o.82.1"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290337397,
   "notebook": 91,
   "targetCells": [
    {
     "cell": "c.62.2",
     "changeType": "edited",
     "output": [
      "o.83.0"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290370267,
   "notebook": 92,
   "targetCells": [
    {
     "cell": "c.62.3",
     "changeType": "edited",
     "output": [
      "o.84.0"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290408459,
   "notebook": 93,
   "targetCells": [
    {
     "cell": "c.62.4",
     "changeType": "edited",
     "output": [
      "o.85.0"
     ],
     "index": 83
    },
    {
     "cell": "m.54.1",
     "changeType": "edited",
     "index": 84
    }
   ]
  },
  {
   "timestamp": 1622290479536,
   "notebook": 94,
   "targetCells": [
    {
     "cell": "m.54.2",
     "changeType": "edited",
     "index": 84
    },
    {
     "cell": "c.63.1",
     "changeType": "edited",
     "output": [],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290541161,
   "notebook": 95,
   "targetCells": [
    {
     "cell": "c.63.1",
     "changeType": "output changed",
     "output": [
      "o.86.0"
     ],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290547559,
   "notebook": 96,
   "targetCells": [
    {
     "cell": "c.63.2",
     "changeType": "edited",
     "output": [],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290562913,
   "notebook": 97,
   "targetCells": [
    {
     "cell": "c.63.3",
     "changeType": "edited",
     "output": [
      "o.87.0"
     ],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290572241,
   "notebook": 98,
   "targetCells": [
    {
     "cell": "c.63.4",
     "changeType": "edited",
     "output": [
      "o.88.0"
     ],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290587221,
   "notebook": 99,
   "targetCells": [
    {
     "cell": "c.63.5",
     "changeType": "edited",
     "output": [
      "o.89.0"
     ],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290607436,
   "notebook": 100,
   "targetCells": [
    {
     "cell": "c.63.6",
     "changeType": "edited",
     "output": [],
     "index": 85
    },
    {
     "cell": "m.54.3",
     "changeType": "edited",
     "index": 84
    }
   ]
  },
  {
   "timestamp": 1622290655058,
   "notebook": 101,
   "targetCells": [
    {
     "cell": "c.63.7",
     "changeType": "edited",
     "output": [
      "o.90.0"
     ],
     "index": 85
    },
    {
     "cell": "m.55.1",
     "changeType": "edited",
     "index": 86
    }
   ]
  },
  {
   "timestamp": 1622290741126,
   "notebook": 102,
   "targetCells": [
    {
     "cell": "m.55.2",
     "changeType": "edited",
     "index": 86
    },
    {
     "cell": "m.56.1",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290867816,
   "notebook": 103,
   "targetCells": [
    {
     "cell": "m.56.2",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290882283,
   "notebook": 104,
   "targetCells": [
    {
     "cell": "m.56.3",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290897345,
   "notebook": 105,
   "targetCells": [
    {
     "cell": "m.56.4",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290907792,
   "notebook": 106,
   "targetCells": [
    {
     "cell": "m.56.5",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290917172,
   "notebook": 107,
   "targetCells": [
    {
     "cell": "m.56.6",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622291027879,
   "notebook": 108,
   "targetCells": [
    {
     "cell": "m.56.7",
     "changeType": "edited",
     "index": 88
    },
    {
     "cell": "c.73.0",
     "changeType": "added",
     "index": 89
    }
   ]
  },
  {
   "timestamp": 1622291059093,
   "notebook": 109,
   "targetCells": [
    {
     "cell": "c.73.1",
     "changeType": "edited",
     "output": [],
     "index": 89
    }
   ]
  },
  {
   "timestamp": 1622291067351,
   "notebook": 110,
   "targetCells": [
    {
     "cell": "c.73.2",
     "changeType": "edited",
     "output": [
      "o.91.0"
     ],
     "index": 89
    }
   ]
  },
  {
   "timestamp": 1622291072276,
   "notebook": 111,
   "targetCells": [
    {
     "cell": "c.73.2",
     "changeType": "removed",
     "index": 89
    },
    {
     "cell": "m.56.8",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622291555802,
   "notebook": 112,
   "targetCells": [
    {
     "cell": "m.56.9",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622291748840,
   "notebook": 113,
   "targetCells": [
    {
     "cell": "m.56.10",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622292522022,
   "notebook": 114,
   "targetCells": [
    {
     "cell": "m.56.11",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622292705723,
   "notebook": 115,
   "targetCells": [
    {
     "cell": "m.56.12",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622312494538,
   "notebook": 116,
   "targetCells": [
    {
     "cell": "c.74.0",
     "changeType": "added",
     "index": 69
    },
    {
     "cell": "c.75.0",
     "changeType": "added",
     "index": 87
    },
    {
     "cell": "c.76.0",
     "changeType": "added",
     "index": 89
    },
    {
     "cell": "m.31.2",
     "changeType": "edited",
     "index": 56
    }
   ]
  },
  {
   "timestamp": 1622312896740,
   "notebook": 117,
   "targetCells": [
    {
     "cell": "m.53.4",
     "changeType": "edited",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1622312964703,
   "notebook": 118,
   "targetCells": [
    {
     "cell": "m.53.5",
     "changeType": "edited",
     "index": 82
    },
    {
     "cell": "m.55.3",
     "changeType": "edited",
     "index": 86
    },
    {
     "cell": "m.56.13",
     "changeType": "edited",
     "index": 88
    },
    {
     "cell": "m.38.4",
     "changeType": "edited",
     "index": 0
    }
   ]
  },
  {
   "timestamp": 1622313227273,
   "notebook": 119,
   "targetCells": [
    {
     "cell": "m.38.5",
     "changeType": "edited",
     "index": 0
    }
   ]
  },
  {
   "timestamp": 1622313230222,
   "notebook": 120,
   "targetCells": [
    {
     "cell": "m.38.6",
     "changeType": "edited",
     "index": 0
    },
    {
     "cell": "c.77.0",
     "changeType": "added",
     "index": 1
    }
   ]
  },
  {
   "timestamp": 1622445305424,
   "notebook": 121,
   "targetCells": [
    {
     "cell": "m.59.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "m.60.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.61.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "m.62.0",
     "changeType": "added",
     "index": 5
    },
    {
     "cell": "m.63.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "m.64.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "m.65.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "m.66.0",
     "changeType": "added",
     "index": 22
    },
    {
     "cell": "m.67.0",
     "changeType": "added",
     "index": 26
    },
    {
     "cell": "m.68.0",
     "changeType": "added",
     "index": 33
    },
    {
     "cell": "m.69.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "m.70.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "m.71.0",
     "changeType": "added",
     "index": 40
    },
    {
     "cell": "m.72.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "m.73.0",
     "changeType": "added",
     "index": 46
    },
    {
     "cell": "m.74.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "m.75.0",
     "changeType": "added",
     "index": 51
    },
    {
     "cell": "m.76.0",
     "changeType": "added",
     "index": 55
    },
    {
     "cell": "m.77.0",
     "changeType": "added",
     "index": 57
    },
    {
     "cell": "c.78.0",
     "changeType": "added",
     "index": 58
    },
    {
     "cell": "m.78.0",
     "changeType": "added",
     "index": 59
    },
    {
     "cell": "m.79.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "m.80.0",
     "changeType": "added",
     "index": 65
    },
    {
     "cell": "m.81.0",
     "changeType": "added",
     "index": 67
    },
    {
     "cell": "m.82.0",
     "changeType": "added",
     "index": 71
    },
    {
     "cell": "m.83.0",
     "changeType": "added",
     "index": 73
    },
    {
     "cell": "m.84.0",
     "changeType": "added",
     "index": 75
    },
    {
     "cell": "m.85.0",
     "changeType": "added",
     "index": 77
    },
    {
     "cell": "m.86.0",
     "changeType": "added",
     "index": 79
    },
    {
     "cell": "m.87.0",
     "changeType": "added",
     "index": 83
    },
    {
     "cell": "m.88.0",
     "changeType": "added",
     "index": 85
    },
    {
     "cell": "m.89.0",
     "changeType": "added",
     "index": 91
    },
    {
     "cell": "m.90.0",
     "changeType": "added",
     "index": 92
    },
    {
     "cell": "c.79.0",
     "changeType": "added",
     "index": 93
    }
   ]
  },
  {
   "timestamp": 1622445448043,
   "notebook": 122,
   "targetCells": [
    {
     "cell": "c.78.1",
     "changeType": "edited",
     "output": [
      "o.95.0"
     ],
     "index": 58
    },
    {
     "cell": "c.80.0",
     "changeType": "added",
     "index": 65
    }
   ]
  }
 ],
 "notebook": {
  "artifact_name": "n.0",
  "versions": [
   {
    "start_checkpoint": 1619004012983,
    "cells": [
     "m.0.0",
     "c.0.0"
    ]
   },
   {
    "start_checkpoint": 1619166384323,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619166409884,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.0",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167416345,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.1",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167430512,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.2",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167469117,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.2",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167519480,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.3",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167525913,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.12.4",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619273398309,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.19.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.27.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.10.0",
     "c.31.0"
    ]
   },
   {
    "start_checkpoint": 1619273440670,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.19.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.27.0",
     "c.29.0",
     "c.32.0",
     "m.28.0",
     "c.30.0",
     "m.10.0",
     "c.31.0"
    ]
   },
   {
    "start_checkpoint": 1619273462931,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.19.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.27.0",
     "c.29.0",
     "c.32.1",
     "m.28.0",
     "c.30.0",
     "m.10.0",
     "c.31.0"
    ]
   },
   {
    "start_checkpoint": 1619344122936,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344680409,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.0",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344804639,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.1",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344843467,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.2",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344920701,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.3",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344948011,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.4",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344965296,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.5",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344997121,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.6",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619345039116,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.7",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619345077293,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.8",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619345085096,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.1",
     "c.40.9",
     "c.41.0",
     "c.42.0",
     "c.43.0",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619427664533,
    "cells": [
     "m.38.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.44.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.42.0",
     "c.48.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.37.0",
     "c.54.0"
    ]
   },
   {
    "start_checkpoint": 1619427699980,
    "cells": [
     "m.38.1",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.44.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.42.0",
     "c.48.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.37.0",
     "c.54.0"
    ]
   },
   {
    "start_checkpoint": 1619530334504,
    "cells": [
     "m.38.1",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.55.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.42.0",
     "c.48.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.37.0",
     "c.56.0"
    ]
   },
   {
    "start_checkpoint": 1622203535195,
    "cells": [
     "m.38.1",
     "c.13.0",
     "m.48.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622203932351,
    "cells": [
     "m.38.2",
     "c.13.0",
     "m.48.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622203944610,
    "cells": [
     "m.38.3",
     "c.13.1",
     "m.48.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204008193,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.1",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204182191,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.1",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204322287,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.1",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204355567,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.2",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204374734,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.3",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204384000,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.4",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204391516,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.5",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204421079,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.6",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204433050,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.7",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204441673,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.8",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204457914,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.1",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204477080,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.2",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204494036,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.3",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204513712,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.4",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204534951,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204907095,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.1",
     "m.8.0",
     "c.8.1",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622205474347,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.1",
     "m.8.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.16.0",
     "m.12.1",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622205682750,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.1",
     "m.8.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.16.0",
     "m.12.2",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622205747266,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.1",
     "m.8.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.16.0",
     "m.12.3",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622208996780,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.1",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209186075,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.2",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209235576,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.1",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209406266,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.1",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209516136,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.1",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209678258,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.2",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209719335,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.1",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209870934,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.1",
     "c.24.1",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210144419,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.1",
     "c.24.2",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210151826,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.1",
     "c.24.3",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210205883,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.1",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.1",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210381391,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.1",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210510241,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.2",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210675867,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.3",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210700458,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.4",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210723976,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.5",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210797522,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.27.0",
     "m.26.1",
     "c.28.0",
     "m.30.1",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622211105740,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.27.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.29.0",
     "m.28.1",
     "c.30.1",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622285607950,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.1",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.71.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622285770045,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.2",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.71.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622285787057,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286007574,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.10",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286066819,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.1",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286097813,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.1",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286517509,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.2",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286553284,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.1",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286762980,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.2",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286789527,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.3",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286800210,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.1",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286910420,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.1",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286961921,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.2",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286964294,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.2",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622287051823,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622289820200,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.1",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290018952,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.1",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290123775,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.1",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290183581,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.2",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290193733,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.3",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290201805,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.4",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290204256,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.1",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290261257,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.2",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290272824,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290304056,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.1",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290305955,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.1",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290337397,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.2",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290370267,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.3",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290408459,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.1",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290479536,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.1",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290541161,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.1",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290547559,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.2",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290562913,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.3",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290572241,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.4",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290587221,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.5",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290607436,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.6",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290655058,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.1",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290741126,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.1",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290867816,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.2",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290882283,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.3",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290897345,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.4",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290907792,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.5",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290917172,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.6",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291027879,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.7",
     "c.73.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291059093,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.7",
     "c.73.1",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291067351,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.7",
     "c.73.2",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291072276,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.8",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291555802,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.9",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291748840,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.10",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622292522022,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.11",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622292705723,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.12",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622312494538,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.75.0",
     "m.56.12",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622312896740,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.4",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.75.0",
     "m.56.12",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622312964703,
    "cells": [
     "m.38.4",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.5",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.56.13",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622313227273,
    "cells": [
     "m.38.5",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.5",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.56.13",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622313230222,
    "cells": [
     "m.38.6",
     "c.77.0",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.5",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.56.13",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622445305424,
    "cells": [
     "m.59.0",
     "m.60.0",
     "c.13.2",
     "m.61.0",
     "c.2.0",
     "m.62.0",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.63.0",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.64.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.65.0",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.66.0",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.67.0",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.68.0",
     "c.22.0",
     "m.69.0",
     "c.33.0",
     "c.34.0",
     "m.70.0",
     "c.57.0",
     "m.71.0",
     "c.24.4",
     "m.72.0",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.73.0",
     "c.58.0",
     "c.59.0",
     "m.74.0",
     "c.69.0",
     "m.75.0",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.76.0",
     "c.30.1",
     "m.77.0",
     "c.78.0",
     "m.78.0",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.79.0",
     "c.37.0",
     "m.80.0",
     "c.40.11",
     "m.81.0",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.82.0",
     "c.74.0",
     "m.83.0",
     "c.61.3",
     "m.84.0",
     "c.49.1",
     "m.85.0",
     "c.50.0",
     "m.86.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.87.0",
     "c.53.5",
     "m.88.0",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.89.0",
     "m.90.0",
     "c.79.0"
    ]
   },
   {
    "start_checkpoint": 1622445448043,
    "cells": [
     "m.59.0",
     "m.60.0",
     "c.13.2",
     "m.61.0",
     "c.2.0",
     "m.62.0",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.63.0",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.64.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.65.0",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.66.0",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.67.0",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.68.0",
     "c.22.0",
     "m.69.0",
     "c.33.0",
     "c.34.0",
     "m.70.0",
     "c.57.0",
     "m.71.0",
     "c.24.4",
     "m.72.0",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.73.0",
     "c.58.0",
     "c.59.0",
     "m.74.0",
     "c.69.0",
     "m.75.0",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.76.0",
     "c.30.1",
     "m.77.0",
     "c.78.1",
     "m.78.0",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.79.0",
     "c.37.0",
     "c.80.0",
     "m.80.0",
     "c.40.11",
     "m.81.0",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.82.0",
     "c.74.0",
     "m.83.0",
     "c.61.3",
     "m.84.0",
     "c.49.1",
     "m.85.0",
     "c.50.0",
     "m.86.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.87.0",
     "c.53.5",
     "m.88.0",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.89.0",
     "m.90.0",
     "c.79.0"
    ]
   }
  ]
 },
 "codeCells": [
  {
   "output_histories": {},
   "artifact_name": "c.0",
   "versions": [
    {
     "start_checkpoint": 1619004012983,
     "parent": "n.0.0",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.0"
   },
   "artifact_name": "c.1",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "literal": "class Person (val name: String, var alter: Int)\n\nval p1 = Person(\"Max Mustermann\", 21)\nprintln(\"Person 1, $p1: \\nName: ${p1.name}, Alter: ${p1.alter}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 63
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.1"
   },
   "artifact_name": "c.2",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.121",
     "literal": "class Auto (\n    val marke: String, //Es wird ein Feld mit dem Namen marke und ein Getter hinzugefügt und bei Erzeugung mit dem übergebenen Wert gefüllt.\n    var farbe: String, //Es wird ein Feld mit dem Namen farbe und einem Getter sowie Setter hinzugefügt und bei Erzeugung mit dem übergebenen Wert gefüllt.\n    ps: Int //Dies ist lediglich ein Übergabeparameter, der im Konstruktor verwendet werden kann.\n)\n\nval a1 = Auto (\"BMW\", \"Gelb\", 220)\nprintln(\"Marke von a1: ${a1.marke}, Farbe von a1: ${a1.farbe}.\") //Benutzung der Getter von marke und farbe\n//println(a1.ps) -> Error, da ps kein Feld sondern nur ein Übergabeparameter ist\n//a1.marke = \"Audi\" -> Error, da das Feld marke nicht verändert werden kann und auch keinen Setter besitzt\na1.farbe = \"Rot\" //Aufruf des Setters von farbe. Das Feld farbe kann verändert werden, da ein Setter vorhanden ist und das Feld den Typ var besitzt\nprintln(\"Farbe von a1 nach Umlackierung: ${a1.farbe}.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 54
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.2",
    "1": "o.55",
    "2": "o.63"
   },
   "artifact_name": "c.3",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "literal": "class Computer (){\n    val marke: String = \"Fuhitsu\"\n    var istAn: Boolean = false\n}\n\nval c1 = Computer ()\nprintln(\"Marke von c1: ${c1.marke}, ist c1 an?: ${c1.istAn}.\") //Benutzung der Getter von marke und istAn\n// c1.marke = \"LD\" -> Error, da das Feld marke nicht verändert werden kann und auch keinen Setter besitzt\nc1.istAn = true //Aufruf des Setters von istAn. Das Feld istAn kann verändert werden, da ein Setter vorhanden ist und das Feld den Typ var besitzt\nprintln(\"ist c1 an?: ${c1.istAn}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 33
     }
    },
    {
     "start_checkpoint": 1622204182191,
     "parent": "n.0.29",
     "literal": "class Computer (){\n    val marke: String = \"Fuhitsu\"\n    var istAn: Boolean = false\n}\n\nval c1 = Computer ()\nprintln(\"Marke von c1: ${c1.marke}, ist c1 an?: ${c1.istAn}.\") //Benutzung der Getter von marke und istAn\n// c1.marke = \"LD\" -> Error, da das Feld marke nicht verändert werden kann und auch keinen Setter besitzt\nc1.istAn = true //Aufruf des Setters von istAn. Das Feld istAn kann verändert werden, da ein Setter vorhanden ist und das Feld den Typ var besitzt\nprintln(\"Ist c1 an?: ${c1.istAn}\")"
    },
    {
     "start_checkpoint": 1622204322287,
     "parent": "n.0.121",
     "literal": "class Computer (){\n    val marke: String = \"Fuhitsu\"\n    var istAn: Boolean = false\n}\n\nval c1 = Computer ()\nprintln(\"Marke von c1: ${c1.marke}, ist c1 an?: ${c1.istAn}.\") //Benutzung der Getter von marke und istAn\n//c1.marke = \"LD\" -> Error, da das Feld marke nicht verändert werden kann und keinen Setter besitzt\nc1.istAn = true //Aufruf des Setters von istAn. Das Feld istAn kann verändert werden, da ein Setter vorhanden und das Feld vom Typ var ist\nprintln(\"Ist c1 an?: ${c1.istAn}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.3"
   },
   "artifact_name": "c.4",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.121",
     "literal": "class Flasche (val farbe: String, var füllung: Int)\nval f1 = Flasche (\"Grau\", 20)\nprintln(\"Die Flasche mit der Farbe ${f1.farbe} ist zu ${f1.füllung}% gefüllt.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 78
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.4"
   },
   "artifact_name": "c.5",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.121",
     "literal": "class Bett (\n    laenge: Int, breite: Int, belegt: Boolean //Übergabeparameter bei Objekterzeugung. Können im init-Block verwendet werden.\n){\n    val laenge: Int\n    val breite: Int\n    var belegt: Boolean\n    \n    init { //primärer Konstruktor mit init-Block. In diesem kann auf die Parameter zugegriffen werden.\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.belegt = belegt\n    }\n}\nval b1 = Bett (160, 200, false)\nval b2 = Bett (-100, 50, true)\nprintln(\"Bett b1: Länge ${b1.laenge}, Breite ${b1.breite}, belegt ${b1.belegt}\")\nprintln(\"Bett b2: Länge ${b2.laenge}, Breite ${b2.breite}, belegt ${b2.belegt}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 16,
      "ch": 79
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.5"
   },
   "artifact_name": "c.6",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.121",
     "literal": "class Tisch (\n    laenge: Int, breite: Int, farbe: String //Übergabeparameter bei Objekterzeugung. Können den Feldern direkt zugewiesen werden.\n){\n    val laenge: Int = if (laenge > 0) laenge else 0\n    val breite = if (breite > 0) breite else 0 //Kurzschreibweise ist zulässig. Dabei wird der Datentyp des Parameters übernommen\n    var farbe: String = farbe\n}\n\nval t1 = Tisch (100, 100, \"Braun\")\nval t2 = Tisch (-100, 50, \"Weiß\")\nprintln(\"Tisch t1: Länge ${t1.laenge}, Breite ${t1.breite}, Farbe ${t1.farbe}\")\nprintln(\"Tisch t2: Länge ${t2.laenge}, Breite ${t2.breite}, Farbe ${t2.farbe}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 78
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.6",
    "1": "o.64"
   },
   "artifact_name": "c.7",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "literal": "class Stuhl (laenge: Int, breite: Int, var belegt: Boolean){\n    val laenge = if (laenge > 0) laenge else 0\n    val breite: Int\n    \n    init {\n        this.breite = if (breite > 0) breite else 0\n    }\n}\nval s1 = Stuhl (20, 20, true)\nval s2 = Stuhl (-20, 30, false)\nprintln(\"Stuhl s1: Länge ${s1.laenge}, Breite ${s1.breite}, belegt ${s1.belegt}\")\nprintln(\"Stuhl s2: Länge ${s2.laenge}, Breite ${s2.breite}, belegt ${s2.belegt}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 80
     }
    },
    {
     "start_checkpoint": 1622204907095,
     "parent": "n.0.121",
     "literal": "class Stuhl (laenge: Int, breite: Int, var belegt: Boolean){ //belegt: Defaultkonstruktor\n    val laenge = if (laenge > 0) laenge else 0 //laenge: direkte Zuweisung\n    val breite: Int\n\n    init { //breite: init-Block\n        this.breite = if (breite > 0) breite else 0\n    }\n}\n\nval s1 = Stuhl (20, 20, true)\nval s2 = Stuhl (-20, 30, false)\nprintln(\"Stuhl s1: Länge ${s1.laenge}, Breite ${s1.breite}, belegt ${s1.belegt}\")\nprintln(\"Stuhl s2: Länge ${s2.laenge}, Breite ${s2.breite}, belegt ${s2.belegt}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.7",
    "1": "o.56"
   },
   "artifact_name": "c.8",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "literal": "class Fenster { //Parameterklammern fehlen\n    val laenge: Int\n    val breite: Int\n    var zustand: String\n    \n    //Konstruktor eines normalen Fensters\n    constructor (laenge: Int, breite: Int, zustand: String){\n        println(\"Konstruktor eines normalen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.zustand = zustand\n    }\n    //Konstruktor eines quadratischen Fensters\n    constructor (laenge: Int, zustand: String){\n        println(\"Konstruktor eines quadratischen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = laenge\n        this.zustand = zustand\n    }\n    //Konstruktor eines neuen Fensters\n    constructor (laenge: Int, breite: Int){\n        println(\"Konstruktor eines neuen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.zustand = \"Neu\"\n    }\n}\n\nval fensterNormal = Fenster (50, -80, \"Gebraucht\")\nprintln(\"Fenster fensterNormal: Länge ${fensterNormal.laenge}, Breite ${fensterNormal.breite}, Zustand ${fensterNormal.zustand} \\n\")\nval fensterQuadrat = Fenster (60, \"Schmutzig\")\nprintln(\"Fenster fensterQuadrat: Länge ${fensterQuadrat.laenge}, Breite ${fensterQuadrat.breite}, Zustand ${fensterQuadrat.zustand} \\n\")\nval fensterNeu = Fenster (100, 120)\nprintln(\"Fenster fensterNeu: Länge ${fensterNeu.laenge}, Breite ${fensterNeu.breite}, Zustand ${fensterNeu.zustand}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 33,
      "ch": 116
     }
    },
    {
     "start_checkpoint": 1622204907095,
     "parent": "n.0.121",
     "literal": "class Fenster { //Parameterklammern fehlen\n    val laenge: Int\n    val breite: Int\n    var zustand: String\n    \n    //Konstruktor eines normalen Fensters\n    constructor (laenge: Int, breite: Int, zustand: String){\n        println(\"Konstruktion eines normalen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.zustand = zustand\n    }\n    //Konstruktor eines quadratischen Fensters\n    constructor (laenge: Int, zustand: String){\n        println(\"Konstruktion eines quadratischen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = laenge\n        this.zustand = zustand\n    }\n    //Konstruktor eines neuen Fensters\n    constructor (laenge: Int, breite: Int){\n        println(\"Konstruktion eines neuen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.zustand = \"Neu\"\n    }\n}\n\nval fensterNormal = Fenster (50, -80, \"Gebraucht\")\nprintln(\"Fenster fensterNormal: Länge ${fensterNormal.laenge}, Breite ${fensterNormal.breite}, Zustand ${fensterNormal.zustand} \\n\")\nval fensterQuadrat = Fenster (60, \"Schmutzig\")\nprintln(\"Fenster fensterQuadrat: Länge ${fensterQuadrat.laenge}, Breite ${fensterQuadrat.breite}, Zustand ${fensterQuadrat.zustand} \\n\")\nval fensterNeu = Fenster (100, 120)\nprintln(\"Fenster fensterNeu: Länge ${fensterNeu.laenge}, Breite ${fensterNeu.breite}, Zustand ${fensterNeu.zustand}\")"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.9",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.10",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.11",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "1": "o.8",
    "2": "o.9",
    "4": "o.10"
   },
   "artifact_name": "c.12",
   "versions": [
    {
     "start_checkpoint": 1619166409884,
     "parent": "n.0.2",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1619167416345,
     "parent": "n.0.3",
     "literal": "//primärer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundärer Konstruktor: Neue Batterie mit Angabe von Kapazität und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\")\n    //sekundärer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false, 0, \"Neu\")\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\")\nprintln(\"Batterie eigeneBatterie: Kapazität ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}\")\nval neueBatterie = Batterie(3000, false)\nprintln(\"Batterie neueBatterie: Kapazität ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}\")\nval BBBatterie = Batterie()\nprintln(\"Batterie BBBatterie: Kapazität ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}\")"
    },
    {
     "start_checkpoint": 1619167430512,
     "parent": "n.0.4",
     "literal": "//primärer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundärer Konstruktor: Neue Batterie mit Angabe von Kapazität und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\")\n    //sekundärer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false)\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\")\nprintln(\"Batterie eigeneBatterie: Kapazität ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}\")\nval neueBatterie = Batterie(3000, false)\nprintln(\"Batterie neueBatterie: Kapazität ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}\")\nval BBBatterie = Batterie()\nprintln(\"Batterie BBBatterie: Kapazität ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}\")"
    },
    {
     "start_checkpoint": 1619167519480,
     "parent": "n.0.6",
     "literal": "//primärer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundärer Konstruktor: Neue Batterie mit Angabe von Kapazität und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\") //Benutzt den primären Konstruktor\n    //sekundärer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false) //Benutzt den anderen sekundären Konstruktor\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\") //primärer Konstruktor\nprintln(\"Batterie eigeneBatterie: Kapazität ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}\")\nval neueBatterie = Batterie(3000, false) //sekundärer Konstruktor: Neue Batterie mit Angabe von Kapazität und Wiederaufladbarkeit\nprintln(\"Batterie neueBatterie: Kapazität ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}\")\nval BBBatterie = Batterie() //sekundärer Konstruktor: Neue BB Einmalbatterie\nprintln(\"Batterie BBBatterie: Kapazität ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}\")"
    },
    {
     "start_checkpoint": 1619167525913,
     "parent": "n.0.7",
     "literal": "//primärer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundärer Konstruktor: Neue Batterie mit Angabe von Kapazität und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\") //Benutzt den primären Konstruktor\n    //sekundärer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false) //Benutzt den anderen sekundären Konstruktor\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\") //primärer Konstruktor\nprintln(\"Batterie eigeneBatterie: Kapazität ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}.\")\nval neueBatterie = Batterie(3000, false) //sekundärer Konstruktor: Neue Batterie mit Angabe von Kapazität und Wiederaufladbarkeit\nprintln(\"Batterie neueBatterie: Kapazität ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}.\")\nval BBBatterie = Batterie() //sekundärer Konstruktor: Neue BB Einmalbatterie\nprintln(\"Batterie BBBatterie: Kapazität ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}.\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.11",
    "1": "o.53",
    "2": "o.54"
   },
   "artifact_name": "c.13",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.25",
     "literal": "class Person (val name: String, var alter: Int)\n\nval p1 = Person(\"Max Mustermann\", 21)\nprintln(\"Person p1, $p1: \\nName: ${p1.name}, Alter: ${p1.alter}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 64
     }
    },
    {
     "start_checkpoint": 1622203944610,
     "parent": "n.0.27",
     "literal": "class Person (val name: String, var alter: Int)\n\nval p1 = Person(\"Max Mustermann\", 21)\nprintln(\"Person p1: $p1\\nName: ${p1.name}, Alter: ${p1.alter}\")"
    },
    {
     "start_checkpoint": 1622204008193,
     "parent": "n.0.121",
     "literal": "class Person (val name: String, var alter: Int)\n\nval p1 = Person(\"Max Mustermann\", 21)\nprintln(\"Person p1: $p1\")\nprintln(\"Name: ${p1.name}, Alter: ${p1.alter}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.12"
   },
   "artifact_name": "c.14",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "//primärer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundärer Konstruktor: Neue Batterie mit Angabe von Kapazität und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\") //Benutzt den primären Konstruktor\n    //sekundärer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false) //Benutzt den anderen sekundären Konstruktor\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\") //primärer Konstruktor\nprintln(\"Batterie eigeneBatterie: Kapazität ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}\")\nval neueBatterie = Batterie(3000, false) //sekundärer Konstruktor: Neue Batterie mit Angabe von Kapazität und Wiederaufladbarkeit\nprintln(\"Batterie neueBatterie: Kapazität ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}\")\nval BBBatterie = Batterie() //sekundärer Konstruktor: Neue BB Einmalbatterie\nprintln(\"Batterie BBBatterie: Kapazität ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 178
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.13"
   },
   "artifact_name": "c.15",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "//TODO\n\n//Tests\nvar fehler = 0\nval test1 = Pizza(25, listOf(\"Schinken\"), false)\nif( test1.groeße != 25 || test1.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test1.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 1! Richtig wäre: Größe 25, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test1.groeße}, Beläge ${test1.belaege}, Geschnitten ${test1.geschnitten}\")\n}\nval test2 = Pizza(31, listOf(\"Schinken\"), false)\nif( test2.groeße != -1 || test2.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test2.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 2! Richtig wäre: Größe -1, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test2.groeße}, Beläge ${test2.belaege}, Geschnitten ${test2.geschnitten}\")\n}\nval test3 = Pizza(14, listOf(\"Schinken\"), false)\nif( test3.groeße != -1 || test3.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test3.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 3! Richtig wäre: Größe -1, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test3.groeße}, Beläge ${test3.belaege}, Geschnitten ${test3.geschnitten}\")\n}\nval test4 = Pizza(31, listOf(\"Schinken\"), false)\nif( test4.groeße != -1 || test4.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test4.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 4! Richtig wäre: Größe -1, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test4.groeße}, Beläge ${test4.belaege}, Geschnitten ${test4.geschnitten}\")\n}\nval test5 = Pizza(28, emptyList(), true)\nif( test5.groeße != 28 || test5.belaege != listOf(\"Tomatensoße\", \"Mozzarella\") || test5.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 5! Richtig wäre: Größe 28, Beläge [Tomatensoße, Mozzarella], Geschnitten true \\n  Ist: Größe ${test5.groeße}, Beläge ${test5.belaege}, Geschnitten ${test5.geschnitten}\")\n}\nval test6 = Pizza(15)\nif( test6.groeße != 15 || test6.belaege != listOf(\"Tomatensoße\", \"Mozzarella\") || test6.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 6! Richtig wäre: Größe 15, Beläge [Tomatensoße, Mozzarella], Geschnitten true \\n  Ist: Größe ${test6.groeße}, Beläge ${test6.belaege}, Geschnitten ${test6.geschnitten}\")\n}\nval test7 = Pizza()\nif( test7.groeße != 25 || test7.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Thunfisch\", \"Zwiebeln\", \"Peperoni\") || test7.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 7! Richtig wäre: Größe 25, Beläge [Tomatensoße, Mozzarella, Thunfisch, Zwiebeln, Peperoni], Geschnitten false \\n  Ist: Größe ${test7.groeße}, Beläge ${test7.belaege}, Geschnitten ${test7.geschnitten}\")\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 42,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.14"
   },
   "artifact_name": "c.16",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.25",
     "literal": "//Lösung\nclass Pizza (groeße: Int, belaege: List<String>, geschnitten: Boolean){\n    val groeße: Int\n    val belaege: MutableList<String>\n    val geschnitten: Boolean\n    \n    init {\n        this.groeße = if (15 <= groeße && groeße <= 30) groeße else -1\n        this.belaege = mutableListOf(\"Tomatensoße\", \"Mozzarella\")\n        this.belaege += belaege\n        this.geschnitten = geschnitten\n    }\n    \n    constructor (groeße: Int) : this(groeße, emptyList(), true)\n    constructor () : this(25, listOf(\"Thunfisch\", \"Zwiebeln\", \"Peperoni\"), true)\n}\n\n//Tests\nvar fehler = 0\nval test1 = Pizza(25, listOf(\"Schinken\"), false)\nif( test1.groeße != 25 || test1.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test1.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 1! Richtig wäre: Größe 25, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test1.groeße}, Beläge ${test1.belaege}, Geschnitten ${test1.geschnitten}\")\n}\nval test2 = Pizza(31, listOf(\"Schinken\"), false)\nif( test2.groeße != -1 || test2.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test2.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 2! Richtig wäre: Größe -1, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test2.groeße}, Beläge ${test2.belaege}, Geschnitten ${test2.geschnitten}\")\n}\nval test3 = Pizza(14, listOf(\"Schinken\"), false)\nif( test3.groeße != -1 || test3.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test3.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 3! Richtig wäre: Größe -1, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test3.groeße}, Beläge ${test3.belaege}, Geschnitten ${test3.geschnitten}\")\n}\nval test4 = Pizza(31, listOf(\"Schinken\"), false)\nif( test4.groeße != -1 || test4.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test4.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 4! Richtig wäre: Größe -1, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test4.groeße}, Beläge ${test4.belaege}, Geschnitten ${test4.geschnitten}\")\n}\nval test5 = Pizza(28, emptyList(), true)\nif( test5.groeße != 28 || test5.belaege != listOf(\"Tomatensoße\", \"Mozzarella\") || test5.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 5! Richtig wäre: Größe 28, Beläge [Tomatensoße, Mozzarella], Geschnitten true \\n  Ist: Größe ${test5.groeße}, Beläge ${test5.belaege}, Geschnitten ${test5.geschnitten}\")\n}\nval test6 = Pizza(15)\nif( test6.groeße != 15 || test6.belaege != listOf(\"Tomatensoße\", \"Mozzarella\") || test6.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 6! Richtig wäre: Größe 15, Beläge [Tomatensoße, Mozzarella], Geschnitten true \\n  Ist: Größe ${test6.groeße}, Beläge ${test6.belaege}, Geschnitten ${test6.geschnitten}\")\n}\nval test7 = Pizza()\nif( test7.groeße != 25 || test7.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Thunfisch\", \"Zwiebeln\", \"Peperoni\") || test7.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 7! Richtig wäre: Größe 25, Beläge [Tomatensoße, Mozzarella, Thunfisch, Zwiebeln, Peperoni], Geschnitten false \\n  Ist: Größe ${test7.groeße}, Beläge ${test7.belaege}, Geschnitten ${test7.geschnitten}\")\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 57,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.15"
   },
   "artifact_name": "c.17",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name: String = name\n        get() = \"Name: $field\" //Wird auf das Feld name zugegeriffen, wird der String \"Name: name\" zurückgegeben\n        //Kein Setter möglich, da val\n    var alter = if (alter > 0) alter else -1\n        get() = field //Standardgetter\n        set(value){ //Eigener Setter. Der neue Wert wird in value gespeichert\n            field = if (value > field) value else field //Das Feld wird auf den neuen Wert gesetzt, falls dieser größer als der Aktuelle ist.\n        }\n}\nval p1 = Person (\"Max Mustermann\", -10)\nprintln(\"Person p1: ${p1.name}, Alter ${p1.alter}\")\np1.alter = 21\nprintln(\"Person p1: ${p1.name}, Alter ${p1.alter}\")\np1.alter = -10\nprintln(\"Person p1: ${p1.name}, Alter ${p1.alter}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 15,
      "ch": 50
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.16"
   },
   "artifact_name": "c.18",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name: String = name\n        get() = \"Name: $field\" //Wird auf das Feld name zugegeriffen, wird der String \"Name: name\" zurückgegeben\n        //Kein Setter möglich, da val\n    var alter = if (alter > 0) alter else -1\n        get() = field //Standardgetter\n        set(value){ //Eigener Setter. Der neue Wert wird in value gespeichert\n            field = if (value > field) value else field //Das Feld wird auf den neuen Wert gesetzt, falls dieser größer als der Aktuelle ist.\n        }\n    val istVolljaerig //Datentyp Boolean aus dem Getter\n        get() = alter > 17\n}\nval p1 = Person (\"Max Mustermann\", 21)\nprintln(\"Person p1: ${p1.name}, Alter ${p1.alter}, Volljährig ${p1.istVolljaerig}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 13,
      "ch": 82
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.17"
   },
   "artifact_name": "c.19",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    val istVolljaehrig: Boolean by lazy {\n        println(\"Wird berechnet...\")\n        alter > 18\n    }\n}\nval p1 = Person(\"Erika Musterfrau\", 32)\nprintln(p1.istVolljaehrig)\nprintln(p1.istVolljaehrig)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 25
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.18"
   },
   "artifact_name": "c.20",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    lateinit var istVolljaehrig: String\n    \n    fun berechneIstVolljaehrig(){\n        istVolljaehrig = if (alter > 17) \"Volljährig\" else \"Nicht Volljährig\"\n    }\n}\nval p1 = Person (\"Max Mustermann\", 30)\n//println(p1.istVolljaehrig) //Error: UninitializedPropertyAccessException: lateinit property istVolljaehrig has not been initialized\np1.berechneIstVolljaehrig() //istVolljaehrig wird berechnet\nprintln(p1.istVolljaehrig)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 25
     }
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    lateinit var istVolljaehrig: String //istVolljaehrig wird nicht bei Objekterzeugung berechnet\n    \n    fun berechneIstVolljaehrig() { //Diese Methode berechnet den Wert des Feldes istVolljaehrig\n        istVolljaehrig = if (alter > 17) \"Volljährig\" else \"Nicht Volljährig\"\n    }\n}\nval p1 = Person (\"Max Mustermann\", 30)\n//println(p1.istVolljaehrig) -> Fehler: UninitializedPropertyAccessException: lateinit property istVolljaehrig has not been initialized\np1.berechneIstVolljaehrig() //istVolljaehrig wird berechnet\nprintln(p1.istVolljaehrig)"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.19",
    "1": "o.58"
   },
   "artifact_name": "c.21",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    lateinit var istVolljaehrig: String\n    \n    fun berechneIstVolljaehrig(){\n        istVolljaehrig = if (alter > 17) \"Volljährig\" else \"Nicht Volljährig\"\n    }\n    fun istInitialisiert() = this::istVolljaehrig.isInitialized\n}\n\nval p1 = Person (\"Max Mustermann\", 30)\nprintln(p1.istInitialisiert())\np1.berechneIstVolljaehrig() //istVolljaehrig wird berechnet\nprintln(p1.istInitialisiert())",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 29
     }
    },
    {
     "start_checkpoint": 1622209406266,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    lateinit var istVolljaehrig: String\n    \n    fun berechneIstVolljaehrig(){\n        istVolljaehrig = if (alter > 17) \"Volljährig\" else \"Nicht Volljährig\"\n    }\n    fun istInitialisiert() = this::istVolljaehrig.isInitialized\n}\n\nval p1 = Person (\"Max Mustermann\", 30)\nprintln(\"Versuch 1: ${p1.istInitialisiert()}\")\np1.berechneIstVolljaehrig() //istVolljaehrig wird berechnet\nprintln(\"Versuch 2: ${p1.istInitialisiert()}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.20"
   },
   "artifact_name": "c.22",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "class Person(val name: String, var alter: Int){\n    fun hatGeburtstag() = alter++ //Objektmethode\n    override fun toString() = \"$name ist $alter Jahre alt.\" //Objektmethode die die Methode toString() überschreibt\n}\n\nval p1 = Person(\"Max Mustermann\", 30)\nprintln(\"Vor Geburtstag: $p1\")\np1.hatGeburtstag()\nprintln(\"Nach Geburtstag: $p1\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 30
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.21"
   },
   "artifact_name": "c.23",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.24",
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int)\nval p1 = Punkt (0,0,0)\nprintln(\"Punkt p1: $p1\") //Verwendung der automatisch generierten toString()-Methode\nval p2 = Punkt (1,1,1)\nif (p1 == p2) //Verwendung der automatisch generierten equals()-Methode\n    println(\"p1 und p2 sind gleich.\")\nelse\n    println(\"p1 und p2 sind ungleich.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 38
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.22",
    "1": "o.59",
    "2": "o.60",
    "3": "o.61",
    "4": "o.62"
   },
   "artifact_name": "c.24",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "val p1 = Punkt (0,1,2)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y, z) = p1\nprintln(\"x: $x, y: $y, z: $z\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 29
     }
    },
    {
     "start_checkpoint": 1622209870934,
     "parent": "n.0.54",
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int, val a: Int)\nval p1 = Punkt (0,1,2, 3)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y, z, a) = p1\nprintln(\"x: $x, y: $y, z: $z, $a\")"
    },
    {
     "start_checkpoint": 1622210144419,
     "parent": "n.0.55",
     "literal": "val p1 = Punkt (0,1,2)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y, z) = p1\nprintln(\"x: $x, y: $y, z: $z\")"
    },
    {
     "start_checkpoint": 1622210151826,
     "parent": "n.0.56",
     "literal": "val p1 = Punkt (0,1,2)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y) = p1\nprintln(\"x: $x, y: $y, z: z\")"
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.121",
     "literal": "val p1 = Punkt (0,1,2)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y, z) = p1 //speichert die ersten drei Felder von p1 in den Variablen x, y, z\nprintln(\"x: $x, y: $y, z: $z\")\nval (a, b) = p1 //speichert die ersten zwei Felder von p1 in den Variablen a, b\nprintln(\"a: $a, b: $b\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.23",
    "1": "o.65"
   },
   "artifact_name": "c.25",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "val p1 = Punkt (0,1,2)\nval p2 = p1.copy()\nprintln(\"p1: $p1\")\nprintln(\"p2: $p2\")\nval p3 = p1.copy(x=4)\nprintln(\"p3: $p3\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 17
     }
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.121",
     "literal": "val p1 = Punkt (0,1,2)\nval p2 = p1.copy() //p1 und p2 sind unabhängige Objekte\nprintln(\"p1: $p1\")\nprintln(\"p2: $p2\")\nval p3 = p1.copy(x=4)\nprintln(\"p3: $p3\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.24"
   },
   "artifact_name": "c.26",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "data class Punkt (val x: Int, val y: Int, val z: Int){\n    val istUrsprung = x == 0 && y == 0 && z == 0\n}\nval p1 = Punkt (0,0,0)\nprintln(\"Punkt p1 ist im Ursprung: ${p1.istUrsprung}, $p1\")\nval p2 = Punkt (1,1,1)\nprintln(\"Punkt p2 ist im Ursprung: ${p2.istUrsprung}, $p2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 58
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.25"
   },
   "artifact_name": "c.27",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "private val satz = object {\n    val subjekt = \"Kotlin\"\n    val praedikat = \"ist\"\n    val objekt = \"Programmiersprache\"\n    val vollstaendig = \"Kotlin ist eine Programmiersprache\"\n}\n\nprintln(\"Das Subjekt des Satzes ${satz.vollstaendig} ist ${satz.subjekt} \")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 74
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.26"
   },
   "artifact_name": "c.28",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "object Rechner {\n    val zahl: Int\n    init {\n        println(\"Singleton Rechner wurde erzeugt.\")\n        zahl = (0..10).random()\n    }\n    \n    fun addieren(a: Int, b: Int) = a + b\n}\n\nval a = 5\nval b = 10\nprintln(\"Berechnung ohne Singleton: ${a+b}\")\nprintln(\"Berechnung mit Singleton: ${Rechner.addieren(a,b)}\")\nprintln(\"Zufallszahl des Singletons: ${Rechner.zahl}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 53
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.27"
   },
   "artifact_name": "c.29",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "class Student(val name: String, var alter: Int){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    \n    var matrikelnummer: Int\n    \n    init {\n        matrikelnummer = zaehler\n    }\n}\n\nval s1 = Student (\"Max\", 21)\nval s2 = Student (\"Anna\", 25)\nval s3 = Student (\"Simon\", 26)\nval s4 = Student (\"Sophie\", 19)\nprintln(\"Die Marikelnummer von ${s1.name} ist ${s1.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s2.name} ist ${s2.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s3.name} ist ${s3.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s4.name} ist ${s4.matrikelnummer}.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 20,
      "ch": 68
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.28",
    "1": "o.66"
   },
   "artifact_name": "c.30",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "import java.time.LocalTime\n\nclass Zahlen(){\n    companion object {\n        var nummer = 1\n            get() = field\n    }\n    object Zwei {\n        var nummer = 2\n    }\n    object Drei {\n        var nummer = 3\n    }\n    object Zeit {\n        fun gibZeit() = LocalTime.now()\n    }\n}\n\nprintln(\"Die Nummer des Standard Companion Objects ist ${Zahlen.nummer}.\")\nprintln(\"Die Nummer des Companion Objects Zwei ist ${Zahlen.Zwei.nummer}.\")\nprintln(\"Die Nummer des Companion Objects Drei ist ${Zahlen.Drei.nummer}.\")\nprintln(\"Es ist aktuell ${Zahlen.Zeit.gibZeit()} Uhr.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 21,
      "ch": 54
     }
    },
    {
     "start_checkpoint": 1622211105740,
     "parent": "n.0.121",
     "literal": "import java.time.LocalTime\n\nclass Zahlen(){\n    companion object {\n        var nummer = 1\n            get() = field\n    }\n    object Zwei {\n        var nummer = 2\n    }\n    object Drei {\n        var nummer = 3\n    }\n    object Zeit {\n        fun gibZeit() = LocalTime.now()\n    }\n}\n\nprintln(\"Die Nummer des Standard Companion Objects ist ${Zahlen.nummer}.\")\nprintln(\"Die Nummer des Companion Objects Zwei ist ${Zahlen.Zwei.nummer}.\")\nprintln(\"Die Nummer des Companion Objects Drei ist ${Zahlen.Drei.nummer}.\")\nprintln(\"Es ist aktuell ${Zahlen.Zeit.gibZeit()} Uhr.\")\n\nval zwei = Zahlen()\n//println(zwei.Zwei.nummer) -> Fehler: Nested object 'Zwei' accessed via instance reference"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.31",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.8",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "1": "o.29"
   },
   "artifact_name": "c.32",
   "versions": [
    {
     "start_checkpoint": 1619273440670,
     "parent": "n.0.9",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1619273462931,
     "parent": "n.0.10",
     "literal": "var zaehler = 0\n\nclass Student(val name: String, var alter: Int){\n    \n    var matrikelnummer: Int\n    \n    init {\n        matrikelnummer = zaehler++\n    }\n}\n\nval s1 = Student (\"Max\", 21)\nval s2 = Student (\"Anna\", 25)\nval s3 = Student (\"Simon\", 26)\nval s4 = Student (\"Sophie\", 19)\nprintln(\"Die Marikelnummer von ${s1.name} ist ${s1.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s2.name} ist ${s2.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s3.name} ist ${s3.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s4.name} ist ${s4.matrikelnummer}.\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.30"
   },
   "artifact_name": "c.33",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.121",
     "literal": "//TODO\n\n//Test\nvar fehler = 0\nval p1 = Parkplatzverwaltung(mutableListOf(true, true, false, false, true))\nif (p1.toString() != \"xx--x\"){\n    println(\"Fehler! p1 sollte eigentlich 'xx--x' sein, ist jedoch '$p1'\")\n    fehler++\n}\nif (!p1.einparken(3)){\n    println(\"Fehler! Parkplatz Nummer 3 sollte eigentlich belegt werden können. Parkplatz: $p1\")\n    fehler++\n}\nif (p1.einparken(3)){\n    println(\"Fehler! Parkplatz Nummer 3 sollte eigentlich nicht belegt werden können. Parkplatz: $p1\")\n    fehler++\n}\nif (p1.toString() != \"xx-xx\"){\n    println(\"Fehler! p1 sollte eigentlich 'xx--x' sein, ist jedoch '$p1'\")\n    fehler++\n}\nval p2 = Parkplatzverwaltung()\nif (p2.toString() != \"-----\"){\n    println(\"Fehler! p2 sollte eigentlich '-----' sein, ist jedoch '$p2'\")\n    fehler++\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 29,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.31"
   },
   "artifact_name": "c.34",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.121",
     "literal": "//Lösung\nclass Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Boolean {\n        return if (!parkplatz[nummer]) {\n            parkplatz[nummer] = true\n            true\n        }\n        else {\n            false\n        }\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval p1 = Parkplatzverwaltung(mutableListOf(true, true, false, false, true))\nif (p1.toString() != \"xx--x\"){\n    println(\"Fehler! p1 sollte eigentlich 'xx--x' sein, ist jedoch '$p1'\")\n    fehler++\n}\nif (!p1.einparken(3)){\n    println(\"Fehler! Parkplatz Nummer 3 sollte eigentlich belegt werden können. Parkplatz: $p1\")\n    fehler++\n}\nif (p1.einparken(3)){\n    println(\"Fehler! Parkplatz Nummer 3 sollte eigentlich nicht belegt werden können. Parkplatz: $p1\")\n    fehler++\n}\nif (p1.toString() != \"xx-xx\"){\n    println(\"Fehler! p1 sollte eigentlich 'xx--x' sein, ist jedoch '$p1'\")\n    fehler++\n}\nval p2 = Parkplatzverwaltung()\nif (p2.toString() != \"-----\"){\n    println(\"Fehler! p2 sollte eigentlich '-----' sein, ist jedoch '$p2'\")\n    fehler++\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 52,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.32",
    "1": "o.70"
   },
   "artifact_name": "c.35",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.65",
     "literal": "enum class Wochentag {\n    MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG, SAMSTAG, SONNTAG\n}\n\nclass Tag (val name : Wochentag)\n\nval montag = Tag(Wochentag.MONTAG)\nprintln(\"Der Name von montag ist ${montag.name}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 48
     }
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.121",
     "literal": "enum class Wochentag {\n    MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG, SAMSTAG, SONNTAG\n}\n\nclass Tag (val name : Wochentag)\n\nval montag = Tag(Wochentag.MONTAG)\nprintln(\"Der Name von montag ist ${montag.name}.\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.33"
   },
   "artifact_name": "c.36",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.121",
     "literal": "print(\"Alle Einträge des Enums: \")\nWochentag.values().forEach { \n    print(\"$it, \")\n}\n\nprintln()\nprintln(\"Vollständiger Name von FREITAG: ${Wochentag.valueOf(\"FREITAG\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 73
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.34"
   },
   "artifact_name": "c.37",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.121",
     "literal": "enum class Wochentag (val nummer: Int){\n    MONTAG(1), DIENSTAG(2), MITTWOCH(3), DONNERSTAG(4), FREITAG(5), SAMSTAG(6), SONNTAG(7);\n    \n    val zufallszahl = (0..10).random()\n    \n    fun istWochenende() = if (this == SAMSTAG || this == SONNTAG) true else false\n}\n\nval montag = Wochentag.MONTAG\nprintln(\"Montag ist ein Tag des Wochenendes: ${montag.istWochenende()}, Nummer des Tags: ${montag.nummer}, Zufallszahl: ${montag.zufallszahl}\")\nval samstag = Wochentag.SAMSTAG\nprintln(\"Samstag ist ein Tag des Wochenendes: ${samstag.istWochenende()}, Nummer des Tags: ${samstag.nummer}, Zufallszahl: ${montag.zufallszahl}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 145
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.38",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.39",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "5": "o.35",
    "6": "o.36",
    "7": "o.37",
    "8": "o.38",
    "9": "o.39",
    "10": "o.71",
    "11": "o.72"
   },
   "artifact_name": "c.40",
   "versions": [
    {
     "start_checkpoint": 1619344680409,
     "parent": "n.0.12",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1619344804639,
     "parent": "n.0.13",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}"
    },
    {
     "start_checkpoint": 1619344843467,
     "parent": "n.0.14",
     "literal": "open class Person(val name: String, var alter: Int){\n    fun wasBinIch() = println(\"Ich bin eine Person\")\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}"
    },
    {
     "start_checkpoint": 1619344920701,
     "parent": "n.0.15",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}"
    },
    {
     "start_checkpoint": 1619344948011,
     "parent": "n.0.16",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)"
    },
    {
     "start_checkpoint": 1619344965296,
     "parent": "n.0.17",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1619344997121,
     "parent": "n.0.18",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: ${p1.toString()}\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1619345039116,
     "parent": "n.0.19",
     "literal": "open class Person(val name: String, var alter: Int){\n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1619345077293,
     "parent": "n.0.20",
     "literal": "open class Person(val name: String, var alter: Int){\n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override fun toString() = \"Ich bin $name, bin $alter Jahre alt und besitze die Matrikelnummer §matrikelnummer.\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.65",
     "literal": "open class Person(val name: String, var alter: Int){\n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override fun toString() = \"Ich bin $name, bin $alter Jahre alt und besitze die Matrikelnummer $matrikelnummer.\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1622286007574,
     "parent": "n.0.68",
     "literal": "open class Person(val name: String, var alter: Int) { //Super-Klasse\n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){ //Sub-Klasse, die von Person erbt\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und besitze die Matrikelnummer $matrikelnummer.\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1622286066819,
     "parent": "n.0.121",
     "literal": "open class Person(val name: String, var alter: Int) { //Super-Klasse\n    override fun toString() = \"Mein Name ist $name und ich bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){ //Sub-Klasse, die von Person erbt\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und besitze die Matrikelnummer $matrikelnummer.\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.41",
   "versions": [
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.21",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.42",
   "versions": [
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.21",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.43",
   "versions": [
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.21",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.44",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.22",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.40",
    "1": "o.73",
    "3": "o.74"
   },
   "artifact_name": "c.45",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "open class Person(val name: String, var alter: Int){\n    open val schlachtruf\n        get() = \"Für die Horde!\"\n    \n    open fun hatGeburtstag() {\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter++\n    } \n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt. $schlachtruf\"\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override val schlachtruf\n        get() = \"Für die Allianz!\"\n    \n    override fun hatGeburtstag() {\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter--\n    } \n    \n    override fun toString() = \"Ich bin $name, bin $alter Jahre alt und habe die Matrikelnummer $matrikelnummer. $schlachtruf Oder vielleicht doch: ${super.schlachtruf}?\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\np1.hatGeburtstag()\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")\ns1.hatGeburtstag()\nprintln(\"s1: $s1\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 36,
      "ch": 17
     }
    },
    {
     "start_checkpoint": 1622286097813,
     "parent": "n.0.70",
     "literal": "open class Person(val name: String, var alter: Int){\n    open val schlachtruf\n        get() = \"Für die Horde!\"\n    \n    open fun hatGeburtstag() {\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter++\n    } \n    override fun toString() = \"Mein Name ist $name und ich bin $alter Jahre alt. $schlachtruf\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override val schlachtruf\n        get() = \"Für die Allianz!\"\n    \n    override fun hatGeburtstag() {\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter--\n    } \n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und habe die Matrikelnummer $matrikelnummer. $schlachtruf Oder vielleicht doch: ${super.schlachtruf}?\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\np1.hatGeburtstag()\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")\ns1.hatGeburtstag()\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1622286517509,
     "parent": "n.0.71",
     "literal": "open class Person(val name: String, var alter: Int){\n    open val schlachtruf //Dieses Feld kann von den Sub-Klassen überschrieben werden\n        get() = \"Für die Horde!\"\n    \n    open fun hatGeburtstag() { //Diese Methode kann von den Sub-Klassen überschrieben werden\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter++\n    } \n    override fun toString() = \"Mein Name ist $name und ich bin $alter Jahre alt. $schlachtruf\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override val schlachtruf\n        get() = \"Für die Allianz!\"\n    \n    override fun hatGeburtstag() { //Überschreibt die Methode hatGeburtstag der Super-Klasse\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter--\n    } \n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und habe die Matrikelnummer $matrikelnummer. $schlachtruf Oder vielleicht doch: ${super.schlachtruf}?\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\np1.hatGeburtstag()\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")\ns1.hatGeburtstag()\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1622286553284,
     "parent": "n.0.121",
     "literal": "open class Person(val name: String, var alter: Int){\n    open val schlachtruf //Dieses Feld kann von den Sub-Klassen überschrieben werden\n        get() = \"Für die Horde!\"\n    \n    open fun hatGeburtstag() { //Diese Methode kann von den Sub-Klassen überschrieben werden\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter++\n    } \n    override fun toString() = \"Mein Name ist $name und ich bin $alter Jahre alt. $schlachtruf\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override val schlachtruf\n        get() = \"Für die Allianz!\"\n    \n    override fun hatGeburtstag() { //Überschreibt die Methode hatGeburtstag der Super-Klasse\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter--\n    } \n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und habe die Matrikelnummer $matrikelnummer. $schlachtruf Oder vielleicht doch: ${super.schlachtruf}?\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\np1.hatGeburtstag() //Ruft hatGeburtstag() von der Klasse Person auf \nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")\ns1.hatGeburtstag() //Ruft hatGeburtstag() von der Klasse Student auf \nprintln(\"s1: $s1\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.41"
   },
   "artifact_name": "c.46",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "open class Punkt2D (val x: Int, val y: Int){\n    override fun toString() = \"x: $x, y: $y\"\n}\n\nclass Punkt3D : Punkt2D{\n    val z: Int\n    \n    //sekundäre Konstruktoren\n    constructor (x: Int, y: Int, z: Int) : super (x, y) {\n        this.z = z\n    }\n    constructor () : super (0, 0) {\n        this.z = 0\n    }\n    \n    override fun toString() = \"${super.toString()}, z: $z\"\n}\n\nval p1 = Punkt3D (4, 2, 8)\nprintln(\"Punkt p1: $p1\")\nval p2 = Punkt3D()\nprintln(\"Punkt p2: $p2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 21,
      "ch": 23
     }
    },
    {
     "start_checkpoint": 1622286553284,
     "parent": "n.0.121",
     "literal": "open class Punkt2D (val x: Int, val y: Int){\n    override fun toString() = \"x: $x, y: $y\"\n}\n\nclass Punkt3D : Punkt2D { //Aufruf des primären Konstruktors von Punkt2D fehlt hier\n    val z: Int\n    \n    //sekundäre Konstruktoren rufen den primären Defaultkonstruktor von Punkt2D auf\n    constructor (x: Int, y: Int, z: Int) : super (x, y) {\n        this.z = z\n    }\n    constructor () : super (0, 0) {\n        this.z = 0\n    }\n    \n    override fun toString() = \"${super.toString()}, z: $z\"\n}\n\nval p1 = Punkt3D (4, 2, 8)\nprintln(\"Punkt p1: $p1\")\nval p2 = Punkt3D()\nprintln(\"Punkt p2: $p2\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.42"
   },
   "artifact_name": "c.47",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "abstract class Computer (val kerne: Int, val farbe: String){\n    var istAn = false\n    abstract fun einschalten()\n}\n\nclass Laptop (kerne: Int, farbe: String, val hatTouchscreen: Boolean) : Computer(kerne, farbe){\n    var istAufgeklappt = false\n    override fun einschalten() {\n        if (!istAufgeklappt) \n            istAufgeklappt = true\n        istAn = true\n        println(\"Laptop wurde eingeschalten.\")\n    }\n}\n\nclass Standcomputer (kerne: Int, farbe: String) : Computer(kerne, farbe){\n    override fun einschalten() {\n        istAn = true\n        println(\"Standcomputer wurde eingeschalten.\")\n    }\n}\n\n//val c1 = Computer (8, \"Schwarz\") -> Error: Cannot create an instance of an abstract class\nval l1 = Laptop(6, \"Rot\", false)\nl1.einschalten()\nval s1 = Standcomputer(12, \"Weiß\")\ns1.einschalten()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 26,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.43"
   },
   "artifact_name": "c.48",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.24",
     "literal": "//Kotlin Fehelr??\n\nsealed class Fehler\ndata class Laufzeitfehler(val f: Int) : Fehler()\ndata class Kompilierfehler() : Fehler()\ndata class Referenzfehler() : Fehler()\n\nval f1 = Kompilierfehler()\n\nwhen (f1){\n    is Laufzeitfehler -> println(\"Es ist ein Laufzeitfehler aufgetreten.\")\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler aufgetreten.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 13,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.44"
   },
   "artifact_name": "c.49",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "interface Addition {\n    val dieZahl: Int\n    \n    fun add2(a: Int, b: Int): Int\n    fun add3(a: Int, b: Int, c: Int) = a + b + c\n}\n\nclass Rechner : Addition {\n    override val dieZahl = 42\n    override fun add2(a: Int, b: Int) = a + b\n}\n\nval rechner = Rechner()\nprintln(\"rechner.dieZahl: ${rechner.dieZahl}\")\nprintln(\"rechner.add2(5,3): ${rechner.add2(5,3)}\")\nprintln(\"rechner.add3(5,9,3): ${rechner.add3(5,9,3)}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 15,
      "ch": 53
     }
    },
    {
     "start_checkpoint": 1622289820200,
     "parent": "n.0.121",
     "literal": "interface Addition {\n    val dieZahl: Int //Feld, das in den Klassen überschrieben und gefüllt werden muss\n    \n    fun add2(a: Int, b: Int): Int //Methode muss in den Klassen ausformuliert werden\n    fun add3(a: Int, b: Int, c: Int) = a + b + c //Bereits voll implementierte Methode, die übernommen wird\n}\n\nclass Rechner : Addition {\n    override val dieZahl = 42 //Überschreibt das vorgegebene Feld dieZahl\n    override fun add2(a: Int, b: Int) = a + b //Überschreibt die vorgegebene Methode add3\n}\n\nval rechner = Rechner()\nprintln(\"rechner.dieZahl: ${rechner.dieZahl}\")\nprintln(\"rechner.add2(5,3): ${rechner.add2(5,3)}\")\nprintln(\"rechner.add3(5,9,3): ${rechner.add3(5,9,3)}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.45"
   },
   "artifact_name": "c.50",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.121",
     "literal": "data class Speicher<T> (var platz1: T, var platz2: T, var platz3: T)\n\nval s1 = Speicher(1,2,3)\nval s2 = Speicher(listOf(1,2,3),listOf(1,2,3),listOf(1,2,3))\nval s3 = Speicher(\"Kotlin\",\"Java\",\"C\")\nprintln(\"s1: $s1\")\nprintln(\"s2: $s2\")\nprintln(\"s3: $s3\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 17
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.46"
   },
   "artifact_name": "c.51",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.121",
     "literal": "class Gleichheitstest<T: Comparable<T>>{\n    fun istGleich(a: T, b: T) = if(a.compareTo(b) == 0) true else false\n}\nval gleichheitstestInt = Gleichheitstest<Int>()\nprintln(\"gleichheitstestInt.istGleich(3,3): ${gleichheitstestInt.istGleich(3,3)}\")\nprintln(\"gleichheitstestInt.istGleich(10,3): ${gleichheitstestInt.istGleich(10,3)}\")\nval gleichheitstestString = Gleichheitstest<String>()\nprintln(\"gleichheitstestString.istGleich('Kotlin','Kotlin'): ${gleichheitstestString.istGleich(\"Kotlin\",\"Kotlin\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 115
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.47"
   },
   "artifact_name": "c.52",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "fun <T: Comparable<T>> istGleich(a: T, b: T) = if(a.compareTo(b) == 0) true else false\nprintln(\"istGleich(3,3): ${istGleich(3,3)}\")\nprintln(\"istGleich('Kotlin','Kotlin'): ${istGleich(\"Kotlin\",\"Kotlin\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 71
     }
    },
    {
     "start_checkpoint": 1622290018952,
     "parent": "n.0.121",
     "literal": "fun <T: Comparable<T>> istGleich(a: T, b: T) = if(a.compareTo(b) == 0) true else false\nprintln(\"istGleich(3,3): ${istGleich(3,3)}\") //T ist Int\nprintln(\"istGleich('Kotlin','Kotlin'): ${istGleich(\"Kotlin\",\"Kotlin\")}\") //T ist String"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.48",
    "1": "o.78",
    "2": "o.79",
    "3": "o.80",
    "5": "o.81"
   },
   "artifact_name": "c.53",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste = mutableListOf(3,6,1,8,10)\nprintln(\"Entferntes Element: ${liste.entferneMinimum()}\")\nprintln(\"liste: $liste\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 13,
      "ch": 23
     }
    },
    {
     "start_checkpoint": 1622290123775,
     "parent": "n.0.82",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Int\nprintln(\"Entferntes Element: ${liste2.entferneMinimum()}\")\nprintln(\"listew: $liste2\")"
    },
    {
     "start_checkpoint": 1622290183581,
     "parent": "n.0.83",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Int\nprintln(\"Entferntes Element: ${liste2.entferneMinimum()}\")\nprintln(\"liste2: $liste2\")"
    },
    {
     "start_checkpoint": 1622290193733,
     "parent": "n.0.84",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element von liste1: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Int\nprintln(\"Entferntes Element von liste2: ${liste2.entferneMinimum()}\")\nprintln(\"liste2: $liste2\")"
    },
    {
     "start_checkpoint": 1622290201805,
     "parent": "n.0.85",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element von liste1: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Char\nprintln(\"Entferntes Element von liste2: ${liste2.entferneMinimum()}\")\nprintln(\"liste2: $liste2\")"
    },
    {
     "start_checkpoint": 1622290204256,
     "parent": "n.0.121",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element von liste1: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Character\nprintln(\"Entferntes Element von liste2: ${liste2.entferneMinimum()}\")\nprintln(\"liste2: $liste2\")"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.54",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.22",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.55",
   "versions": [
    {
     "start_checkpoint": 1619530334504,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.56",
   "versions": [
    {
     "start_checkpoint": 1619530334504,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.49"
   },
   "artifact_name": "c.57",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.121",
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int)\nval p1 = Punkt (0,0,0)\nprintln(\"Punkt p1: $p1\") //Verwendung der automatisch generierten toString()-Methode\nval p2 = Punkt (1,1,1)\nprintln(\"Punkt p2: $p2\")\nif (p1 == p2) //Verwendung der automatisch generierten equals()-Methode\n    println(\"p1 und p2 sind gleich.\")\nelse\n    println(\"p1 und p2 sind ungleich.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 38
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.50"
   },
   "artifact_name": "c.58",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.121",
     "literal": "//TODO\n\nval abstaende = mutableListOf<Abstand>() //Liste von Abständen\n\n//Test\nval positionen1 = listOf(Position(2,7), Position(0,0), Position(5,2), Position(7,2))\nval positionen2 = listOf(Position(4,4), Position(10,2), Position(1,6), Position(3,4))\nfor(p1 in positionen1){\n    for(p2 in positionen2){\n        berechneAbstand(p1, p2)\n    }\n}\nabstaende.sortBy {it.wert}\nvar fehler = 0\nif(abstaende.toString() != \"[Abstand(wert=2), Abstand(wert=3), Abstand(wert=4), Abstand(wert=5), Abstand(wert=6), Abstand(wert=7), Abstand(wert=8), Abstand(wert=10), Abstand(wert=12), Abstand(wert=13)]\"){\n    println(\"Fehler! Es sollten folgende Abstände in der Liste vorhanden sein:\\n\\t[Abstand(wert=2), Abstand(wert=3), Abstand(wert=4), Abstand(wert=5), Abstand(wert=6), Abstand(wert=7), Abstand(wert=8), Abstand(wert=10), Abstand(wert=12), Abstand(wert=13)]\\nIn der Liste ist aber aktuell:\\n\\t$abstaende\")\n    fehler++\n}\nval richtigeAnzahl = listOf(1,2,2,3,1,2,2,1,1,1)\nfor(i in 0 until abstaende.size){\n    if(abstaende[i].positionen.size != richtigeAnzahl[i]){\n        println(\"Fehler bei Element Nummer $i in abstaende!\\n\\tDer Abstand ${abstaende[i]} sollte eigentlich ${richtigeAnzahl[i]} Einträge in der Liste positionen besitzen, es ist/sind aber ${abstaende[i].positionen.size} Eintrag/Einträge.\")\n        fehler++\n    }\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 28,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.51"
   },
   "artifact_name": "c.59",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.121",
     "literal": "//Lösung\n\ndata class Position (val x: Int, val y: Int)\ndata class Abstand (val wert: Int){\n    val positionen = mutableListOf<Pair<Position, Position>>()\n}\n\nfun berechneAbstand(p1: Position, p2: Position) {\n    val abstand = Abstand((p1.x - p2.x).absoluteValue + (p1.y - p2.y).absoluteValue)\n    abstand.positionen.add(Pair(p1, p2))\n    if (abstand in abstaende)\n        abstaende.find { it == abstand }?.positionen?.add(Pair(p1, p2))\n    else\n        abstaende.add(abstand)\n}\n\nval abstaende = mutableListOf<Abstand>() //Liste von Abständen\n\n//Test\nval positionen1 = listOf(Position(2,7), Position(0,0), Position(5,2), Position(7,2))\nval positionen2 = listOf(Position(4,4), Position(10,2), Position(1,6), Position(3,4))\nfor(p1 in positionen1){\n    for(p2 in positionen2){\n        berechneAbstand(p1, p2)\n    }\n}\nabstaende.sortBy {it.wert}\nvar fehler = 0\nif(abstaende.toString() != \"[Abstand(wert=2), Abstand(wert=3), Abstand(wert=4), Abstand(wert=5), Abstand(wert=6), Abstand(wert=7), Abstand(wert=8), Abstand(wert=10), Abstand(wert=12), Abstand(wert=13)]\"){\n    println(\"Fehler! Es sollten folgende Abstände in der Liste vorhanden sein:\\n\\t[Abstand(wert=2), Abstand(wert=3), Abstand(wert=4), Abstand(wert=5), Abstand(wert=6), Abstand(wert=7), Abstand(wert=8), Abstand(wert=10), Abstand(wert=12), Abstand(wert=13)]\\nIn der Liste ist aber aktuell:\\n\\t$abstaende\")\n    fehler++\n}\nval richtigeAnzahl = listOf(1,2,2,3,1,2,2,1,1,1)\nfor(i in 0 until abstaende.size){\n    if(abstaende[i].positionen.size != richtigeAnzahl[i]){\n        println(\"Fehler bei Element Nummer $i in abstaende!\\n\\tDer Abstand ${abstaende[i]} sollte eigentlich ${richtigeAnzahl[i]} Einträge in der Liste positionen besitzen, es ist/sind aber ${abstaende[i].positionen.size} Eintrag/Einträge.\")\n        fehler++\n    }\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 42,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.60",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.52",
    "1": "o.75",
    "2": "o.76",
    "3": "o.77"
   },
   "artifact_name": "c.61",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "literal": "//Kotlin Fehelr??\n\nsealed class Fehler\ndata class Laufzeitfehler(val f: Int) : Fehler()\ndata class Kompilierfehler(val s: String) : Fehler()\ndata class Referenzfehler(val s: String) : Fehler()\n\nval zufall = (0..2).random()\nval f1 = if(zufall == 1)\n                Laufzeitfehler(2)\n            else if(zufall == 2)\n                Kompilierfehler(\"adf\")\n            else\n                Referenzfehler(\"wkf\")\n\nwhen (f1){\n    is Laufzeitfehler -> println(\"Es ist ein Laufzeitfehler aufgetreten.\")\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler aufgetreten.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 19,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1622286910420,
     "parent": "n.0.76",
     "literal": "sealed class Fehler\ndata class Laufzeitfehler(val f: Int) : Fehler()\ndata class Kompilierfehler(val s: String) : Fehler()\ndata class Referenzfehler(val s: String) : Fehler()\n\nval zufall = (0..2).random()\nval f1 = if(zufall == 1)\n                Laufzeitfehler(2)\n            else if(zufall == 2)\n                Kompilierfehler(\"adf\")\n            else\n                Referenzfehler(\"wkf\")\n\nwhen (f1){\n    is Laufzeitfehler -> println(\"Es ist ein Laufzeitfehler aufgetreten.\")\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler aufgetreten.\")\n}"
    },
    {
     "start_checkpoint": 1622286961921,
     "parent": "n.0.77",
     "literal": "sealed class Fehler\ndata class Laufzeitfehler(val f: Int) : Fehler()\ndata class Kompilierfehler(val s: String) : Fehler()\ndata class Referenzfehler(val s: String) : Fehler()\n\nval zufall = (0..2).random()\nval f1 = if(zufall == 1)\n                Laufzeitfehler(2)\n            else if(zufall == 2)\n                Kompilierfehler(\"sad\")\n            else\n                Referenzfehler(\"wkf\")\n\nwhen (f1){\n    is Laufzeitfehler -> println(f1)\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler aufgetreten.\")\n}"
    },
    {
     "start_checkpoint": 1622287051823,
     "parent": "n.0.121",
     "literal": "sealed class Fehler\ndata class Laufzeitfehler(val fehlercode: Int) : Fehler()\ndata class Kompilierfehler(val fehlercode: Int) : Fehler()\ndata class Referenzfehler(val fehlercode: Int) : Fehler()\n\nval zufall = (0..2).random()\nval f1 = if(zufall == 1)\n                Laufzeitfehler(123)\n            else if(zufall == 2)\n                Kompilierfehler(42)\n            else\n                Referenzfehler(200)\n\nwhen (f1){\n    is Laufzeitfehler -> println(\"Es ist ein Laufzeitfehler $f1 aufgetreten.\")\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler $f1 aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler $f1 aufgetreten.\")\n}"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.67",
    "1": "o.82",
    "2": "o.83",
    "3": "o.84",
    "4": "o.85"
   },
   "artifact_name": "c.62",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "literal": "val parameter = (-100..200).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 6
     }
    },
    {
     "start_checkpoint": 1622290304056,
     "parent": "n.0.89",
     "literal": "val parameter = (-100..100).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent //Führen Sie die "
    },
    {
     "start_checkpoint": 1622290337397,
     "parent": "n.0.91",
     "literal": "val parameter = (-100..100).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent //Führen Sie die Zelle mehrfach aus, um die verschiedenen Verhalten zu Betrachten"
    },
    {
     "start_checkpoint": 1622290370267,
     "parent": "n.0.92",
     "literal": "val parameter = (-100..100).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprintln(prozent::class.simpleName)\nprozent //Führen Sie die Zelle mehrfach aus, um die verschiedenen Verhalten zu Betrachten"
    },
    {
     "start_checkpoint": 1622290408459,
     "parent": "n.0.121",
     "literal": "val parameter = (-100..100).random()\nval prozent = //In der Variable prozent wird entweder ein Wert zwischen 0 und 100 oder eine Exception gespeichert.\n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent //Führen Sie die Zelle mehrfach aus, um die verschiedenen Verhalten zu Betrachten"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.68",
    "1": "o.86",
    "3": "o.87",
    "4": "o.88",
    "5": "o.89",
    "7": "o.90"
   },
   "artifact_name": "c.63",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "literal": "val parameter = \"Kotlin\"\n//val parameter = \"231\"\nval prozent = \n    try{\n        Integer.parseInt(parameter)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $parameter kann nicht in eine ganze Zahl umgewandelt werden.\")\n    }\nprozent",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 6
     }
    },
    {
     "start_checkpoint": 1622290479536,
     "parent": "n.0.94",
     "literal": "val parameter = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\n//val parameter = \"231\"\nval prozent = \n    try{\n        Integer.parseInt(parameter)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $parameter kann nicht in eine ganze Zahl umgewandelt werden.\")\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290547559,
     "parent": "n.0.96",
     "literal": "val parameter = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = \n    try{\n        Integer.parseInt(parameter)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $parameter kann nicht in eine ganze Zahl umgewandelt werden.\")\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290562913,
     "parent": "n.0.97",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = \n    try{\n        Integer.parseInt(zeichenkette)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\")\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290572241,
     "parent": "n.0.98",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = \n    try{\n        Integer.parseInt(zeichenkette)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\")\n        println(e)\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290587221,
     "parent": "n.0.99",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = \n    try{\n        Integer.parseInt(zeichenkette)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\\n$e\")\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290607436,
     "parent": "n.0.100",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = try{\n                    Integer.parseInt(zeichenkette)\n                }\n                catch(e: Exception){\n                    println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\\n$e\")\n                }\nprozent"
    },
    {
     "start_checkpoint": 1622290655058,
     "parent": "n.0.121",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval zahl = try{\n                    Integer.parseInt(zeichenkette)\n                }\n                catch(e: Exception){\n                    println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\\n$e\")\n                }\nzahl"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.69"
   },
   "artifact_name": "c.64",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "literal": "class KeineProzentzahl(fehlermeldung: String) : Exception(fehlermeldung)\n\nval parameter = (-100..200).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw KeineProzentzahl(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.65",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.57"
   },
   "artifact_name": "c.66",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.121",
     "literal": "//Lösung\nclass Pizza (groeße: Int, belaege: List<String>, geschnitten: Boolean){\n    val groeße: Int\n    val belaege: MutableList<String>\n    val geschnitten: Boolean\n    \n    init {\n        this.groeße = if (15 <= groeße && groeße <= 30) groeße else -1\n        this.belaege = mutableListOf(\"Tomatensoße\", \"Mozzarella\")\n        this.belaege += belaege\n        this.geschnitten = geschnitten\n    }\n    \n    constructor (groeße: Int) : this(groeße, emptyList(), true) //Pizza Magaritha\n    constructor () : this(25, listOf(\"Thunfisch\", \"Zwiebeln\", \"Peperoni\"), true) //Pizza al Tonno\n}\n\n//Tests\nvar fehler = 0\nval test1 = Pizza(25, listOf(\"Schinken\"), false)\nif( test1.groeße != 25 || test1.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test1.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 1! Richtig wäre: Größe 25, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test1.groeße}, Beläge ${test1.belaege}, Geschnitten ${test1.geschnitten}\")\n}\nval test2 = Pizza(31, listOf(\"Schinken\"), false)\nif( test2.groeße != -1 || test2.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test2.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 2! Richtig wäre: Größe -1, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test2.groeße}, Beläge ${test2.belaege}, Geschnitten ${test2.geschnitten}\")\n}\nval test3 = Pizza(14, listOf(\"Schinken\"), false)\nif( test3.groeße != -1 || test3.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test3.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 3! Richtig wäre: Größe -1, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test3.groeße}, Beläge ${test3.belaege}, Geschnitten ${test3.geschnitten}\")\n}\nval test4 = Pizza(31, listOf(\"Schinken\"), false)\nif( test4.groeße != -1 || test4.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Schinken\") || test4.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 4! Richtig wäre: Größe -1, Beläge [Tomatensoße, Mozzarella, Schinken], Geschnitten false \\n  Ist: Größe ${test4.groeße}, Beläge ${test4.belaege}, Geschnitten ${test4.geschnitten}\")\n}\nval test5 = Pizza(28, emptyList(), true)\nif( test5.groeße != 28 || test5.belaege != listOf(\"Tomatensoße\", \"Mozzarella\") || test5.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 5! Richtig wäre: Größe 28, Beläge [Tomatensoße, Mozzarella], Geschnitten true \\n  Ist: Größe ${test5.groeße}, Beläge ${test5.belaege}, Geschnitten ${test5.geschnitten}\")\n}\nval test6 = Pizza(15)\nif( test6.groeße != 15 || test6.belaege != listOf(\"Tomatensoße\", \"Mozzarella\") || test6.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 6! Richtig wäre: Größe 15, Beläge [Tomatensoße, Mozzarella], Geschnitten true \\n  Ist: Größe ${test6.groeße}, Beläge ${test6.belaege}, Geschnitten ${test6.geschnitten}\")\n}\nval test7 = Pizza()\nif( test7.groeße != 25 || test7.belaege != listOf(\"Tomatensoße\", \"Mozzarella\", \"Thunfisch\", \"Zwiebeln\", \"Peperoni\") || test7.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 7! Richtig wäre: Größe 25, Beläge [Tomatensoße, Mozzarella, Thunfisch, Zwiebeln, Peperoni], Geschnitten false \\n  Ist: Größe ${test7.groeße}, Beläge ${test7.belaege}, Geschnitten ${test7.geschnitten}\")\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 57,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.67",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.47",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.68",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.47",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.69",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.121",
     "literal": "private val satz = object {\n    val subjekt = \"Kotlin\"\n    val praedikat = \"ist\"\n    val objekt = \"Programmiersprache\"\n    val vollstaendig = \"Kotlin ist eine Programmiersprache\"\n}\n\nprintln(\"Das Subjekt des Satzes ${satz.vollstaendig} ist ${satz.subjekt}.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 74
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.70",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.121",
     "literal": "class Student(val name: String, var alter: Int){\n    companion object { //Umsetzung in Java: public static int zaehler = 0\n        var zaehler = 0\n            get() = field++\n    }\n    \n    var matrikelnummer: Int\n    \n    init {\n        matrikelnummer = zaehler //Umsetzung in Java: matrikelnummer = zaehler++\n    }\n}\n\nval s1 = Student (\"Max\", 21)\nval s2 = Student (\"Anna\", 25)\nval s3 = Student (\"Simon\", 26)\nval s4 = Student (\"Sophie\", 19)\nprintln(\"Die Marikelnummer von ${s1.name} ist ${s1.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s2.name} ist ${s2.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s3.name} ist ${s3.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s4.name} ist ${s4.matrikelnummer}.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 20,
      "ch": 68
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.71",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.65",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.72",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.65",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "2": "o.91"
   },
   "artifact_name": "c.73",
   "versions": [
    {
     "start_checkpoint": 1622291027879,
     "parent": "n.0.108",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1622291059093,
     "parent": "n.0.109",
     "literal": "class Test(){\n    val t1: Int = 2\n}"
    },
    {
     "start_checkpoint": 1622291067351,
     "parent": "n.0.110",
     "literal": "class Test(){\n    val t1: Int = 2\n}\nval t = Test()\nt.t1"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.92"
   },
   "artifact_name": "c.74",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "n.0.121",
     "literal": "abstract class Computer (val kerne: Int, val farbe: String){ //Abstrakte Klasse\n    var istAn = false\n    abstract fun einschalten() //Abstrakte Methode\n}\n\nclass Laptop (kerne: Int, farbe: String, val hatTouchscreen: Boolean) : Computer(kerne, farbe){\n    var istAufgeklappt = false\n    override fun einschalten() { //Vervollständigt die abstrakte Methode einschalten(), die geerbt wurde\n        if (!istAufgeklappt) \n            istAufgeklappt = true\n        istAn = true\n        println(\"Laptop wurde eingeschalten.\")\n    }\n}\n\nclass Standcomputer (kerne: Int, farbe: String) : Computer(kerne, farbe){\n    override fun einschalten() {\n        istAn = true\n        println(\"Standcomputer wurde eingeschalten.\")\n    }\n}\n\n//val c1 = Computer (8, \"Schwarz\") -> Error: Cannot create an instance of an abstract class\nval l1 = Laptop(6, \"Rot\", false)\nl1.einschalten()\nval s1 = Standcomputer(12, \"Weiß\")\ns1.einschalten()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 26,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.93"
   },
   "artifact_name": "c.75",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "n.0.121",
     "literal": "class KeineProzentzahl(fehlermeldung: String) : Exception(fehlermeldung)\n\nval parameter = (-100..100).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw KeineProzentzahl(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.76",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "n.0.116",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.77",
   "versions": [
    {
     "start_checkpoint": 1622313230222,
     "parent": "n.0.120",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.94",
    "1": "o.95"
   },
   "artifact_name": "c.78",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "literal": "class Auto(val ps: Int, var farbe: String){\n    companion object {\n        val nummernschilder = mutableListOf<String>()\n        fun generiereNummernschild(): String {\n            var testschild = \"${('A'..'Z').random()}${('A'..'Z').random()}-${(1..9).random()}${(0..9).random()}\"\n            while (nummernschilder.find { it == testschild } != null){\n                testschild = \"${('A'..'Z').random()}${('A'..'Z').random()}-${(1..9).random()}${(0..9).random()}\"\n            }\n            nummernschilder.add(testschild)\n            return testschild\n        }\n    }\n    \n    val nummernschild = generiereNummernschild()\n}\n\n//Test\nvar duplikate = 0\nval autos = MutableList(100) { Auto ((60..300).random(), \"weiß\") }\nfor (auto in autos){\n    for(testauto in autos){\n        if(auto.nummernschild == testauto.nummernschild && auto != testauto && auto.nummernschild != \"AA-00\"){\n            duplikate++\n            println(\"Nummernschild ${auto.nummernschild} wurde mehrfach gefunden.\")\n        }\n    }\n}\nif (duplikate == 0){\n    println(\"Super! Es konnten keine zwei Autos mit dem gleichen Nummernschild gefunden werden.\")\n}\nelse {\n    println(\"Falsch! Es wurden Nummernschilder mehrfach generiert.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1622445448043,
     "parent": "n.0.122",
     "literal": "class Auto(val ps: Int, var farbe: String){\n    companion object {\n        val nummernschilder = mutableListOf<String>()\n        fun generiereNummernschild(): String {\n            var testschild = \"${('A'..'Z').random()}${('A'..'Z').random()}-${(1..9).random()}${(0..9).random()}\"\n            while (nummernschilder.find { it == testschild } != null){\n                testschild = \"${('A'..'Z').random()}${('A'..'Z').random()}-${(1..9).random()}${(0..9).random()}\"\n            }\n            nummernschilder.add(testschild)\n            return testschild\n        }\n    }\n    \n    val nummernschild = generiereNummernschild()\n}\n\n//Test\nval autos = MutableList(100) { Auto ((60..300).random(), \"weiß\") }\nval nummernschilder = mutableListOf<String>()\nfor (auto in autos){\n    nummernschilder.add(auto.nummernschild)\n}\nif (nummernschilder.size == nummernschilder.toSet().size){\n    println(\"Super! Alle Nummernschilder sind einzigartig.\")\n}\nelse {\n    println(\"Falsch! Es wurden Nummernschilder mehrfach vergeben.\")\n}"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.79",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.80",
   "versions": [
    {
     "start_checkpoint": 1622445448043,
     "parent": "n.0.122",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.96"
   },
   "artifact_name": "c.81",
   "versions": [
    {
     "start_checkpoint": 1622445629223,
     "literal": "//TODO\n\n//Test\nval autos = MutableList(100) { Auto ((60..300).random(), \"weiß\") }\nval nummernschilder = mutableListOf<String>()\nfor (auto in autos){\n    nummernschilder.add(auto.nummernschild)\n}\nif (nummernschilder.size == nummernschilder.toSet().size){\n    println(\"Super! Alle Nummernschilder sind einzigartig.\")\n}\nelse {\n    println(\"Falsch! Es wurden Nummernschilder mehrfach vergeben.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 13,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.82",
   "versions": [
    {
     "start_checkpoint": 1622446154193,
     "literal": "//Lösung\nenum class Monat(val nummer: Int){\n    JANUAR(1), FEBRUAR(2), MAERZ(3), APRIL(4), MAI(5), JUNI(6), JULI(7), AUGUST(8), SEPTEMBER(9), OKTOBER(10), NOVEMBER(11), DEZEMBER(12)\n}\n\n//Test\ntry{\n    val januar = Monat.JANUAR\n    if(januar.nummer != 1){\n        println(\"Fehler! Der Januar ist der 1. Monat im Kalenderjahr.\")\n    }\n}\ncatch(e: Exception){\n    println(e)\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.83",
   "versions": [
    {
     "start_checkpoint": 1622446386059,
     "literal": "//Lösung\nenum class Monat(val nummer: Int){\n    JANUAR(1), FEBRUAR(2), MAERZ(3), APRIL(4), MAI(5), JUNI(6), JULI(7), AUGUST(8), SEPTEMBER(9), OKTOBER(10), NOVEMBER(11), DEZEMBER(12)\n}\n\n//Test\nvar fehler = 0\ntry{\n    val januar = Monat.JANUAR\n    if(januar.nummer != 1){\n        fehler++\n        println(\"Fehler! Der Januar ist der 1. Monat im Kalenderjahr.\")\n    }\n    val februar = Monat.FEBRUAR\n    if(februar.nummer != 2){\n        fehler++\n        println(\"Fehler! Der Februar ist der 2. Monat im Kalenderjahr.\")\n    }\n    val maerz = Monat.MAERZ\n    if(maerz.nummer != 3){\n        fehler++\n        println(\"Fehler! Der März ist der 3. Monat im Kalenderjahr.\")\n    }\n    val april = Monat.APRIL\n    if(april.nummer != 4){\n        fehler++\n        println(\"Fehler! Der April ist der 4. Monat im Kalenderjahr.\")\n    }\n    val mai = Monat.MAI\n    if(mai.nummer != 5){\n        fehler++\n        println(\"Fehler! Der Mai ist der 5. Monat im Kalenderjahr.\")\n    }\n    val juni = Monat.JUNI\n    if(juni.nummer != 6){\n        fehler++\n        println(\"Fehler! Der Juni ist der 6. Monat im Kalenderjahr.\")\n    }\n    val juli = Monat.JULI\n    if(juli.nummer != 7){\n        fehler++\n        println(\"Fehler! Der Juli ist der 7. Monat im Kalenderjahr.\")\n    }\n    val august = Monat.AUGUST\n    if(august.nummer != 8){\n        fehler++\n        println(\"Fehler! Der August ist der 8. Monat im Kalenderjahr.\")\n    }\n    val september = Monat.SEPTEMBER\n    if(september.nummer != 9){\n        fehler++\n        println(\"Fehler! Der September ist der 9. Monat im Kalenderjahr.\")\n    }\n    val oktober = Monat.OKTOBER\n    if(oktober.nummer != 10){\n        fehler++\n        println(\"Fehler! Der Oktober ist der 10. Monat im Kalenderjahr.\")\n    }\n    val november = Monat.NOVEMBER\n    if(november.nummer != 11){\n        fehler++\n        println(\"Fehler! Der November ist der 11. Monat im Kalenderjahr.\")\n    }\n    val dezember = Monat.DEZEMBER\n    if(dezember.nummer != 12){\n        fehler++\n        println(\"Fehler! Der Dezember ist der 12. Monat im Kalenderjahr.\")\n    }\n}\ncatch(e: Exception){\n    println(e)\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 71,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.97"
   },
   "artifact_name": "c.84",
   "versions": [
    {
     "start_checkpoint": 1622446438359,
     "literal": "//Lösung\nenum class Monat(val nummer: Int){\n    JANUAR(1), FEBRUAR(2), MAERZ(3), APRIL(4), MAI(5), JUNI(6), JULI(7), AUGUST(8), SEPTEMBER(9), OKTOBER(10), NOVEMBER(11), DEZEMBER(12)\n}\n\n//Test\nvar fehler = 0\ntry{\n    val januar = Monat.JANUAR\n    if(januar.nummer != 1){\n        fehler++\n        println(\"Fehler! Der Januar ist der 1. Monat im Kalenderjahr.\")\n    }\n    val februar = Monat.FEBRUAR\n    if(februar.nummer != 2){\n        fehler++\n        println(\"Fehler! Der Februar ist der 2. Monat im Kalenderjahr.\")\n    }\n    val maerz = Monat.MAERZ\n    if(maerz.nummer != 3){\n        fehler++\n        println(\"Fehler! Der März ist der 3. Monat im Kalenderjahr.\")\n    }\n    val april = Monat.APRIL\n    if(april.nummer != 4){\n        fehler++\n        println(\"Fehler! Der April ist der 4. Monat im Kalenderjahr.\")\n    }\n    val mai = Monat.MAI\n    if(mai.nummer != 5){\n        fehler++\n        println(\"Fehler! Der Mai ist der 5. Monat im Kalenderjahr.\")\n    }\n    val juni = Monat.JUNI\n    if(juni.nummer != 6){\n        fehler++\n        println(\"Fehler! Der Juni ist der 6. Monat im Kalenderjahr.\")\n    }\n    val juli = Monat.JULI\n    if(juli.nummer != 7){\n        fehler++\n        println(\"Fehler! Der Juli ist der 7. Monat im Kalenderjahr.\")\n    }\n    val august = Monat.AUGUST\n    if(august.nummer != 8){\n        fehler++\n        println(\"Fehler! Der August ist der 8. Monat im Kalenderjahr.\")\n    }\n    val september = Monat.SEPTEMBER\n    if(september.nummer != 9){\n        fehler++\n        println(\"Fehler! Der September ist der 9. Monat im Kalenderjahr.\")\n    }\n    val oktober = Monat.OKTOBER\n    if(oktober.nummer != 10){\n        fehler++\n        println(\"Fehler! Der Oktober ist der 10. Monat im Kalenderjahr.\")\n    }\n    val november = Monat.NOVEMBER\n    if(november.nummer != 11){\n        fehler++\n        println(\"Fehler! Der November ist der 11. Monat im Kalenderjahr.\")\n    }\n    val dezember = Monat.DEZEMBER\n    if(dezember.nummer != 12){\n        fehler++\n        println(\"Fehler! Der Dezember ist der 12. Monat im Kalenderjahr.\")\n    }\n}\ncatch(e: Exception){\n    println(e)\n}\n\nif(fehler != 0)\n    println(\"Falsch! Es traten $fehler Fehler auf.\")\nelse\n    println(\"Richtig! Es traten keine Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 76,
      "ch": 50
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.85",
   "versions": [
    {
     "start_checkpoint": 1622448432636,
     "literal": "abstract class Software(protected val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(private val dateiformate: List<String>, name: String): Software(name){\n    public fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override public fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.86",
   "versions": [
    {
     "start_checkpoint": 1622448474944,
     "literal": "abstract class Software(protected val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(private val dateiformate: List<String>, name: String): Software(name){\n    public fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override public fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(private val anzahlSpieler: Int, name: String): Software(name){\n    public fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override public fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.98"
   },
   "artifact_name": "c.87",
   "versions": [
    {
     "start_checkpoint": 1622448670796,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\nval text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\ntext.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 15,
      "ch": 8
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.99"
   },
   "artifact_name": "c.88",
   "versions": [
    {
     "start_checkpoint": 1622448728040,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 22,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.100"
   },
   "artifact_name": "c.89",
   "versions": [
    {
     "start_checkpoint": 1622448767131,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.101"
   },
   "artifact_name": "c.90",
   "versions": [
    {
     "start_checkpoint": 1622448836926,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 28,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.102"
   },
   "artifact_name": "c.91",
   "versions": [
    {
     "start_checkpoint": 1622448873498,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    \n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\nComputerspiel::class.supertypes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 30,
      "ch": 30
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.103"
   },
   "artifact_name": "c.92",
   "versions": [
    {
     "start_checkpoint": 1622448912229,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(Computerspiel::class.supertypes is Software)\n        println(\"Fehler\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.104"
   },
   "artifact_name": "c.93",
   "versions": [
    {
     "start_checkpoint": 1622448923282,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(Computerspiel::class.supertypes is Software)\n        println(\"Fehler\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.105"
   },
   "artifact_name": "c.94",
   "versions": [
    {
     "start_checkpoint": 1622448961246,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(Computerspiel::class.supertypes is Software)\n        println(\"Fehler\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.106"
   },
   "artifact_name": "c.95",
   "versions": [
    {
     "start_checkpoint": 1622448968685,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(Computerspiel::class.supertypes !is Software)\n        println(\"Fehler\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.107"
   },
   "artifact_name": "c.96",
   "versions": [
    {
     "start_checkpoint": 1622449325160,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel is Software){\n        println(\"Fehler\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.108"
   },
   "artifact_name": "c.97",
   "versions": [
    {
     "start_checkpoint": 1622449328804,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        println(\"Fehler\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.109"
   },
   "artifact_name": "c.98",
   "versions": [
    {
     "start_checkpoint": 1622449386830,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        println(\"Fehler\")\n    }\n    if(text !is Software){\n        println(\"Fehler\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.110"
   },
   "artifact_name": "c.99",
   "versions": [
    {
     "start_checkpoint": 1622449412581,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        println(\"Fehler! Klasse Computerspiel erbt nicht von Software\")\n    }\n    if(text !is Software){\n        println(\"Fehler! Klasse Textverarbeitungssoftware erbt nicht von Software\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.111"
   },
   "artifact_name": "c.100",
   "versions": [
    {
     "start_checkpoint": 1622449427152,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        println(\"Fehler! Klasse Computerspiel erbt nicht von Software\")\n    }\n    if(text !is Software){\n        println(\"Fehler! Klasse Textverarbeitungssoftware erbt nicht von Software\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.112"
   },
   "artifact_name": "c.101",
   "versions": [
    {
     "start_checkpoint": 1622449455419,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        throw Exception(\"Test\")\n    }\n    if(text !is Software){\n        println(\"Fehler! Klasse Textverarbeitungssoftware erbt nicht von Software\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.113"
   },
   "artifact_name": "c.102",
   "versions": [
    {
     "start_checkpoint": 1622449459194,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel is Software){\n        throw Exception(\"Test\")\n    }\n    if(text !is Software){\n        println(\"Fehler! Klasse Textverarbeitungssoftware erbt nicht von Software\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.114"
   },
   "artifact_name": "c.103",
   "versions": [
    {
     "start_checkpoint": 1622449563208,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract)\n        throw AssertionError(\"Klasse Software ist nicht abstrakt.\")\n    if(spiel !is Software)\n        throw AssertionError(\"Klasse Computerspiel erbt nicht von Software.\")\n    if(text !is Software)\n        throw AssertionError(\"Klasse Textverarbeitungssoftware erbt nicht von Software.\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.115"
   },
   "artifact_name": "c.104",
   "versions": [
    {
     "start_checkpoint": 1622449581627,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract)\n        throw AssertionError(\"Klasse Software ist nicht abstrakt.\")\n    if(spiel !is Software)\n        throw AssertionError(\"Klasse Computerspiel erbt nicht von Software.\")\n    if(text !is Software)\n        throw AssertionError(\"Klasse Textverarbeitungssoftware erbt nicht von Software.\")\n    println(\"Super! Ihre Lösung ist richtig.\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 33,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.116"
   },
   "artifact_name": "c.105",
   "versions": [
    {
     "start_checkpoint": 1622461253120,
     "literal": "interface Liste2 {\n    var erster: Int\n    \n    fun hinzufuegen(wert: Int): Boolean\n    fun entfernen(): Int\n}\n\nListe2::class.typeParameters",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 27
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.117"
   },
   "artifact_name": "c.106",
   "versions": [
    {
     "start_checkpoint": 1622461274695,
     "literal": "interface Liste2 {\n    var erster: Int\n    \n    fun hinzufuegen(wert: Int): Boolean\n    fun entfernen(): Int\n}\n\nListe2::class.supertypes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 23
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.107",
   "versions": [
    {
     "start_checkpoint": 1622461346825,
     "literal": "data class Element(val wert: Int, var naechster: Element? = null)\n\ninterface Liste {\n    var erster: Element \n    \n    fun hinzufuegen(wert: Int): Boolean\n    fun entfernen(): Int\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.108",
   "versions": [
    {
     "start_checkpoint": 1622461925182,
     "literal": "data class Element(val wert: Int, var naechster: Element? = null)\n\n//Lösung\ninterface Liste {\n    var erster: Element? //nullable, da das erste Element leer sein kann\n    \n    fun hinzufuegen(wert: Int): Boolean //Parameter: Wert des Elements, Rückgabe: Erfolg\n    fun entfernen(): Int //Rückgabe des Werts des entfernten Elements\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.109",
   "versions": [
    {
     "start_checkpoint": 1622462322072,
     "literal": "class Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer]) {\n            parkplatz[nummer] = true\n        }\n        else {\n            throw ParkplatzVoll(nummer)\n        }\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Lösung\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    parkplatzverwaltung.einparken(2)\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.110",
   "versions": [
    {
     "start_checkpoint": 1622462349259,
     "literal": "class Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer]) {\n            parkplatz[nummer] = true\n        }\n        else {\n            println(\"Test\")\n            throw ParkplatzVoll(nummer)\n        }\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Lösung\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    parkplatzverwaltung.einparken(2)\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.118"
   },
   "artifact_name": "c.111",
   "versions": [
    {
     "start_checkpoint": 1622462409997,
     "literal": "class Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer])\n            parkplatz[nummer] = true\n        else\n            throw ParkplatzVoll(nummer)\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Lösung\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    try{\n        parkplatzverwaltung.einparken(2)\n    }\n    catch(e: ParkplatzVoll){\n        println(e)\n    }\n    \n}\n\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 36,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.119"
   },
   "artifact_name": "c.112",
   "versions": [
    {
     "start_checkpoint": 1622462466361,
     "literal": "class Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer])\n            parkplatz[nummer] = true\n        else\n            throw ParkplatzVoll(nummer)\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Lösung\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    \n    try {\n        parkplatzverwaltung.einparken(2)\n    }\n    catch(e: ParkplatzVoll) {\n        println(e)\n    }\n}\n\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 36,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.120"
   },
   "artifact_name": "c.113",
   "versions": [
    {
     "start_checkpoint": 1622462480225,
     "literal": "//Lösung\nclass Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer])\n            parkplatz[nummer] = true\n        else\n            throw ParkplatzVoll(nummer)\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    \n    try {\n        parkplatzverwaltung.einparken(2)\n    }\n    catch(e: ParkplatzVoll) {\n        println(e)\n    }\n}\n\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 36,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.121"
   },
   "artifact_name": "c.114",
   "versions": [
    {
     "start_checkpoint": 1622554526806,
     "literal": "class Liste<T> (var erster: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erster == null)\n            erster = Element<T>(wert)\n        else {\n            val alterErster = erster\n            erster = Element<T>(wert, alterErster)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val ersterNeu = erster\n        erster = ersterNeu?.naechster\n        return ersterNeu?.wert\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 24,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.122"
   },
   "artifact_name": "c.115",
   "versions": [
    {
     "start_checkpoint": 1622554535077,
     "literal": "class Liste<T> (var erster: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erster == null)\n            erster = Element<T>(wert)\n        else {\n            val alterErster = erster\n            erster = Element<T>(wert, alterErster)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val ersterNeu = erster\n        erster = erster?.naechster\n        return ersterNeu?.wert\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 24,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.123"
   },
   "artifact_name": "c.116",
   "versions": [
    {
     "start_checkpoint": 1622554558291,
     "literal": "class Liste<T> (var erster: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erster == null)\n            erster = Element<T>(wert)\n        else {\n            val alterErster = erster\n            erster = Element<T>(wert, alterErster)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erster?.wert\n        erster = erster?.naechster\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 24,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.124"
   },
   "artifact_name": "c.117",
   "versions": [
    {
     "start_checkpoint": 1622554574252,
     "literal": "class Liste<T> (var erster: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erster == null)\n            erster = Element<T>(wert)\n        else {\n            val alterErster = erster\n            erster = Element<T>(wert, alterErster)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erster?.wert\n        erster = erster?.naechster\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erster",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.125"
   },
   "artifact_name": "c.118",
   "versions": [
    {
     "start_checkpoint": 1622554722608,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erstes == null)\n            erstes = Element<T>(wert)\n        else {\n            val altesErstes = erstes\n            erstes = Element<T>(wert, erstes)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechster\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.126"
   },
   "artifact_name": "c.119",
   "versions": [
    {
     "start_checkpoint": 1622554905062,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        if (erstes == null)\n            erstes = Element<T>(wert)\n        else {\n            erstes = Element<T>(wert, erstes)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.120",
   "versions": [
    {
     "start_checkpoint": 1622554911490,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 20,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.121",
   "versions": [
    {
     "start_checkpoint": 1622554924020,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 20,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.127"
   },
   "artifact_name": "c.122",
   "versions": [
    {
     "start_checkpoint": 1622554928149,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 17,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.128"
   },
   "artifact_name": "c.123",
   "versions": [
    {
     "start_checkpoint": 1622554936285,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 18,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.129"
   },
   "artifact_name": "c.124",
   "versions": [
    {
     "start_checkpoint": 1622555013679,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 18,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.130"
   },
   "artifact_name": "c.125",
   "versions": [
    {
     "start_checkpoint": 1622555057935,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nfor (i in 1..10){\n    listeInt.hinzufuegen(i)\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 19,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.131"
   },
   "artifact_name": "c.126",
   "versions": [
    {
     "start_checkpoint": 1622555146041,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..10){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 10){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.132"
   },
   "artifact_name": "c.127",
   "versions": [
    {
     "start_checkpoint": 1622555280381,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..10){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 10){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 9){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 29,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.133"
   },
   "artifact_name": "c.128",
   "versions": [
    {
     "start_checkpoint": 1622555291808,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 10){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 9){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 29,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.134"
   },
   "artifact_name": "c.129",
   "versions": [
    {
     "start_checkpoint": 1622555329392,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 33,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.135"
   },
   "artifact_name": "c.130",
   "versions": [
    {
     "start_checkpoint": 1622555376241,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 37,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.136"
   },
   "artifact_name": "c.131",
   "versions": [
    {
     "start_checkpoint": 1622555441324,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht hinzugefügt werden.\")\n    }\n    \n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 41,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.132",
   "versions": [
    {
     "start_checkpoint": 1622555523519,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefügt werden.\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() != i){\n        fehler++\n        println(\"Fehler! Ein Element konnte nicht enfernt werden.\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.133",
   "versions": [
    {
     "start_checkpoint": 1622555546003,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefügt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() != i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. $listeInt\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.137"
   },
   "artifact_name": "c.134",
   "versions": [
    {
     "start_checkpoint": 1622555549197,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefügt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() == i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. $listeInt\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.138"
   },
   "artifact_name": "c.135",
   "versions": [
    {
     "start_checkpoint": 1622555562967,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefügt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() == i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.toString()}\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.139"
   },
   "artifact_name": "c.136",
   "versions": [
    {
     "start_checkpoint": 1622555573766,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefügt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() == i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.erstes?.toString()}\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.140"
   },
   "artifact_name": "c.137",
   "versions": [
    {
     "start_checkpoint": 1622555585074,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefügt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() == i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.erstes}\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.138",
   "versions": [
    {
     "start_checkpoint": 1622555682607,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefügt werden. ${listeInt.erstes}\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste. ${listeInt.erstes}\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() != i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.erstes}\")\n    }\n}\nif(listeInt.entfernen() != null){\n        fehler++\n        println(\"Fehler! Obwohl kein Element mehr entfernt werden können sollte, wurde ein Wert zurückgegeben. ${listeInt.erstes}\")\n    }\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 50,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.141"
   },
   "artifact_name": "c.139",
   "versions": [
    {
     "start_checkpoint": 1622555767250,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefügt werden. ${listeInt.erstes}\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste. ${listeInt.erstes}\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() != i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.erstes}\")\n    }\n}\nif(listeInt.entfernen() != null){\n        fehler++\n        println(\"Fehler! Obwohl kein Element mehr entfernt werden können sollte, wurde ein Wert zurückgegeben. ${listeInt.erstes}\")\n}\n\nif(fehler == 0)\n    println(\"Super! Ihre Lösung hat alle Tests bestanden.\")\nelse\n    println(\"Falsch! Es traten bei $fehler Tests Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 54,
      "ch": 61
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.142"
   },
   "artifact_name": "c.140",
   "versions": [
    {
     "start_checkpoint": 1622557161983,
     "literal": "class Person(public val name: String)\n\nval p1 = Person(\"test\")\np1.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.143"
   },
   "artifact_name": "c.141",
   "versions": [
    {
     "start_checkpoint": 1622557178954,
     "literal": "class Person(internal val name: String)\n\nval p1 = Person(\"test\")\np1.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.144"
   },
   "artifact_name": "c.142",
   "versions": [
    {
     "start_checkpoint": 1622557527039,
     "literal": "class LesbarePerson(name: String){\n    private val name = name\n    get() = field\n}\nval p1 = Person(\"test\")\np1.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.145"
   },
   "artifact_name": "c.143",
   "versions": [
    {
     "start_checkpoint": 1622557707412,
     "literal": "class LesbarePerson(name: String){\n    var name = name\n    get() = field\n    private set(neuerWert){\n        field = neuerWert\n    }\n}\nval p1 = Person(\"test\")\np1.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 6
     }
    }
   ]
  }
 ],
 "markdownCells": [
  {
   "artifact_name": "m.0",
   "versions": [
    {
     "start_checkpoint": 1619004012983,
     "parent": "n.0.0",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes wird die objektorientierte Programmierung sein.\n\n## Lektion 1 - Einführung\nAufgrund der Kompatibilität mit Java ist Kotlin eine objektorientierte Sprache. Dabei werden alle Daten als Objekte behandelt. Es sind alle bekannten objektorientierte Konzepte vorhanden, jedoch angepasst und teilweise auch vereinfacht. Dazu ein Beispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt, `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>\n\nEs ist zu erkennen, dass der Kotlincode deutlich kürzer und auch übersichtlicher ist. Jedoch wird er Ihnen aktuell wenig aussagen. In den folgenden Lektionen wird das Beispiel Schritt für Schritt erklärt.\n\n## Lektion 2 - Felder"
    }
   ]
  },
  {
   "artifact_name": "m.1",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.11",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes wird die objektorientierte Programmierung sein.\n\n## Lektion 1 - Klassen\nAufgrund der Kompatibilität mit Java ist auch Kotlin eine objektorientierte Sprache. Deswegen werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind alle bekannten objektorientierte Konzepte vorhanden, jedoch angepasst und teilweise auch vereinfacht. Dazu ein Einführungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.2",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.24",
     "markdown": "Es ist zu erkennen, dass der Kotlincode deutlich kürzer und übersichtlicher ist. Warum er so aussieht wird in den folgenden Lektionen genauer besprochen.\n\n### Felder\nFelder können Klassen einfach Hinzugefügt werden. Die erste Möglichkeit ist durch die Übergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei öffentlicher Sichtbarkeit eine Variablenart (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heißt es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, welches bei Objekterzeugung mit dem Wert des Übergabeparameters gefüllt wird. Außerdem wird immer ein unsichtbarer Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, wird zusätzlich ein rudimentärer Setter der Klasse hinzugefügt."
    }
   ]
  },
  {
   "artifact_name": "m.3",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "Eine weitere Möglichkeit Felder zu definieren ist klassisch zu Beginn im Rumpf der Klasse. Diese werden jedoch nicht automatisch bei Objekterzeugung, sondern mit dem angegebenen Standardwert gefüllt. Diesen wird auch je nach Typ im Hintergrund ein Getter und Setter bei Seite gestellt."
    },
    {
     "start_checkpoint": 1622204182191,
     "parent": "n.0.116",
     "markdown": "Eine weitere Möglichkeit Felder zu definieren ist klassisch im Rumpf der Klasse. Diese werden jedoch nicht automatisch bei Objekterzeugung, sondern mit den angegebenen Standardwerten befüllt. Des Weiteren wird auch diesen Feldern je nach Typ im Hintergrund ein Getter und Setter bei Seite gestellt."
    }
   ]
  },
  {
   "artifact_name": "m.4",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder mit Werten bestückt werden. Aufgrund des Konstruktorwirrars in Java, unterscheidet Kotlin zwischen 2 verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n#### Primärer Konstruktor\nDer primäre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204322287,
     "parent": "n.0.30",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder bei Objekterzeugung mit Werten bestückt werden. Aufgrund des Konstruktorwirrars in Java, unterscheidet Kotlin zwischen 2 verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n#### Primärer Konstruktor\nDer primäre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204355567,
     "parent": "n.0.31",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder bei Objekterzeugung mit Werten bestückt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n#### Primärer Konstruktor\nDer primäre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204374734,
     "parent": "n.0.32",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder bei Objekterzeugung mit Werten bestückt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n#### Primärer Konstruktor\nDer primäre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204384000,
     "parent": "n.0.33",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder bei Objekterzeugung mit Werten bestückt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n#### Primärer Konstruktor\nDer primäre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204391516,
     "parent": "n.0.34",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder bei Objekterzeugung mit Werten bestückt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\n#### Primärer Konstruktor\nDer primäre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204421079,
     "parent": "n.0.35",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder bei Objekterzeugung mit Werten bestückt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\n#### Primärer Konstruktor\nDer primäre Konstruktor ist für die eigentliche Erzeugung der Objekte zuständig und besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204433050,
     "parent": "n.0.36",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder bei Objekterzeugung mit Werten bestückt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\n#### Primärer Konstruktor\nDer primäre Konstruktor ist für die eigentliche Erzeugung der Objekte zuständig und besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm Folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204441673,
     "parent": "n.0.37",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder bei Objekterzeugung mit Werten bestückt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\n#### Primärer Konstruktor\nDer primäre Konstruktor ist für die eigentliche Erzeugung der Objekte zuständig und besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm Folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDer Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204457914,
     "parent": "n.0.121",
     "markdown": "### Konstruktor\nMit dem Konstruktor können die Felder bei Objekterzeugung mit Werten bestückt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\n#### Primärer Konstruktor\nDer primäre Konstruktor ist für die eigentliche Erzeugung der Objekte zuständig und besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm Folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDer Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler für alle Parameter, denen ein Variablentyp zugewiesen wurde, generiert.  "
    }
   ]
  },
  {
   "artifact_name": "m.5",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "##### Konstruktor mit `init`-Block\nNatürlich kann der Konstruktor auch selbst, wie in Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlüsselwort `init` gefolgt von einem Methodenrumpf. Anders als von Java gewöhnt werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter können im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlüsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204457914,
     "parent": "n.0.38",
     "markdown": "##### Konstruktor mit init-Block\nNatürlich kann der Konstruktor auch selbst, wie in Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlüsselwort `init` gefolgt von einem Methodenrumpf. Anders als von Java gewöhnt werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter können im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlüsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204477080,
     "parent": "n.0.39",
     "markdown": "##### Konstruktor mit init-Block\nNatürlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlüsselwort `init` gefolgt von einem Methodenrumpf. Anders als von Java gewöhnt werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter können im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlüsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204494036,
     "parent": "n.0.40",
     "markdown": "##### Konstruktor mit init-Block\nNatürlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlüsselwort `init`, gefolgt von einem Methodenrumpf. Anders als von Java gewöhnt werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter können im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlüsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204513712,
     "parent": "n.0.41",
     "markdown": "##### Konstruktor mit init-Block\nNatürlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlüsselwort `init`, gefolgt von einem Methodenrumpf. Im Vergleich zu Java werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter können im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlüsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204534951,
     "parent": "n.0.116",
     "markdown": "##### Konstruktor mit init-Block\nNatürlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlüsselwort `init`, gefolgt von einem Methodenrumpf. Im Vergleich zu Java werden dessen Parameter nicht direkt im Kopf des Konstruktors, sondern im Kopf der Klasse angegeben. Die dort definierten Parameter können im Konstruktor benutzt werden. Bei Namenskonflikten findet das Schlüsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    }
   ]
  },
  {
   "artifact_name": "m.6",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "##### Konstruktor durch direkte Initialisierung\nEine weitere Möglichkeit der Initialisierung ist die Felder direkt bei der Deklaration den Parametern oder festgelegten Werten zuzuweisen."
    },
    {
     "start_checkpoint": 1622204534951,
     "parent": "n.0.121",
     "markdown": "##### Konstruktor durch direkte Initialisierung\nEine weitere Möglichkeit der Initialisierung ist, die Felder direkt bei der Deklaration Parameter oder festgelegte Werte zuzuweisen."
    }
   ]
  },
  {
   "artifact_name": "m.7",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "##### Vergleich\nJede Erscheinungsform des Konstruktors hat seine Vorteile und Anwendungsbereiche. Während der Defaultkonstruktor bei einfachen Klassen, bei denen nicht mit den Übergabedaten vor der Zuweisung gearbeitet werden, zu bevorzugen ist, bieten die expliziten Konstruktoren genau das. Auf dem ersten Blick scheint es so, als benötige man den Konstruktor mit einem `init`-Block nicht, da die Parameter scheinbar mit dem gleichen Ergebnis direkt zugewiesen werden können. Jedoch ist dieser bei komplexeren Klassen zu bevorzugen, da dort alle Daten erst auf Richtigkeit geprüft werden und so beispielweise auch mit `try` und `catch` gearbeitet werden kann (näheres dazu in [Lektion X](Lektion-X---Fehlerbehandlung)).\n\n##### Kombination\nDie verschiedenen Konstruktoren können auch beliebig miteinander kombiniert werden. "
    }
   ]
  },
  {
   "artifact_name": "m.8",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "##### Mehrere primäre Konstruktoren\nEine wichtige Eigenschaft einer Klasse fehlt aber noch: Die Erzeugung eines Objekts mit unterschiedlichen Parameterprofilen. Dazu können in der Klasse mehrere primäre Konstruktoren implementiert werden. Diesen wird das Schlüsselwort `constructor` vorangestellt. Außerdem bekommt jeder Konstruktor sein eigenes Parameterprofil, mit dem dieser dann in dessen Rumpf arbeiten kann. Die Konstruktoren ähnelm dabei dem `init`-Verfahren, da sie alle ihren eigenen Rumpf besitzen. Die Parameterklammern der Klasse werden weggelassen."
    }
   ]
  },
  {
   "artifact_name": "m.9",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "markdown": "#### Sekundärer Konstruktor"
    },
    {
     "start_checkpoint": 1619167525913,
     "parent": "n.0.25",
     "markdown": "#### Sekundärer Konstruktor\nMit Hilfe eines sekundären Konstruktors ist es einfach möglich alternative Objekterzeugungen zu implementierten. Dazu wird ein primärer Konstruktor mit `this()` mit zu bestimmenden Parametern aufgerufen. Auch kann ein anderer sekündärer Konstruktor aufgerufen, jedoch muss am Ende ein Primärer benutzt werden, da nur dieser das Objekt erzeugen kann. Die Implementierung eines sekundären Konstruktors ähnelt der bei Benutzung mehrerer primärer Konstruktoren. Jedoch ist nur eine Anweisung erlaubt, die von den Parametern mit `:` getrennt wird. Diese muss einen Konstruktor aufrufen (`this()` oder `super()`)."
    },
    {
     "start_checkpoint": 1622205474347,
     "parent": "n.0.116",
     "markdown": "#### Sekundärer Konstruktor\nMit Hilfe eines sekundären Konstruktors ist es einfach möglich alternative Wege Objekte zu erzeugen bereitzustellen. Dazu wird ein primärer Konstruktor mit `this()` und zu bestimmenden Parametern aufgerufen. Auch kann ein anderer sekündärer Konstruktor aufgerufen, jedoch muss am Ende immer ein Primärer benutzt werden, da nur dieser das Objekt erzeugen kann. Die Implementierung eines sekundären Konstruktors ähnelt der bei Benutzung mehrerer primärer Konstruktoren. Jedoch ist nur eine Anweisung erlaubt, die von den Parametern mit `:` getrennt wird und einen primären Konstruktor aufruft."
    }
   ]
  },
  {
   "artifact_name": "m.10",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.8",
     "markdown": "## Lektion X - Fehlerbehandlung"
    }
   ]
  },
  {
   "artifact_name": "m.11",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.24",
     "markdown": "### Aufgabe\nImplementieren Sie eine Klasse `Pizza`. Jede Pizza soll eine Größe `groeße` (zwischen 15 und 30 [cm], ansonsten -1) und eine Liste aus Belägen `belaege` (Standardmäßig bereits mit Tomatensoße und Käse befüllt) enthalten. Außerdem soll gespeichert werden, ob sie geschnitten `geschnitten` werden soll. Wählen Sie einen passenden primären Konstruktor, der für jedes Feld einen Übergabeparameter besitzt. Fügen Sie außerdem weitere (sekundäre) Konstruktoren hinzu, die eine Pizza Magaritha (Tomatensoße, Mozzarella) und eine 25cm Pizza al Tonno (Tomatensoße, Mozzarella, Thunfisch, Zwiebeln, Peperoni) initialisieren. Beide Pizzas sollen geschnitten werden."
    }
   ]
  },
  {
   "artifact_name": "m.12",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.25",
     "markdown": "### Getter und Setter\nEs können aber auch eigene Getter und Setter für jedes Feld definiert werden, falls der Variablentyp dies zulässt. Sie müssen direkt nach den Feld definiert werden. Auf der aktuelle Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter übergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert repräsentiert. Ein Wert wird dem Feld mit einer Zuweisung an `field` geändert. Es sind immer die Datentypen der Felder zu beachten."
    },
    {
     "start_checkpoint": 1622205474347,
     "parent": "n.0.44",
     "markdown": "### Getter und Setter\nEs können aber auch eigene Getter und Setter für jedes Feld definiert werden, falls der Variablentyp dies zulässt und diese erst im Rumpf der Klasse definiert werden. Sie müssen direkt nach den Feld definiert werden. Auf der aktuelle Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter übergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert repräsentiert. Ein Wert wird dem Feld mit einer Zuweisung an `field` geändert. Es sind immer die Datentypen der Felder zu beachten."
    },
    {
     "start_checkpoint": 1622205682750,
     "parent": "n.0.45",
     "markdown": "### Getter und Setter\nEs können aber auch eigene Getter und Setter für jedes Feld definiert werden, falls der Variablentyp dies zulässt und diese erst im Rumpf der Klasse definiert werden. Beide müssen direkt nach den Feld definiert werden. Auf der aktuelle Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter übergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert repräsentiert. Ein Wert wird dem Feld mit einer Zuweisung an `field` geändert. Es sind immer die Datentypen der Felder zu beachten."
    },
    {
     "start_checkpoint": 1622205747266,
     "parent": "n.0.116",
     "markdown": "### Getter und Setter\nEs können aber auch eigene Getter und Setter für jedes Feld definiert werden, falls der Variablentyp dies zulässt und diese erst im Rumpf der Klasse definiert werden. Beide müssen direkt nach den Feld definiert werden. Auf den aktuellen Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter übergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert repräsentiert. Der Wert des Feldes wird mit einer Zuweisung an `field` geändert. Es sind immer die Datentypen der Felder zu beachten."
    }
   ]
  },
  {
   "artifact_name": "m.13",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "#### Computed Properties\nDurch die Definition eigener Getter können Felder auch kleine Methoden darstellen ohne einen eigenen Wert zu speichern. So können beispielsweise berechnete Wahrheitswerte zurückgegeben werden. Diese Handhabung kann rudimentäre Methoden ersetzen. Als Beispiel wird die bereits kennengelernte Klasse `Person` mit einem berechnetem Feld `istVolljaerig` ergänzt."
    },
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.121",
     "markdown": "#### Computed Properties\nDurch die Definition eigener Getter können Felder auch *kleine Methoden* darstellen ohne einen eigenen Wert zu speichern. So können beispielsweise berechnete Wahrheitswerte zurückgegeben werden. Dadurch können rudimentäre Methoden ersetzt werden. Als Beispiel wird die bereits kennengelernte Klasse `Person` mit einem berechneten Feld `istVolljaerig` ergänzt."
    }
   ]
  },
  {
   "artifact_name": "m.14",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlüsselwort `by lazy` träge gemacht werden. Das heißt, dass der Wert erst bei Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck nötig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Wert jedoch nicht noch einmal berechnet, sondern der gespeicherte Wert wird verwendet.\n\nQuiz: Wie oft wird \"Wird berechnet...\" ausgegeben?"
    },
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.47",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlüsselwort `by lazy` *träge* gemacht werden. Das heißt, dass der Wert erst bei Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck nötig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Wert jedoch nicht noch einmal berechnet, sondern der gespeicherte Wert wird verwendet.\n\nQuiz: Wie oft wird \"Wird berechnet...\" ausgegeben?"
    },
    {
     "start_checkpoint": 1622209186075,
     "parent": "n.0.48",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlüsselwort `by lazy` *träge* gemacht werden. Das heißt, dass der Wert erst bei der ersten Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck nötig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Wert jedoch nicht noch einmal berechnet, sondern der gespeicherte Wert wird verwendet.\n\nQuiz: Wie oft wird \"Wird berechnet...\" ausgegeben?"
    },
    {
     "start_checkpoint": 1622209235576,
     "parent": "n.0.116",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlüsselwort `by lazy` *träge* gemacht werden. Das heißt, dass der Wert erst bei der ersten Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck nötig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Inhalt nicht noch einmal berechnet, sondern der gespeicherte Wert wird verwendet."
    }
   ]
  },
  {
   "artifact_name": "m.15",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "#### `lateinit`\nEin weiteres ähnliches Konstrukt ist `lateinit`. Dies findet Anwendung, wenn ein Feld erst nach der Objekterzeugung einen Wert zurgewiesen bekommt. Dieses Feld kann dann im Konstruktor ignoriert werden.<br />\nVorraussetzungen:\n* Das Feld ist vom Typ `var`\n* Der Datentyp des Feldes ist nonnullable\n* Der Datentyp des Feldes ist nicht primitiv"
    },
    {
     "start_checkpoint": 1622209235576,
     "parent": "n.0.121",
     "markdown": "#### `lateinit`\nEin weiteres, ähnliches Konstrukt ist `lateinit`. Dies findet Anwendung, wenn ein Feld erst nach der Objekterzeugung einen Wert zugewiesen bekommt. Dieses Feld kann im Konstruktor ignoriert werden.  \nVorraussetzungen:\n* Das Feld ist vom Typ `var`\n* Der Datentyp des Feldes ist *non-nullable*\n* Der Datentyp des Feldes ist nicht primitiv"
    }
   ]
  },
  {
   "artifact_name": "m.16",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Einem `lateinit` Feld ist zusätzlich gespeichert, ob es bereits initialisiert wurde. Diese Information kann mit `this::name.isInitialized` abgerufen werden."
    },
    {
     "start_checkpoint": 1622209235576,
     "parent": "n.0.49",
     "markdown": "In einem `lateinit` Feld ist zusätzlich gespeichert, ob es bereits initialisiert wurde. Diese Information kann mit `this::name.isInitialized` abgerufen werden."
    },
    {
     "start_checkpoint": 1622209406266,
     "parent": "n.0.121",
     "markdown": "In einem `lateinit` Feld ist zusätzlich gespeichert, ob es bereits für das Objekt initialisiert wurde. Diese Information kann mit `this::name.isInitialized` abgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.17",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "### Sichtbarkeiten\nBis jetzt wurden alle Variablen, Felder und Klassen öffentlich implementiert. Jedoch gibt es in Kotlin wie auch in Java Sichtbarkeiten, mit denen der Zugriff eingeschränkt werden kann.\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden."
    },
    {
     "start_checkpoint": 1622209406266,
     "parent": "n.0.50",
     "markdown": "### Sichtbarkeiten\nBis jetzt wurden alle Variablen, Felder und Klassen öffentlich implementiert. Jedoch gibt es in Kotlin, wie auch in Java, Sichtbarkeiten, mit denen der Zugriff eingeschränkt werden kann.\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden."
    },
    {
     "start_checkpoint": 1622209516136,
     "parent": "n.0.121",
     "markdown": "### Sichtbarkeiten\nBis jetzt wurden alle Variablen, Felder und Klassen öffentlich implementiert. Jedoch gibt es in Kotlin, wie auch in Java, Sichtbarkeiten, mit denen der Zugriff eingeschränkt werden kann.\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können Sie sich als größere Pakete vorgestellen.\n* `public`: Das Element kann überall benutzt werden."
    }
   ]
  },
  {
   "artifact_name": "m.18",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "### Methoden\nObjektmethoden sind mit normalen statischen Methoden zu vergleichen. Es kann die Kurzschreibweise angewendet und eine Sichtbarkeit zugewiesen werden. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits generierte Methode, zum Beispiel `toString()`, überschrieben werden, muss der Methode das Schlüsselwort `override` vorangestellt werden."
    },
    {
     "start_checkpoint": 1622209516136,
     "parent": "n.0.51",
     "markdown": "### Methoden\nDer Aufbau von Objektmethoden kann mit dem von Funktionen verglichen werden. Es kann die Kurzschreibweise angewendet und eine Sichtbarkeit zugewiesen werden. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits implementierte Methode, zum Beispiel `toString()`, überschrieben werden, muss der Methode das Schlüsselwort `override` vorangestellt werden."
    },
    {
     "start_checkpoint": 1622209678258,
     "parent": "n.0.52",
     "markdown": "### Methoden\nDer Aufbau von Objektmethoden kann mit dem von Funktionen verglichen werden, werden jedoch im Rumpf einer Klasse definiert. Es kann die Kurzschreibweise angewendet und eine Sichtbarkeit zugewiesen werden. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits implementierte Methode, zum Beispiel `toString()`, überschrieben werden, muss der Methode das Schlüsselwort `override` vorangestellt werden."
    },
    {
     "start_checkpoint": 1622209719335,
     "parent": "n.0.116",
     "markdown": "### Methoden\nDer Aufbau von Objektmethoden kann mit dem von Funktionen verglichen werden, werden jedoch im Rumpf einer Klasse definiert. Es kann die Kurzschreibweise angewendet und eine Sichtbarkeit zugewiesen werden. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits implementierte Methode, zum Beispiel `toString()`, überschrieben werden, ist das Voranstellen des Schlüsselworts `override` nötig."
    }
   ]
  },
  {
   "artifact_name": "m.19",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.8",
     "markdown": "### Aufgabe ??"
    }
   ]
  },
  {
   "artifact_name": "m.20",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "## Lektion 2 - Datenklassen\nZusätzlich zu normalen Klassen bietet Kotlin auch die Möglichkeit Klassen zu erstellen, die nur die Aufgabe der Speicherung von Daten haben. Auf den ersten Blick könnte dies auch mit normalen Klassen bewerkstelligt werden. Jedoch müssen dann alle Methoden per Hand implementiert werden. Beispielsweise `toString()`oder auch `equals()`. Um dem aus dem Weg zu gehen, gibt es Datenklassen. Für diese generiert der Kotlin-Compiler im Hintergrund folgende Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Gekennzeichnet werden Datenklassen mit dem Schlüsselwort `data class`."
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.57",
     "markdown": "## Lektion 2 - Datenklassen\nZusätzlich zu normalen Klassen bietet Kotlin auch die Möglichkeit Klassen zu erstellen, die nur die Aufgabe der Speicherung von Daten haben. Auf den ersten Blick könnte dies auch mit normalen Klassen bewerkstelligt werden. Jedoch müssen dann alle Methoden, die eine Datenklasse in der Regel benötigt, per Hand implementiert werden. Beispiele dafür sind `toString()` oder `equals()`. Um dem aus dem Weg zu gehen, gibt es Datenklassen. Für diese generiert der Kotlin-Compiler im Hintergrund folgende Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Gekennzeichnet werden Datenklassen mit dem Schlüsselwort `data class`."
    },
    {
     "start_checkpoint": 1622210381391,
     "parent": "n.0.116",
     "markdown": "## Lektion 2 - Datenklassen\nZusätzlich zu normalen Klassen bietet Kotlin auch die Möglichkeit Klassen zu erstellen, die nur die Aufgabe der Speicherung von Daten haben. Auf den ersten Blick könnte dies auch mit normalen Klassen bewerkstelligt werden. Jedoch müssen dann alle Methoden, die eine Datenklasse in der Regel benötigt, per Hand implementiert werden. Beispiele dafür sind `toString()` oder `equals()`. Um dem aus dem Weg zu gehen, gibt es Datenklassen. Für diese generiert der Kotlin-Compiler im Hintergrund folgende Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Gekennzeichnet werden Datenklassen mit dem Schlüsselwort `data class`. Alle Felder, die bei den generierten Methoden berücksichtigt werden sollen, müssen in dem Kopf der Datenklasse angegeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.21",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Durch die Verwendung der `componentN()`-Methode kann auf mehrere Felder der Datenklasse zugeggriffen werden. Dabei bekommt jedes Feld eine eigene Nummer, beispielsweise x die Nummer 1, zugewisen. Wird `N` durch die Nummer ersetzt und auf dem Objekt aufgerufen, wird das Feld zurückgegeben. Auch können dadurch mehrere Felder abgerufen werden, indem eine Folge als Rückgabe erwartet wird."
    },
    {
     "start_checkpoint": 1622209870934,
     "parent": "n.0.116",
     "markdown": "Durch die Verwendung der `componentN()`-Methode kann auf die Felder der Datenklasse zugeggriffen werden. Dabei bekommt jedes Feld eine eigene Nummer, beispielsweise in der Klasse 'Punkt' 'x' die Nummer 1, zugewisen. Wird `N` durch die Nummer ersetzt und auf einem Objekt aufgerufen, wird das Feld zugehörige zurückgegeben. Auch können dadurch mehrere Felder abgerufen werden, indem eine Folge als Rückgabe erwartet wird."
    }
   ]
  },
  {
   "artifact_name": "m.22",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Mit Hilfe von `copy()` kann ein neues Objekt mit den gleichen Daten erzeugt werden. Sollen bestimmte Felder aber einen anderen Wert bekommen, kann dies der Methode mit Namen des Feldes und dem gewünschten Wert übergeben werden."
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.116",
     "markdown": "Mit Hilfe von `copy()` kann ein neues Objekt mit den gleichen Daten erzeugt werden. Soll aber bestimmten Feldern einen anderer Wert zugewiesen werden, kann dies der Methode mit Namen des Feldes und dem gewünschten Wert übergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.23",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Zusätzlich können auch weitere Felder in der Datenklasse hinzugefügt werden. Diese werden jedoch nicht bei den automatisch generierten Methoden berücksichtigt. Außerdem darf der primäre Konstruktor keine Parameter besitzen. Somit können die eigens erstellten Felder in der Klasse nur berechnet und nicht mit einem Parameter gefüllt werden."
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.57",
     "markdown": "Zusätzlich können auch weitere Felder in den Rumpf einer Datenklasse hinzugefügt werden. Diese werden jedoch nicht bei den automatisch generierten Methoden berücksichtigt. Außerdem darf der primäre Konstruktor keine Parameter besitzen. Somit können die eigens erstellten Felder in der Klasse nur berechnet und nicht mit einem Parameter gefüllt werden."
    },
    {
     "start_checkpoint": 1622210381391,
     "parent": "n.0.121",
     "markdown": "Zusätzlich können auch weitere Felder in den Rumpf einer Datenklasse definiert werden. Diese werden jedoch nicht bei den automatisch generierten Methoden berücksichtigt. Außerdem darf der primäre Konstruktor einer Datenklasse keine *freien* Parameter besitzen. Es wird nur der Defaultkonstruktor unterstützt. Somit können die eigens erstellten Felder im Rumpf der Klasse nur berechnet und nicht mit einem Parameter gefüllt werden."
    }
   ]
  },
  {
   "artifact_name": "m.24",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.24",
     "markdown": "### Aufgabe - TODO"
    }
   ]
  },
  {
   "artifact_name": "m.25",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "## Lektion 3 - Objekte\nEine Besonderheit von Kotlin ist, dass nicht jedes Objekt eine Klasse benötigt. Dadurch kann beispielsweise ein statisches Feld simuliert werden oder unkompliziert mehrere Daten an einem Ort zusammengefasst werden.\n### Ad-hoc Objekte\nMit sogeannten Ad-hoc Objekten können Daten ähnlich einer Map komprimiert werden. Es kann ein Objekt erzeugt werden ohne vorher eine Klasse angelegt zu haben. Dies ist mit dem Schlüsselwort `object` einzuleiten. Wie auch einer Klasse können dem Ad-hoch Objekt Felder zugewiesen werden."
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.116",
     "markdown": "## Lektion 3 - Objekte\nEine Besonderheit von Kotlin ist, dass nicht jedes Objekt eine Klasse benötigt. Dadurch kann beispielsweise ein statisches Feld simuliert oder unkompliziert mehrere Daten an einem Ort zusammengefasst werden.\n### Ad-hoc Objekte\nMit sogeannten Ad-hoc Objekten können Daten ähnlich einer Map komprimiert werden. Es kann ein Objekt erzeugt werden ohne vorher eine Klasse angelegt zu haben. Dies ist mit dem Schlüsselwort `object` einzuleiten. Wie auch einer Klasse können dem Ad-hoch Objekt Felder zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.26",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "### Singletons\nSingletons sind Objekte, die nur ein Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Ein solches Objekt wird mit dem Schlüsselwort `object` gekennzeichnet und kann nicht einer Variable zugewiesen werden, da es erst bei der ersten Benutzung erzeugt wird. Deswegen kann es auch nicht erzeugt werden. Dies wird automatisch beim ersten Aufruf, der in der Punktnotation mit dem Namen des Singletons erfolgt. Ein Singleton kann aus Feldern und Methoden bestehen. Ein Konstruktor kann jedoch nicht angewendet werden, da die Erzeugung ohne Übergabeparameter stattfindet."
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.116",
     "markdown": "### Singletons\nSingletons sind Objekte, die nur ein Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Ein solches Objekt wird mit dem Schlüsselwort `object` gekennzeichnet und kann nicht einer Variable zugewiesen werden, da es erst bei der ersten Benutzung erzeugt wird. Deswegen kann es auch nicht erzeugt werden. Die Erzeugung erfolgt automatisch beim ersten Aufruf, der in der Punktnotation mit dem Namen des Singletons erfolgt. Ein Singleton kann aus Feldern und Methoden bestehen. Ein Konstruktor kann jedoch nicht angewendet werden, da die Erzeugung ohne Übergabeparameter stattfindet."
    }
   ]
  },
  {
   "artifact_name": "m.27",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.8",
     "markdown": "### Companion Objekte\nEiner Klasse können sogenannte Companion Objekte angehängt werden. Diese sind für alle Objekte der Klasse gleich und ähneln somit statischen Variablen oder Methoden. Sie können nur in einer Klasse implementiert werden und besitzen das Schlüsselwort `companion object`. Im Hintergrund ist ein solches Konstrukt nichts weiter als ein Singleton einer Klasse das alle Objekte verwenden können. In dem Objekt können Felder und Methoden implementiert werden."
    }
   ]
  },
  {
   "artifact_name": "m.28",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Falls in einer Klasse mehrere Companion Objekte gewünscht sind, ist ab dem Zweiten das Schlüsselwort `companion` wegzulassen und außerdem ein Name anzugeben. Außerhalb der Klasse kann auf das Objekt nur durch die Klasse und nicht einem Objekt der Klasse zugegriffen werden."
    },
    {
     "start_checkpoint": 1622211105740,
     "parent": "n.0.116",
     "markdown": "Falls in einer Klasse mehrere Companion Objekte gewünscht werden, ist ab dem Zweiten das Schlüsselwort `companion` wegzulassen und außerdem ein Name anzugeben. Außerhalb der Klasse kann auf das Objekt nur durch die Klasse und nicht einem Objekt der Klasse zugegriffen werden."
    }
   ]
  },
  {
   "artifact_name": "m.29",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.24",
     "markdown": "### Aufgabe\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz repräsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Länge 5 verwirklicht werden. Ist ein Parkplatz belegt, so soll an diesem Eintrag `true` stehen. Benutzen Sie passende Sichtbarkeiten. Standardmäßig wird bei Erzeugung eine passendes Liste übergeben. Falls kein Parameter übergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zusätzlich eine Methode `einparken()` die die Nummer des Parkplatzes übergeben bekommt und diesen belegt falls möglich. Bei Erfolg soll `true` zurückgegebn werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter übergeben werden. Überschreiben Sie zusätzlich die Methode `toString()`, die den Parkplatz übersichtlich nach folgendem Muster ausgegeben soll: <br />\n<p>--x-- (Parkplatz Nummer 2 ist belegt)</p>"
    }
   ]
  },
  {
   "artifact_name": "m.30",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.47",
     "markdown": "### Companion Objekte\nEiner Klasse können sogenannte Companion Objekte angehängt werden. Diese sind für alle Objekte der Klasse gleich und ähneln somit statischen Variablen oder Methoden. Sie können nur in einer Klasse implementiert werden und besitzen das Schlüsselwort `companion object`. Im Hintergrund ist ein solches Konstrukt nichts weiter als ein Singleton einer Klasse das alle Objekte verwenden können. In dem Objekt können Felder und Methoden implementiert werden.<br />\nAnstelle eines Companion Objects könnte auch eine Top-Level-Variable verwendet werden. Jedoch läge dort kein Zusammenhang zwischen den Klassen vor und die Variable könnte auch von anderen Objekten verändert werden."
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.63",
     "markdown": "### Companion Objekte\nEiner Klasse können sogenannte Companion Objekte angehängt werden. Diese sind für alle Objekte der Klasse gleich und ähneln somit statischen Variablen oder Methoden. Sie können nur in einer Klasse implementiert werden und besitzen das Schlüsselwort `companion object`. Im Hintergrund ist ein solches Konstrukt nichts weiter als ein Singleton einer Klasse, das alle Objekte verwenden können. In dem Objekt können Felder und Methoden implementiert werden.<br />\nAnstelle eines Companion Objects könnte auch eine Top-Level-Variable verwendet werden. Jedoch läge dort kein Zusammenhang zwischen den Klassen vor und die Variable könnte auch von anderen Objekten verändert werden."
    },
    {
     "start_checkpoint": 1622211105740,
     "parent": "n.0.121",
     "markdown": "### Companion Objekte\nEiner Klasse können sogenannte Companion Objekte angehängt werden. Diese sind für alle Objekte der Klasse gleich und ähneln somit statischen Variablen oder Methoden. Sie können nur in einer Klasse implementiert werden und besitzen das Schlüsselwort `companion object`. Im Hintergrund ist ein solches Konstrukt nichts weiter als ein Singleton einer Klasse, das alle Objekte verwenden können. In dem Objekt können Felder und Methoden implementiert werden.  \nAnstelle eines Companion Objects könnte auch eine Top-Level-Variable verwendet werden. Jedoch läge dort kein Zusammenhang zwischen den Klassen vor und die Variable könnte auch von anderen Objekten verändert werden."
    }
   ]
  },
  {
   "artifact_name": "m.31",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.65",
     "markdown": "## Lektion 4 - Enumeration\nMit Hilfe einer Enumeration kann ein eigener limitierter Datentyp erstellt werden, der nur gewisse Werte annehmen kann. Der Klasse wird dann das Schlüsselwort `enum` vorrangestellt. Soll ein Wert des Enums verwendet werden, muss der Name der Enumeration zusätzlich angegeben werden."
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.116",
     "markdown": "## Lektion 4 - Enumeration\nMit Hilfe einer Enumeration kann ein eigener, limitierter Datentyp erstellt werden, der nur vordefinierte Werte annehmen kann. Der Klasse wird dafür das Schlüsselwort `enum` vorrangestellt. Soll ein Wert des Enums verwendet werden, muss zusätzlich der Name der Enumeration angegeben werden."
    },
    {
     "start_checkpoint": 1622312494538,
     "parent": "n.0.116",
     "markdown": "## Lektion 4 - Aufzählung\nMit Hilfe einer Enumeration kann ein eigener, limitierter Datentyp erstellt werden, der nur vordefinierte Werte annehmen kann. Der Klasse wird dafür das Schlüsselwort `enum` vorrangestellt. Soll ein Wert des Enums verwendet werden, muss zusätzlich der Name der Enumeration angegeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.32",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.65",
     "markdown": "Auf alle möglichen Werte eines Enums kann mit `values()` zugegriffen werden. Zurückgegeben wird ein Array. Soll auf das Enum-Objekt eines Strings zugegriffen werden, kann dies mit `valueOf()` mit dem String als Parameter, bewerkstelligt werden. Wird kein passendes Element gefunden, wird eine `IllegalArgumentException` geworfen."
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.65",
     "markdown": "Auf alle möglichen Werte eines Enums kann mit `values()` zugegriffen werden. Zurückgegeben wird ein Array. Soll auf das Enum-Objekt eines Strings zugegriffen werden, kann dies mit `valueOf()` und dem String als Parameter, bewerkstelligt werden. Wird kein passendes Element gefunden, wird eine `IllegalArgumentException` geworfen."
    },
    {
     "start_checkpoint": 1622285770045,
     "parent": "n.0.66",
     "markdown": "Auf alle möglichen Werte eines Enums kann mit `values()` zugegriffen werden. Zurückgegeben wird ein Array. Soll auf das Enum-Objekt eines Strings zugegriffen werden, ist dies mit `valueOf()` und dem String als Parameter möglich. Wird kein passendes Element gefunden, wird eine `IllegalArgumentException` geworfen."
    },
    {
     "start_checkpoint": 1622285787057,
     "parent": "n.0.121",
     "markdown": "Auf alle möglichen Werte eines Enums kann mit `values()` zugegriffen werden. Zurückgegeben wird ein Array. Soll auf das Enum-Objekt eines Strings zugegriffen werden, ist dies mit `valueOf()` und dem String als Parameter möglich. Wird kein passendes Element gefunden, ist das Ergebnis eine `IllegalArgumentException`."
    }
   ]
  },
  {
   "artifact_name": "m.33",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.65",
     "markdown": "Da Enums als vollständige Klassen angesehen werden, können ihnen Felder und sogar Methoden hinzugefügt werden. Sollen Felder mit einem bestimmten Wert der von dem Wert des Enums anhängt gefüllt werden, kann hinter dem Wert des Enums die Werte für den Konstruktor übergeben werden."
    },
    {
     "start_checkpoint": 1622285787057,
     "parent": "n.0.116",
     "markdown": "Da Enums als vollständige Klassen angesehen werden, können ihnen Felder und sogar Methoden hinzugefügt werden. Sollen Felder mit einem bestimmten Wert, der von dem Wert des Enums abhängt, gefüllt werden, kann hinter dem Wert des Enums die Parameter des Konstruktors übergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.34",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "markdown": "## Lektion 5 - Vererbung"
    },
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.65",
     "markdown": "## Lektion 5 - Vererbung\nIn Kotlin kann nicht von einer beliebigen Klasse geerbt werden. Diese muss als Vorraussetzung den Vorsatz `open` besitzen. Dies signaliesiert, dass eine Vererbung stattfinden darf. Der Namen der Klasse, von der geerbt werden soll, ist mit einem `:` getrennt hinter den Parameterklammern der erbenden Klasse zu schreiben. Dem Konstruktor der super-Klasse werden die Parameter direkt im Kopf der Klasse übergeben. "
    },
    {
     "start_checkpoint": 1622286007574,
     "parent": "n.0.116",
     "markdown": "## Lektion 5 - Vererbung\nIn Kotlin kann nicht von einer beliebigen Klasse geerbt werden. Diese muss als Voraussetzung den Vorsatz `open` besitzen. Dadurch wird signalisiert, dass eine Vererbung stattfinden darf. Der Namen der Klasse, von der geerbt werden soll, ist mit einem `:` getrennt hinter den Parameterklammern der erbenden Klasse zu schreiben. Dem Konstruktor der Super-Klasse werden die Parameter direkt im Kopf der Klasse übergeben. "
    }
   ]
  },
  {
   "artifact_name": "m.35",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "markdown": "## Lektion 6 - Schnittstellen"
    }
   ]
  },
  {
   "artifact_name": "m.36",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "markdown": "## Lektion 7 - Generizität"
    }
   ]
  },
  {
   "artifact_name": "m.37",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.24",
     "markdown": "## Lektion 8 - Fehlerbehandlung"
    }
   ]
  },
  {
   "artifact_name": "m.38",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.22",
     "markdown": "sealed class Expr\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()# Abschnitt 3\nThema dieses Abschnittes wird die objektorientierte Programmierung sein.\n\n## Lektion 1 - Klassen\nAufgrund der Kompatibilität mit Java ist auch Kotlin eine objektorientierte Sprache. Deswegen werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind alle bekannten objektorientierte Konzepte vorhanden, jedoch angepasst und teilweise auch vereinfacht. Dazu ein Einführungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1619427699980,
     "parent": "n.0.25",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes wird die objektorientierte Programmierung sein.\n\n## Lektion 1 - Klassen\nAufgrund der Kompatibilität mit Java ist auch Kotlin eine objektorientierte Sprache. Deswegen werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind alle bekannten objektorientierte Konzepte vorhanden, jedoch angepasst und teilweise auch vereinfacht. Dazu ein Einführungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622203932351,
     "parent": "n.0.26",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilität mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einführungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622203944610,
     "parent": "n.0.116",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilität mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einführungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622312964703,
     "parent": "n.0.118",
     "markdown": "<img src=\"images/Abschnitt3.png\" style=\"margin-left: auto; margin-right: auto; display: block; margin-bottom: 20px\"/>\n<h1 style=\"display:none\">Abschnitt 2 - Funktionale Programmierung</h1>\n\n<img src=\"images/Einführung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h2 style=\"display:none\">Einführung</h2>\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilität mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einführungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622313227273,
     "parent": "n.0.119",
     "markdown": "<img src=\"asimages/Abschnitt3.png\" style=\"margin-left: auto; margin-right: auto; display: block; margin-bottom: 20px\"/>\n<h1 style=\"display:none\">Abschnitt 2 - Funktionale Programmierung</h1>\n\n<img src=\"images/Einführung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h2 style=\"display:none\">Einführung</h2>\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilität mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einführungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622313230222,
     "parent": "n.0.120",
     "markdown": "<img src=\"images/Abschnitt3.png\" style=\"margin-left: auto; margin-right: auto; display: block; margin-bottom: 20px\"/>\n<h1 style=\"display:none\">Abschnitt 2 - Funktionale Programmierung</h1>\n\n<img src=\"images/Einführung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h2 style=\"display:none\">Einführung</h2>\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilität mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einführungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.39",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Felder und Methoden überschreiben\nSollen Felder oder Methoden der super-Klasse in der sub-Klasse überschrieben werden, müssen diese auch mit `open` gekennzeichnet werden. Erst dann ist es möglich das gleiche Feld oder die gleiche Methode in der sub-Klasse mit dem Zusatz `override` zu definieren. Soll auf das Feld oder die Methode der Oberklasse zugegriffen werden, findet das Schlüsselwort `super` Anwendung. Bei Mehrfachvererbung wird die nächst höhere Klasse angesprochen."
    },
    {
     "start_checkpoint": 1622286066819,
     "parent": "n.0.69",
     "markdown": "### Felder und Methoden überschreiben\nSollen Felder oder Methoden der Super-Klasse in der Sub-Klasse überschrieben werden, müssen diese auch mit `open` gekennzeichnet werden. Erst dann ist es möglich das gleiche Feld oder die gleiche Methode in der sub-Klasse mit dem Zusatz `override` zu definieren. Soll auf das Feld oder die Methode der Oberklasse zugegriffen werden, findet das Schlüsselwort `super` Anwendung. Bei Mehrfachvererbung wird die nächst höhere Klasse angesprochen."
    },
    {
     "start_checkpoint": 1622286097813,
     "parent": "n.0.116",
     "markdown": "### Felder und Methoden überschreiben\nSollen Felder oder Methoden der Super-Klasse in der Sub-Klasse überschrieben werden, müssen diese ebenfalls mit `open` gekennzeichnet werden. Erst dann ist es möglich das gleiche Feld oder die gleiche Methode in der sub-Klasse mit dem Zusatz `override` zu definieren. Soll auf das Feld oder die Methode der Oberklasse zugegriffen werden, findet das Schlüsselwort `super` Anwendung. Bei Mehrfachvererbung wird die nächst höhere Klasse angesprochen."
    }
   ]
  },
  {
   "artifact_name": "m.40",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Sekundäre Konstruktoren\nWir sind bis jetzt von dem einfachen Fall ausgegangen, dass die Unterklasse einen primären Konstruktor besitzt. Jedoch gibt es auch die Möglichkeit diese nut mit sekunären Konstruktoren auszustatten. Diese müssen jedoch immer den primären Konstruktor der Oberklasse aufrufen."
    },
    {
     "start_checkpoint": 1622286553284,
     "parent": "n.0.121",
     "markdown": "### Sekundäre Konstruktoren\nWir sind bis jetzt von dem einfachen Fall ausgegangen, dass die Unterklasse einen primären Konstruktor besitzt. Jedoch gibt es auch die Möglichkeit diese nur mit sekundären Konstruktoren auszustatten. Diese müssen immer den primären Konstruktor der Oberklasse aufrufen."
    }
   ]
  },
  {
   "artifact_name": "m.41",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abtrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Möglichkeit unintiierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlüsselwort `abstract` vorangestellt und können ohne Probleme geerbt werden. Die Subklassen müssen jedoch die Methoden vervollständigen."
    },
    {
     "start_checkpoint": 1622286553284,
     "parent": "n.0.72",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Möglichkeit unintiierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlüsselwort `abstract` vorangestellt und können ohne Probleme geerbt werden. Die Subklassen müssen jedoch die Methoden vervollständigen."
    },
    {
     "start_checkpoint": 1622286762980,
     "parent": "n.0.73",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Möglichkeit uninitierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlüsselwort `abstract` vorangestellt und können ohne Probleme geerbt werden. Die Subklassen müssen jedoch die Methoden vervollständigen."
    },
    {
     "start_checkpoint": 1622286789527,
     "parent": "n.0.74",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Möglichkeit uninitierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlüsselwort `abstract` vorangestellt können ohne Probleme vererbt werden. Die Subklassen müssen jedoch die Methoden vervollständigen."
    },
    {
     "start_checkpoint": 1622286800210,
     "parent": "n.0.116",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Möglichkeit uninitierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlüsselwort `abstract` vorangestellt können ohne Probleme vererbt werden. Die Sub-Klassen müssen jedoch die Methoden vervollständigen."
    }
   ]
  },
  {
   "artifact_name": "m.42",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.24",
     "markdown": "### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlüsselwort `sealed` vorangestellt und sie besitzt einen privaten Konstruktor. Außerdem darf von der Klasse nur in der Datei geerbt werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweifung der default-Fall weggelassen werden."
    }
   ]
  },
  {
   "artifact_name": "m.43",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "## Lektion 6 - Schnittstellen\nEin wichtiges objektorientiertes Konzept ist das der Schnittstelle. Ein bekanntes Beispiel ist hier das `Comparable`-Interface, das eine `compareTo()`-Methode vorschreibt. Aber anstelle des Vorschreibens von Methoden können auch Zugriffe definiert werden. Eine Schnittstelle hat das Schlüsselwort `interface` und wird bei der implementierenden Klasse ähnlich zur Vererbung angegeben. In einem Interface können sowohl Methoden voll implementiert oder nur deren Kopf angegeben werden, sodass diese von jeder Klasse selbst vervollständigt werden muss. Außerdem können sie auch Felder beinhalten.\nKotlin bietet bereits einige vorimplementierte Schnittstellen an:\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622289820200,
     "parent": "n.0.116",
     "markdown": "## Lektion 6 - Schnittstellen\nEin wichtiges objektorientiertes Konzept ist das der Schnittstelle. Ein bekanntes Beispiel das `Comparable`-Interface, das eine `compareTo()`-Methode voraussetzt. Aber anstelle des Vorschreibens von Methoden können auch Zugriffe definiert werden. Eine Schnittstelle besitzt das Schlüsselwort `interface` und wird bei der implementierenden Klasse ähnlich zum Erben angegeben. In einem Interface können sowohl Methoden voll implementiert oder nur deren Kopf angegeben werden, sodass diese von jeder Klasse selbst vervollständigt werden müssen. Außerdem können sie auch Felder beinhalten.\nKotlin bietet bereits einige vorgefertigte Schnittstellen an:\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.44",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "## Lektion 7 - Generizität\n### Generische Klassen\nBei manchen Softwareprojekten kommt man um generische Klassen nicht vorbei, falls mehrfache Arbeit vermieden werden soll. An sich unterscheiden sich die Unterschiede von solchen Klassen in Kotlin und Java nicht. Der generische Datentyp wird nach dem Klassennamen in `<>` angegeben und kann in der Klasse anstelle normalen Datentypen eingesetzt werden."
    },
    {
     "start_checkpoint": 1622289820200,
     "parent": "n.0.80",
     "markdown": "## Lektion 7 - Generizität\n### Generische Klassen\nBei manchen Softwareprojekten kommt man an generischen Klassen nicht vorbei, falls mehrfache Arbeit vermieden werden soll. An sich unterscheiden sich die Unterschiede von solchen Klassen in Kotlin und Java nicht. Der generische Datentyp wird nach dem Klassennamen in `<>` angegeben und kann in der Klasse anstelle normalen Datentypen eingesetzt werden."
    },
    {
     "start_checkpoint": 1622290018952,
     "parent": "n.0.116",
     "markdown": "## Lektion 7 - Generizität\n### Generische Klassen\nBei manchen Softwareprojekten kommt man an generischen Klassen nicht vorbei, falls mehrfache Arbeit vermieden werden soll. Das Konzept an sich unterscheidet sich in Kotlin und Java nicht. Der generische Datentyp wird nach dem Klassennamen in `<>` angegeben und kann in der Klasse anstelle normalen Datentypen eingesetzt werden."
    }
   ]
  },
  {
   "artifact_name": "m.45",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.116",
     "markdown": "Soll der generische Datentyp eingeschränkt werden, kann dies durch ein Interface passieren. Dieses gibt vor welche Methoden der Datentyp implementieren muss."
    }
   ]
  },
  {
   "artifact_name": "m.46",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Generische Funktionen\nGenerizität findet aber nicht nur bei Klassen, sondern auch bei Funktionen Anwendung. Jedoch wird hier der generische Typ vor dem Namen der Funktion angegeben. Bei Aufruf der Methode muss der Typ nicht angegeben werden, sondern wird vom Kompiler erkannt."
    },
    {
     "start_checkpoint": 1622290018952,
     "parent": "n.0.121",
     "markdown": "### Generische Funktionen\nGenerizität findet aber nicht nur bei Klassen, sondern auch bei Funktionen Anwendung. Jedoch wird hier der generische Typ vor dem Namen der Funktion angegeben. Bei Aufruf der Methode muss der Typ nicht angegeben werden, sondern wird vom Compiler erkannt."
    }
   ]
  },
  {
   "artifact_name": "m.47",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Generische Erweiterungsfunktionen\nErweiterungsfunktionen einer bestimmten Klasse wurden bereits in Abschnitt 1 kennengelernt. Dieses Konzept kann aber auch auf generische Klassen übertragen werden. So können beispielsweise einer generischen Liste neue Methoden hinzugefügt werden."
    },
    {
     "start_checkpoint": 1622290018952,
     "parent": "n.0.81",
     "markdown": "### Generische Erweiterungsmethoden\nErweiterungsmethoden einer bestimmten Klasse wurden bereits in Abschnitt 1 kennengelernt. Dieses Konzept kann aber auch auf generische Klassen übertragen werden. So können beispielsweise einer generischen Liste neue Methoden hinzugefügt werden."
    },
    {
     "start_checkpoint": 1622290123775,
     "parent": "n.0.116",
     "markdown": "### Generische Erweiterungsmethoden\nDas Konzept und die Implementierung von Erweiterungsmethoden wurden bereits in Abschnitt 1 kennengelernt. Es kann aber auch auf generische Klassen übertragen werden. So können beispielsweise einer generischen Liste neue Methoden hinzugefügt werden."
    }
   ]
  },
  {
   "artifact_name": "m.48",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.25",
     "markdown": "Es ist zu erkennen, dass der Kotlincode deutlich kürzer und übersichtlicher ist. <br />\nDer Kopf einer Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von dem Namen. Die Parameter werden nach diesem in runden Klammern angegeben. Erzeugt werden kann die Klasse wie aus Java gewohnt mit der Nennung der Name der Klasse sowie dem Aufruf eines Konstruktors. In den runden Klammern sind die erforderlichen Argumente für die Objekterzeugung zu finden.\n\n### Felder\nFelder können Klassen einfach Hinzugefügt werden. Die erste Möglichkeit ist durch die Übergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei öffentlicher Sichtbarkeit eine Variablenart (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heißt es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, welches bei Objekterzeugung mit dem Wert des Übergabeparameters gefüllt wird. Außerdem wird immer ein unsichtbarer Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, wird zusätzlich ein rudimentärer Setter der Klasse hinzugefügt."
    },
    {
     "start_checkpoint": 1622204008193,
     "parent": "n.0.28",
     "markdown": "Es ist zu erkennen, dass der Code in Kotlin deutlich kürzer und übersichtlicher ist.  \nDer Kopf einer Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von dem Namen. Die Parameter werden nach diesem in runden Klammern angegeben. Erzeugt werden kann die Klasse, wie aus Java gewohnt, mit der Nennung des Namens der Klasse sowie dem Aufruf eines Konstruktors. In den runden Klammern sind die erforderlichen Argumente für die Objekterzeugung zu finden.\n\n### Felder\nFelder können Klassen auf verschiedene Weise hinzugefügt werden. Die erste Möglichkeit ist durch die Übergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei öffentlicher Sichtbarkeit eine Variablenart (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heißt es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, welches bei Objekterzeugung mit dem Wert des Übergabeparameters gefüllt wird. Außerdem wird immer ein unsichtbarer Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, wird zusätzlich ein rudimentärer Setter der Klasse hinzugefügt."
    },
    {
     "start_checkpoint": 1622204182191,
     "parent": "n.0.116",
     "markdown": "Es ist zu erkennen, dass der Code in Kotlin deutlich kürzer und übersichtlicher ist.  \nDer Kopf einer Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von dem Namen. Die Parameter werden nach diesem in runden Klammern angegeben. Erzeugt werden kann die Klasse, wie aus Java gewohnt, mit der Nennung des Namens der Klasse sowie dem Aufruf eines Konstruktors. In den runden Klammern sind die erforderlichen Argumente für die Objekterzeugung zu finden.\n\n### Felder\nFelder können Klassen auf verschiedene Weise hinzugefügt werden. Die erste Möglichkeit ist durch die Übergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei öffentlicher Sichtbarkeit ein Variablentyp (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heißt, es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, das bei Objekterzeugung mit dem Wert des Übergabeparameters gefüllt wird. Außerdem wird immer ein *unsichtbarer* Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, fügt der Compiler zusätzlich einen rudimentären Setter hinzu."
    }
   ]
  },
  {
   "artifact_name": "m.49",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.25",
     "markdown": "### Aufgabe - Pizza-Klasse\nImplementieren Sie eine Klasse `Pizza`. Jede Pizza soll eine Größe `groeße` (zwischen 15 und 30 [cm], ansonsten -1) und eine Liste aus Belägen `belaege` (Standardmäßig bereits mit Tomatensoße und Käse befüllt) enthalten. Außerdem soll gespeichert werden, ob sie geschnitten `geschnitten` werden soll. Wählen Sie einen passenden primären Konstruktor, der für jedes Feld einen Übergabeparameter besitzt. Fügen Sie außerdem weitere (sekundäre) Konstruktoren hinzu, die eine Pizza Magaritha (Tomatensoße, Mozzarella) und eine 25cm Pizza al Tonno (Tomatensoße, Mozzarella, Thunfisch, Zwiebeln, Peperoni) initialisieren. Beide Pizzas sollen geschnitten werden."
    },
    {
     "start_checkpoint": 1622205474347,
     "parent": "n.0.121",
     "markdown": "### Aufgabe - Pizza-Klasse\nImplementieren Sie eine Klasse `Pizza`. Jede Pizza soll eine Größe `groeße` (zwischen 15 und 30 [cm], ansonsten -1) und eine Liste aus Belägen `belaege` (Standardmäßig bereits mit Tomatensoße und Käse befüllt) enthalten. Außerdem soll gespeichert werden, ob sie geschnitten `geschnitten` werden soll. Wählen Sie einen passenden primären Konstruktor, der für jedes Feld einen Übergabeparameter besitzt. Fügen Sie außerdem weitere (sekundäre) Konstruktoren hinzu, die eine Pizza Magaritha (Tomatensoße, Mozzarella) und eine 25cm Pizza al Tonno (Tomatensoße, Mozzarella, Thunfisch, Zwiebeln, Peperoni) initialisieren. Beide Pizzen sollen geschnitten werden."
    }
   ]
  },
  {
   "artifact_name": "m.50",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.47",
     "markdown": "### Aufgabe - Parkplatzverwaltung\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz repräsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Länge 5 verwirklicht werden. Ist ein Parkplatz belegt, so soll an diesem Eintrag `true` stehen. Benutzen Sie passende Sichtbarkeiten. Standardmäßig wird bei Erzeugung eine passendes Liste übergeben. Falls kein Parameter übergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zusätzlich eine Methode `einparken()` die die Nummer des Parkplatzes übergeben bekommt und diesen belegt falls möglich. Bei Erfolg soll `true` zurückgegebn werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter übergeben werden. Überschreiben Sie zusätzlich die Methode `toString()`, die den Parkplatz übersichtlich nach folgendem Muster ausgegeben soll: <br />\n<p>--x-- (Parkplatz Nummer 2 ist belegt)</p>"
    },
    {
     "start_checkpoint": 1622209719335,
     "parent": "n.0.53",
     "markdown": "### Aufgabe - Parkplatzverwaltung\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz repräsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Länge 5 verwirklicht werden, der als Feld repräsentiert wird. Ist ein Parkplatz belegt, so soll an diesem Eintrag `true` stehen. Benutzen Sie passende Sichtbarkeiten. Standardmäßig wird bei Erzeugung eine passendes Liste übergeben. Falls kein Parameter übergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zusätzlich eine Methode `einparken()` die die Nummer des Parkplatzes übergeben bekommt und diesen belegt falls möglich. Bei Erfolg soll `true` zurückgegebn werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter übergeben werden. Überschreiben Sie zusätzlich die Methode `toString()`, die den Parkplatz übersichtlich nach folgendem Muster ausgegeben soll: <br />\n<p>--x-- (Parkplatz Nummer 2 ist belegt)</p>"
    },
    {
     "start_checkpoint": 1622209870934,
     "parent": "n.0.116",
     "markdown": "### Aufgabe - Parkplatzverwaltung\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz repräsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Länge 5 verwirklicht werden, der als Feld repräsentiert wird. Ist ein Parkplatz belegt, so soll dieser Eintrag `true` sein. Verwenden Sie passende Sichtbarkeiten.  \nStandardmäßig wird bei Erzeugung eine passende Liste übergeben. Falls kein Parameter übergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zusätzlich eine Methode `einparken()` der die Nummer des Parkplatzes übergeben wird und diesen falls möglich belegt. Bei Erfolg soll `true` zurückgegeben werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter übergeben werden. Überschreiben Sie zusätzlich die Methode `toString()`, die den Parkplatz übersichtlich nach folgendem Muster ausgegeben soll:  \n--x-- (Parkplatz Nummer 2 ist belegt)"
    }
   ]
  },
  {
   "artifact_name": "m.51",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.47",
     "markdown": "### Aufgabe - Abstände\nIn dieser Aufgabe soll mit Hilfe von Datenklassen eine Verwaltung von Abständen ermöglicht werden. Dazu werden folgende Komponenten benötigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speicher\n* Eine Datenklasse `Abstand`, die primär den Wert des Abstands zweier Positionen speichert. Außerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.\n* Eine Funktion `berechneAbstand()` der zwei Positionen übergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefügt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefügt werden.  "
    },
    {
     "start_checkpoint": 1622210381391,
     "parent": "n.0.58",
     "markdown": "### Aufgabe - Abstände\nIn dieser Aufgabe soll mit Hilfe von Datenklassen eine Verwaltung von Abständen ermöglicht werden. Dazu werden folgende Komponenten benötigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primär den Wert des Abstands zweier Positionen speichert. Außerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.\n* Eine Funktion `berechneAbstand()` der zwei Positionen übergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefügt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefügt werden.  "
    },
    {
     "start_checkpoint": 1622210510241,
     "parent": "n.0.59",
     "markdown": "### Aufgabe - Abstände\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abständen implementieren. Dazu werden folgende Komponenten benötigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primär den Wert des Abstands zweier Positionen speichert. Außerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.\n* Eine Funktion `berechneAbstand()` der zwei Positionen übergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefügt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefügt werden.  "
    },
    {
     "start_checkpoint": 1622210675867,
     "parent": "n.0.60",
     "markdown": "### Aufgabe - Abstände\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abständen implementieren. Dazu werden folgende Komponenten benötigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primär den Wert eines Abstands. Außerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.  \nBeispiel: Wert des Abstandes: 3, positionen: [(Position(0,0), Position(2,1)), (Position(0,3), Position(3,3)), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen übergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefügt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefügt werden. "
    },
    {
     "start_checkpoint": 1622210700458,
     "parent": "n.0.61",
     "markdown": "### Aufgabe - Abstände\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abständen implementieren. Dazu werden folgende Komponenten benötigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primär den Wert eines Abstands. Außerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.  \nBeispiel: `wert` des Abstandes: 3, Inhalt von `positionen`: [(Position(0,0), Position(2,1)), (Position(0,3), Position(3,3)), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen übergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefügt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefügt werden. "
    },
    {
     "start_checkpoint": 1622210723976,
     "parent": "n.0.62",
     "markdown": "### Aufgabe - Abstände\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abständen implementieren. Dazu werden folgende Komponenten benötigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primär den Wert eines Abstands. Außerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.  \nBeispiel: `wert` des Abstandes: 3, Inhalt von `positionen`: [( Position(0,0), Position(2,1) ), ( Position(0,3), Position(3,3) ), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen übergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefügt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefügt werden. "
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.116",
     "markdown": "### Aufgabe - Abstände\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abständen implementieren. Dazu werden folgende Komponenten benötigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primär den Wert eines Abstands. Außerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.  \nBeispiel: `wert` des Abstandes: 3, Inhalt von `positionen`: [( Position(0,0), Position(2,1) ), ( Position(0,3), Position(3,3) ), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen übergeben werden. In ihrem Rumpf soll die [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) der beiden Punkte berechnet und der Abstand zur globale Liste `abstaende` hinzugefügt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch sollen die beiden Positionen dem bereits vorhandenen Abstand in die Liste `positionen` hinzugefügt werden. "
    }
   ]
  },
  {
   "artifact_name": "m.52",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "<div class=\"alert alert-block alert-danger\">\n<b>TODO</b> Sealed class und interface in kotlin 1.5.0 anschauen\n</div>\n\n### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlüsselwort `sealed` vorangestellt und sie besitzt einen privaten Konstruktor. Von dieser darf nur in dem selben Paket oder der selben Kompiliereinheit geerbet werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweifung der default-Fall weggelassen werden."
    },
    {
     "start_checkpoint": 1622286800210,
     "parent": "n.0.75",
     "markdown": "<div class=\"alert alert-block alert-danger\">\n<b>TODO</b> Sealed class und interface in kotlin 1.5.0 anschauen\n</div>\n\n### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlüsselwort `sealed` vorangestellt. Sie besitzt einen privaten Konstruktor. Von dieser darf nur in dem selben Paket oder der selben Kompiliereinheit geerbet werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweifung der default-Fall weggelassen werden."
    },
    {
     "start_checkpoint": 1622286910420,
     "parent": "n.0.116",
     "markdown": "<div class=\"alert alert-block alert-danger\">\n<b>TODO</b> Sealed class und interface in kotlin 1.5.0 anschauen\n</div>\n\n### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlüsselwort `sealed` vorangestellt. Sie besitzt einen privaten Konstruktor. Von dieser darf nur in dem selben Paket oder der selben Kompiliereinheit geerbet werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweifung der *default*-Fall weggelassen werden."
    }
   ]
  },
  {
   "artifact_name": "m.53",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "## Lektion 8 - Fehlerbehandlung\nWährend in Java zwischen Checked (die Möglichkeit eines Fehlers muss behandelt werden) und Unchecked Exceptions (müssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Exception diese vorbeugend zu behandeln.<br />\nMit `throw` können Exceptions selbst ausgelöst werden. Außerdem kann ein solcher Ausdruck auch einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622290204256,
     "parent": "n.0.86",
     "markdown": "## Lektion 8 - Fehlerbehandlung\nWährend in Java zwischen *checked* (die Möglichkeit eines Fehlers muss behandelt werden) und *unchecked Exceptions* (Fehler müssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Exception diese vorbeugend zu behandeln.<br />\nMit `throw` können Exceptions selbst ausgelöst werden. Außerdem kann ein solcher Ausdruck auch einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622290261257,
     "parent": "n.0.87",
     "markdown": "## Lektion 8 - Fehlerbehandlung\nWährend in Java zwischen *checked* (die Möglichkeit eines Fehlers muss behandelt werden) und *unchecked Exceptions* (Fehler müssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` können Exceptions selbst ausgelöst werden. Außerdem kann ein solcher Ausdruck auch einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622290272824,
     "parent": "n.0.116",
     "markdown": "## Lektion 8 - Fehlerbehandlung\nWährend in Java zwischen *checked* (die Möglichkeit eines Fehlers muss behandelt werden) und *unchecked Exceptions* (Fehler müssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` können Exceptions selbst ausgelöst werden. Außerdem kann ein solcher Ausdruck einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622312896740,
     "parent": "n.0.117",
     "markdown": "## Lektion 8 - Ausnahmebehandlung\nWährend in Java zwischen *checked* (die Möglichkeit eines Fehlers muss behandelt werden) und *unchecked Exceptions* (Fehler müssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` können Exceptions selbst ausgelöst werden. Außerdem kann ein solcher Ausdruck einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622312964703,
     "parent": "n.0.118",
     "markdown": "## Lektion 8 - Ausnahmebehandlung\nWährend in Java zwischen *checked* (die Möglichkeit einer Ausnahme muss behandelt werden) und *unchecked Exceptions* (Ausnahmen müssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` können Exceptions selbst ausgelöst werden. Außerdem kann ein solcher Ausdruck einer Variable zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.54",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "Der `try and catch`-Block ist natürlich auch in Kotlin vorhanden. Aber auch hier kann das Ergebnis dieses Ausdrucks einer Variable zugewiesen werden. Der Syntax ähnelt den der Lambda-Ausdücke."
    },
    {
     "start_checkpoint": 1622290408459,
     "parent": "n.0.93",
     "markdown": "Der `try and catch`-Block darf in Kotlin natürlich nicht fehlen. Wie bei einer Exception selbst kann auch hier das Ergebnis dieses Ausdrucks einer Variable zugewiesen werden. Der Syntax ähnelt den der Lambda-Ausdücke."
    },
    {
     "start_checkpoint": 1622290479536,
     "parent": "n.0.94",
     "markdown": "Der `try and catch`-Block darf in Kotlin natürlich nicht fehlen. Wie bei einer Exception selbst kann auch hier das Ergebnis dieses Ausdrucks einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622290607436,
     "parent": "n.0.121",
     "markdown": "Der `try & catch`-Block darf in Kotlin natürlich nicht fehlen. Wie bei einer Exception selbst kann auch hier das Ergebnis dieses Ausdrucks einer Variable zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.55",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "Soll nach der Ausführung einer der beiden Blöcke Code ausgefürt werden, kann zusätzlich ein `finaly`-Block verwendet werden. Der darin befindende Code wird immer am Ende ausgeführt und eignet sich deshalb besonders für Aufräumarbeiten. Falls ein solcher Block vorhanden ist, kann `catch` auch weggelassen werden.<br />\nEigene Exceptions können auch implemenitert werden. Dabei ist erforderlich, dass die Klasse von `Exception` erbt und die Fehlermeldung als String übergeben und an die Superklasse weitergibt."
    },
    {
     "start_checkpoint": 1622290655058,
     "parent": "n.0.101",
     "markdown": "Soll nach der Ausführung einer der beiden Blöcke Code ausgefürt werden, kann zusätzlich ein `finally`-Block verwendet werden. Der darin befindende Code wird immer am Ende ausgeführt und eignet sich deshalb besonders für Aufräumarbeiten. Falls ein solcher Block vorhanden ist, kann `catch` auch weggelassen werden.<br />\nEigene Exceptions können auch implemenitert werden. Dabei ist erforderlich, dass die Klasse von `Exception` erbt und die Fehlermeldung als String übergeben und an die Superklasse weitergibt."
    },
    {
     "start_checkpoint": 1622290741126,
     "parent": "n.0.116",
     "markdown": "Soll nach der Ausführung einer der beiden Blöcke Code ausgefürt werden, kann zusätzlich ein `finally`-Block verwendet werden. Der darin befindende Code wird immer am Ende ausgeführt und eignet sich deshalb besonders für Aufräumarbeiten. Falls ein solcher Block vorhanden ist, kann `catch` auch weggelassen werden.  \nEs können auch eigene Exceptions definiert werden. Dabei ist erforderlich, dass die Klasse von `Exception` erbt, die Fehlermeldung als String übergeben bekommt und an die Super-Klasse weitergibt."
    },
    {
     "start_checkpoint": 1622312964703,
     "parent": "n.0.121",
     "markdown": "Soll nach der Ausführung einer der beiden Blöcke Code ausgefürt werden, kann zusätzlich ein `finally`-Block verwendet werden. Der darin befindende Code wird immer am Ende ausgeführt und eignet sich deshalb besonders für Aufräumarbeiten. Falls ein solcher Block vorhanden ist, kann `catch` auch weggelassen werden.  \nEs können auch eigene Exceptions definiert werden. Dabei ist erforderlich, dass die Klasse von `Exception` erbt, die Beschreibung als String übergeben bekommt und an die Super-Klasse weitergibt."
    }
   ]
  },
  {
   "artifact_name": "m.56",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurden die objektorientierte Programmierung in Kotlin besprochen.<br />\nEine Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Kompiler für uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren. <br />\nDie Objekterzeugung erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.<br /><br />\nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine \"klassische\", aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.<br /><br />\nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.<br />\nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert werden und auch zusätzöicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.<br />\nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.<br />\nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zusätzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Außerdem können die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fügt diese dann im Hintergrund zu einem zusammenhängendem Konstruktor zusammen.<br />\nEiner Klasse können mehrere primäre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.<br /><br />\n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.<br /><br />\n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.<br />\nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.<br />\nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.<br /><br />\n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.<br />\nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.<br />\nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.<br /><br />\n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n<br />\n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.<br /><br />\n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.<br />\nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.<br />\n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n<br /><br />\n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.<br />\nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler übernommen.<br />\nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.<br /><br />\nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.<br /><br />\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.<br />\nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.<br />\nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.<br />\nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.<br />\nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.<br /><br />\nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details> \n<br />\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.<br />\nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.<br /><br />\nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen. <br />\nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.<br />\nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.<br />\nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622290741126,
     "parent": "n.0.102",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Kompiler für uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine \"klassische\", aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert werden und auch zusätzöicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zusätzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Außerdem können die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fügt diese dann im Hintergrund zu einem zusammenhängendem Konstruktor zusammen.  \nEiner Klasse können mehrere primäre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details> \n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622290867816,
     "parent": "n.0.103",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Kompiler für uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine \"klassische\", aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert werden und auch zusätzöicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zusätzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Außerdem können die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fügt diese dann im Hintergrund zu einem zusammenhängendem Konstruktor zusammen.  \nEiner Klasse können mehrere primäre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details> \n  \n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622290882283,
     "parent": "n.0.104",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Kompiler für uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine \"klassische\", aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert werden und auch zusätzöicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zusätzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Außerdem können die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fügt diese dann im Hintergrund zu einem zusammenhängendem Konstruktor zusammen.  \nEiner Klasse können mehrere primäre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details> \n<br />\n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622290897345,
     "parent": "n.0.105",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Kompiler für uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine \"klassische\", aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert werden und auch zusätzöicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zusätzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Außerdem können die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fügt diese dann im Hintergrund zu einem zusammenhängendem Konstruktor zusammen.  \nEiner Klasse können mehrere primäre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n\n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622290907792,
     "parent": "n.0.106",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Kompiler für uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine \"klassische\", aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert werden und auch zusätzöicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zusätzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Außerdem können die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fügt diese dann im Hintergrund zu einem zusammenhängendem Konstruktor zusammen.  \nEiner Klasse können mehrere primäre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622290917172,
     "parent": "n.0.107",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Kompiler für uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine \"klassische\", aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert werden und auch zusätzöicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zusätzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Außerdem können die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fügt diese dann im Hintergrund zu einem zusammenhängendem Konstruktor zusammen.  \nEiner Klasse können mehrere primäre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622291027879,
     "parent": "n.0.108",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine *klassische*, aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf den primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert werden und auch zusätzöicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zusätzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Außerdem können die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fügt diese dann im Hintergrund zu einem zusammenhängendem Konstruktor zusammen.  \nEiner Klasse können mehrere primäre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622291072276,
     "parent": "n.0.111",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine *klassische*, aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert werden und auch zusätzöicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zusätzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Außerdem können die verschiedenen Formen auch miteinander Kombiniert werden. der Compiler fügt diese dann im Hintergrund zu einem zusammenhängendem Konstruktor zusammen.  \nEiner Klasse können mehrere primäre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Compiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Compiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Compiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Compiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622291555802,
     "parent": "n.0.112",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine *klassische*, aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert und auch zusätzlicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zusätzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen können auch miteinander kombiniert werden. Der Kompiler fügt diese im Hintergrund zu einem zusammenhängenden Konstruktor zusammen.  \nEiner Klasse können **mehrere primäre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefügt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurückgegen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können sich als größere Pakete vorgestellt werden.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Compiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Compiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Compiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Compiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622291748840,
     "parent": "n.0.113",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine *klassische*, aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert und auch zusätzlicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zusätzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen können auch miteinander kombiniert werden. Der Kompiler fügt diese im Hintergrund zu einem zusammenhängenden Konstruktor zusammen.  \nEiner Klasse können **mehrere primäre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefügt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurückgegeriffen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden unterstützt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können Sie sich als größere Pakete vorgestellen.\n* `public`: Das Element kann überall benutzt werden.\n\n  \n\nZusätzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder angegeben werden. Für diese generiert der Compiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht berücksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur durch Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Compiler übernommen.  \nMit einem **Companion Object** können die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf können Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgeführt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um den Compiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Möglichkeiten. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu übergeben, wie bei einer normalen Klasse, ist nicht möglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse überschrieben werden, müssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlüsselwort `super` bewerkstelligt werden.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da beispielsweise nur weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, müssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Compiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622292522022,
     "parent": "n.0.114",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine *klassische*, aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert und auch zusätzlicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zusätzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen können auch miteinander kombiniert werden. Der Kompiler fügt diese im Hintergrund zu einem zusammenhängenden Konstruktor zusammen.  \nEiner Klasse können **mehrere primäre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefügt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurückgegeriffen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden unterstützt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können Sie sich als größere Pakete vorgestellen.\n* `public`: Das Element kann überall benutzt werden.\n\n\n\nZusätzlich zu Feldern und Konstruktoren ist sind ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Kopf wie Funktionen, werden jedoch in einer Klasse implementiert. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder und keine Parameter angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei den Methoden nicht berücksichtigt.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur aufsteigend zugewiesen.  \n`copy()` hingegen gibt ein identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur mit Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.  \n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Eines explizite Erzeugung des Singletons ist nicht möglich. Bei der ersten Verwendung  übernimmt dies der Kompiler.  \nMit einem **Companion Object** können die aus Java bekannten statischen Aspekte einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von Allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf ist eine Definition von Feldern und Methoden möglich. Soll eine Klasse mehrere `companion objects` besitzen, wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen ein Name vergeben. Der Aufruf auf ein solches Objekt sieht folgendermaßen aus: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist, der Bau eines eigenen Datentyp mit vordefinierten Werten. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um dem Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Funktionsweise erheblich. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum, wie bei einer normalen Klasse, zu übergeben, ist nicht möglich.  \n\n\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der Unterklasse überschrieben werden, müssen diese in der Super-Klasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden sollen, kann dies mit dem Schlüsselwort `super` geschehen.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet werden und nur deren Kopf angegeben wird, müssen erbende Sub-Klassen diese *fertig* implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Sub-Klassen bei Kompilierzeit bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert, als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin einige vordefinierte Schnittstellen.</summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitäten mitbringt, können diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Compiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgeführt.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch \"aufgeräumt\" werden, kann ein `finally`-Block angehängt werden. Außerdem könnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622292705723,
     "parent": "n.0.116",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine *klassische*, aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert und auch zusätzlicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zusätzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen können auch miteinander kombiniert werden. Der Kompiler fügt diese im Hintergrund zu einem zusammenhängenden Konstruktor zusammen.  \nEiner Klasse können **mehrere primäre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefügt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurückgegeriffen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden unterstützt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können Sie sich als größere Pakete vorgestellen.\n* `public`: Das Element kann überall benutzt werden.\n\n\n\nZusätzlich zu Feldern und Konstruktoren ist sind ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Kopf wie Funktionen, werden jedoch in einer Klasse implementiert. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder und keine Parameter angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei den Methoden nicht berücksichtigt.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur aufsteigend zugewiesen.  \n`copy()` hingegen gibt ein identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur mit Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.  \n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Eines explizite Erzeugung des Singletons ist nicht möglich. Bei der ersten Verwendung  übernimmt dies der Kompiler.  \nMit einem **Companion Object** können die aus Java bekannten statischen Aspekte einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von Allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf ist eine Definition von Feldern und Methoden möglich. Soll eine Klasse mehrere `companion objects` besitzen, wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen ein Name vergeben. Der Aufruf auf ein solches Objekt sieht folgendermaßen aus: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist, der Bau eines eigenen Datentyp mit vordefinierten Werten. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um dem Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Funktionsweise erheblich. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum, wie bei einer normalen Klasse, zu übergeben, ist nicht möglich.  \n\n\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der Unterklasse überschrieben werden, müssen diese in der Super-Klasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden sollen, kann dies mit dem Schlüsselwort `super` geschehen.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet werden und nur deren Kopf angegeben wird, müssen erbende Sub-Klassen diese *fertig* implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Sub-Klassen bei Kompilierzeit bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert, als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin einige vordefinierte Schnittstellen.</summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Eigenschaften aufweist, können diesem generische Schnittstellen vorgeschrieben werden. Sie werden nach dem Namen mit `:` getrennt angegeben.  \nDes Weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.\n\n\nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen *checked* und *unchecked Exceptions* unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Ausnahmen zu behandeln.  \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann ein solcher Ausdruck einer Variable zugewiesen werden.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try & catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch *aufgeräumt* werden, kann ein `finally`-Block angehängt werden. Außerdem kann bei dem Vorhandensein von `finally` der `catch`-Block weggelassen werden.  \nEigene Fehler können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Datentyps `String` übergeben werden."
    },
    {
     "start_checkpoint": 1622312964703,
     "parent": "n.0.118",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, ähnlich zu Java, mit dem Namen der Klasse sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine *klassische*, aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert und auch zusätzlicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zusätzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen können auch miteinander kombiniert werden. Der Kompiler fügt diese im Hintergrund zu einem zusammenhängenden Konstruktor zusammen.  \nEiner Klasse können **mehrere primäre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefügt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf ein primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurückgegeriffen und keine abermalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden unterstützt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können Sie sich als größere Pakete vorgestellen.\n* `public`: Das Element kann überall benutzt werden.\n\n\n\nZusätzlich zu Feldern und Konstruktoren ist sind ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Kopf wie Funktionen, werden jedoch in einer Klasse implementiert. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder und keine Parameter angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei den Methoden nicht berücksichtigt.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur aufsteigend zugewiesen.  \n`copy()` hingegen gibt ein identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objekt den übergebenen Wert.\n    \n\nWährend in Java Objekte nur mit Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.  \n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Felder müssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Eines explizite Erzeugung des Singletons ist nicht möglich. Bei der ersten Verwendung  übernimmt dies der Kompiler.  \nMit einem **Companion Object** können die aus Java bekannten statischen Aspekte einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von Allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf ist eine Definition von Feldern und Methoden möglich. Soll eine Klasse mehrere `companion objects` besitzen, wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen ein Name vergeben. Der Aufruf auf ein solches Objekt sieht folgendermaßen aus: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist, der Bau eines eigenen Datentyp mit vordefinierten Werten. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um dem Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse möglich und erweitert die Funktionsweise erheblich. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum, wie bei einer normalen Klasse, zu übergeben, ist nicht möglich.  \n\n\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der Unterklasse überschrieben werden, müssen diese in der Super-Klasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden sollen, kann dies mit dem Schlüsselwort `super` geschehen.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet werden und nur deren Kopf angegeben wird, müssen erbende Sub-Klassen diese *fertig* implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Sub-Klassen bei Kompilierzeit bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert, als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin einige vordefinierte Schnittstellen.</summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Eigenschaften aufweist, können diesem generische Schnittstellen vorgeschrieben werden. Sie werden nach dem Namen mit `:` getrennt angegeben.  \nDes Weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.\n\n\nDie **Ausnahmebehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen *checked* und *unchecked Exceptions* unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Ausnahmen zu behandeln.  \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann ein solcher Ausdruck einer Variable zugewiesen werden.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try & catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch *aufgeräumt* werden, kann ein `finally`-Block angehängt werden. Außerdem kann bei dem Vorhandensein von `finally` der `catch`-Block weggelassen werden.  \nEigene Ausnahmen können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Beschreibung als Parameter des Datentyps `String` übergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.57",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.116",
     "markdown": "##### Vergleich\nJede Erscheinungsform des Konstruktors hat seine Vorteile und Anwendungsbereiche. Während der Defaultkonstruktor bei einfachen Klassen, bei denen die Parameter unverändert zugewiesen werden, zu bevorzugen ist, bieten die expliziten Konstruktoren genau die Möglichkeit der vorherigen Bearbeitung. Auf dem ersten Blick scheint es so, als sei der Konstruktor mit einem `init`-Block 1:1 zu ersetzen durch einen Konstruktor mit direkter Initialisierung, da die Parameter scheinbar mit dem gleichen Ergebnis direkt zugewiesen werden können. Jedoch ist der zuletzt genannte bei komplexeren Klassen zu bevorzugen, da dort alle Daten erst auf Richtigkeit, beispielweise mit `try` und `catch`, geprüft werden können (näheres dazu in [Lektion 8](Lektion-8---Fehlerbehandlung)).\n\n##### Kombination\nDie verschiedenen Konstruktoren können auch beliebig miteinander kombiniert werden. "
    }
   ]
  },
  {
   "artifact_name": "m.58",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.121",
     "markdown": "##### Mehrere primäre Konstruktoren\nEine wichtige Eigenschaft einer Klasse fehlt aber noch: Die Erzeugung eines Objekts mit unterschiedlichen Parameterprofilen. Um das zu erreichen können in der Klasse mehrere primäre Konstruktoren implementiert werden. Diesen wird das Schlüsselwort `constructor` vorangestellt. Außerdem bekommt jeder Konstruktor sein eigenes Parameterprofil, mit dem dieser in dessen Rumpf arbeiten kann. Die Konstruktoren ähneln dabei dem `init`-Verfahren, da sie alle ihren eigenen Rumpf besitzen. Die Parameterklammern der Klasse werden weggelassen."
    }
   ]
  },
  {
   "artifact_name": "m.59",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Abschnitt3.png\" style=\"margin-left: auto; margin-right: auto; display: block; margin-bottom: 20px\"/>\n<h1 style=\"display:none\">Abschnitt 2 - Funktionale Programmierung</h1>\n\n<img src=\"images/Einführung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h2 style=\"display:none\">Einführung</h2>\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n<img src=\"images/Gliederung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h3 style=\"display:none\">Gliederung</h3>\nDieser Abschnitt folgt folgender Struktur:\n<ol>\n    <li>Klassen</li>\n    <li>Datenklassen</li>\n    <li>Objekte</li>\n    <li>Aufzählungen</li>\n    <li>Vererbung</li>\n    <li>Schnittstellen</li>\n    <li>Generizität</li>\n    <li>Ausnahmebehandlung</li>\n</ol>\n\n<img src=\"images/Lernziele.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h3 style=\"display:none\">Lernziele</h3>\nNach diesem Abschnitt sollen Sie in der Lage sein:\n<ul>\n    <li>die Unterschiede zwischen einer nullable und nonnullable Variable aufzuzeigen.</li>\n    <li>nullable Datentypen in deinem Code zu verwenden.</li>\n    <li>das Konzept der Lambda-Ausdrücke zu nennen.</li>\n    <li>korrekte Lambda-Ausdrücke zu formulieren und diese an einen gegebenen Anwendungsfall anzupassen.</li>\n    <li>Operationen auf Datenstrukturen mit mehreren passenden Lambda-Ausdrücken auszuführen.</li>\n    <li>Funktionen höherer Ordnung zu erkennen und diese zu analysieren.</li>\n</ul>  \n<img src=\"images/Literatur.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h3 style=\"display:none\">Literatur</h3>\n<p>Folgende Literatur kann in diesem Abschnitt zur Vertiefung herangezogen werden:<p>\n<ul>\n    <li>M. Kofler, Kotlin: das umfassende Handbuch. 2021.</li>\n    <li>D. Griffiths und D. Griffiths, Kotlin von Kopf bis Fuß. 2019.</li>\n    <li>D. Jemerov und S. Isakova, Kotlin in action. 2017.</li>\n    <li>C. Kohls, A. Dobrynin, und F. Leonhard, Programmieren lernen mit Kotlin Grundlagen, Objektorientierung und fortgeschrittene Konzepte. 2020.</li>\n</ul>"
    }
   ]
  },
  {
   "artifact_name": "m.60",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion1.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 1 - Klassen</h2>\n\nAufgrund der Interoperabilität mit Java ist auch Kotlin eine objektorientierte Sprache. Infolgedessen werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierten Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einführungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verändert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.61",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Es ist zu erkennen, dass der Code in Kotlin deutlich kürzer und übersichtlicher ist.  \nDer Kopf einer Klasse wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von dem Namen. Die Parameter werden nach diesem in runden Klammern angegeben. Erzeugt werden kann die Klasse, wie aus Java gewohnt, mit der Nennung des Namens der Klasse, sowie dem Aufruf eines Konstruktors. In den runden Klammern sind die erforderlichen Argumente für die Objekterzeugung zu finden.\n\n### Felder\nFelder können Klassen auf verschiedene Weisen hinzugefügt werden. Die erste Möglichkeit ist durch die Übergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei öffentlicher Sichtbarkeit ein Variablentyp (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heißt, es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, das bei Objekterzeugung mit dem Wert des Übergabeparameters gefüllt wird. Außerdem wird immer ein *unsichtbarer* Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, fügt der Compiler zusätzlich einen rudimentären Setter hinzu."
    }
   ]
  },
  {
   "artifact_name": "m.62",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Eine weitere Möglichkeit Felder zu definieren ist klassisch im Rumpf der Klasse. Diese werden jedoch nicht automatisch bei Objekterzeugung, sondern mit den angegebenen Standardwerten befüllt. Des Weiteren wird auch diesen Feldern, je nach Typ, im Hintergrund ein Getter und Setter bei Seite gestellt."
    }
   ]
  },
  {
   "artifact_name": "m.63",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "##### Konstruktor mit init-Block\nNatürlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlüsselwort `init`, gefolgt von einem Methodenrumpf. Im Vergleich zu Java werden dessen Parameter nicht direkt im Kopf des Konstruktors, sondern im Kopf der Klasse angegeben. Die dort definierten Parameter können im Konstruktor benutzt werden. Bei Namenskonflikten findet das Schlüsselwort `this` Anwendung, dass das aktuelle Objekt referenziert."
    }
   ]
  },
  {
   "artifact_name": "m.64",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "##### Vergleich\nJede Erscheinungsform des Konstruktors hat seine Vorteile und Anwendungsbereiche. Während der Defaultkonstruktor bei einfachen Klassen, bei denen die Parameter unverändert zugewiesen werden zu bevorzugen ist, bieten die expliziten Konstruktoren genau die Möglichkeit der vorherigen Bearbeitung. Auf dem ersten Blick scheint es so, als sei der Konstruktor mit einem `init`-Block 1:1 zu ersetzen durch einen Konstruktor mit direkter Initialisierung, da die Parameter scheinbar mit dem gleichen Ergebnis direkt zugewiesen werden können. Jedoch ist der zuletzt Genannte bei komplexeren Klassen zu bevorzugen, da dort alle Daten erst auf Richtigkeit, beispielweise mit `try` und `catch`, geprüft werden können (Näheres dazu in [Lektion 8](Lektion-8---Fehlerbehandlung)).\n\n##### Kombination\nDie verschiedenen Konstruktoren können auch beliebig miteinander kombiniert werden. "
    }
   ]
  },
  {
   "artifact_name": "m.65",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "#### Sekundärer Konstruktor\nMit Hilfe eines sekundären Konstruktors ist es einfach möglich alternative Wege Objekte zu erzeugen. Dazu wird ein primärer Konstruktor mit `this()` und zu bestimmenden Parametern aufgerufen. Auch kann ein anderer sekundärer Konstruktor aufgerufen, jedoch muss am Ende immer ein Primärer benutzt werden, da nur dieser das Objekt erzeugen kann. Die Implementierung eines sekundären Konstruktors ähnelt der bei Benutzung mehrerer primärer Konstruktoren. Jedoch ist nur eine Anweisung erlaubt, die von den Parametern mit `:` getrennt wird und einen primären Konstruktor aufruft."
    }
   ]
  },
  {
   "artifact_name": "m.66",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Getter und Setter\nEs können aber auch eigene Getter und Setter für jedes Feld definiert werden, falls der Variablentyp dies zulässt und diese erst im Rumpf der Klasse definiert werden. Beide müssen direkt nach dem Feld definiert werden. Auf den aktuellen Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter übergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert repräsentiert. Der Wert des Feldes wird mit einer Zuweisung an `field` geändert. Es sind immer die Datentypen der Felder zu beachten."
    }
   ]
  },
  {
   "artifact_name": "m.67",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlüsselwort `by lazy` *träge* gemacht werden. Das heißt, dass der Wert erst bei der ersten Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck nötig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Inhalt nicht noch einmal berechnet, sondern auf den gespeicherten Wert zurückgegriffen."
    }
   ]
  },
  {
   "artifact_name": "m.68",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Methoden\nDer Aufbau von Objektmethoden kann mit dem von Funktionen verglichen werden, werden jedoch im Rumpf einer Klasse definiert. Es ist möglich die Kurzschreibweise anzuwenden und eine Sichtbarkeit zuzuweisen. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits implementierte Methode, zum Beispiel `toString()`, überschrieben werden, ist das Voranstellen des Schlüsselworts `override` nötig."
    }
   ]
  },
  {
   "artifact_name": "m.69",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Aufgabe - Parkplatzverwaltung\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz repräsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Länge 5 verwirklicht werden, der als Feld repräsentiert wird. Ist ein Parkplatz belegt, so soll dieser Eintrag `true` sein. Verwenden Sie passende Sichtbarkeiten.  \nStandardmäßig wird bei Erzeugung eine passende Liste übergeben. Falls kein Parameter übergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zusätzlich eine Methode `einparken()` der die Nummer des Parkplatzes übergeben wird und diesen falls möglich belegt. Bei Erfolg soll `true` zurückgegeben werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter übergeben werden. Überschreiben Sie zusätzlich die Methode `toString()`, die den Parkplatz übersichtlich nach folgendem Muster ausgeben soll:  \n--x-- (Parkplatz Nummer 2 ist belegt)"
    }
   ]
  },
  {
   "artifact_name": "m.70",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion2.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 2 - Datenklassen</h2>\n\n\nZusätzlich zu normalen Klassen bietet Kotlin auch die Möglichkeit Klassen zu erstellen, die nur die Aufgabe der Speicherung von Daten haben. Auf den ersten Blick könnte dies auch mit normalen Klassen bewerkstelligt werden. Jedoch müssen dann alle Methoden, die eine Datenklasse in der Regel benötigt, per Hand implementiert werden. Beispiele dafür sind `toString()` oder `equals()`. Um das zu Verhindern, gibt es Datenklassen. Für diese generiert der Kotlin-Compiler im Hintergrund folgende Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Gekennzeichnet werden Datenklassen mit dem Schlüsselwort `data class`. Alle Felder, die bei den generierten Methoden berücksichtigt werden sollen, müssen in dem Kopf der Datenklasse angegeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.71",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Durch die Verwendung der `componentN()`-Methode kann auf die Felder der Datenklasse zugegriffen werden. Dabei bekommt jedes Feld eine eigene Nummer, beispielsweise in der Klasse 'Punkt' 'x' die Nummer 1, zugewiesen. Wird `N` durch die Nummer ersetzt und auf einem Objekt aufgerufen, wird das dazugehörige Feld zurückgegeben. Auch können dadurch mehrere Felder abgerufen werden, indem eine Folge als Rückgabe erwartet wird."
    }
   ]
  },
  {
   "artifact_name": "m.72",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Die Erzeugung eines neuen, identischen Objekts erfolgt mit Hilfe von `copy()`. Soll aber bestimmten Feldern ein anderer Wert zugewiesen werden, kann dies der Methode mit Namen des Feldes und dem gewünschten Wert übergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.73",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Aufgabe - Abstände\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abständen implementieren. Dazu werden folgende Komponenten benötigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primär den Wert eines Abstands speichert. Außerdem sollen in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die diesen Abstand besitzen.  \nBeispiel: `wert` des Abstandes: 3, Inhalt von `positionen`: [( Position(0,0), Position(2,1) ), ( Position(0,3), Position(3,3) ), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen übergeben werden. In ihrem Rumpf soll die [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) der beiden Punkte berechnet und der Abstand zur globale Liste `abstaende` hinzugefügt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch, sollen die beiden Positionen dem bereits vorhandenen Abstand in die Liste `positionen` hinzugefügt werden. "
    }
   ]
  },
  {
   "artifact_name": "m.74",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion3.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 3 - Objekte</h2>\n\n\nEine Besonderheit von Kotlin ist, dass nicht jedes Objekt eine Klasse benötigt. Dadurch kann beispielsweise ein statisches Feld simuliert oder unkompliziert mehrere Daten an einem Ort zusammengefasst werden.\n### Ad-hoc Objekte\nMit sogeannten Ad-hoc Objekten können Daten ähnlich einer Map komprimiert werden. Es kann ein Objekt erzeugt werden, ohne vorher eine Klasse angelegt zu haben. Dies ist mit dem Schlüsselwort `object` einzuleiten. Wie auch einer Klasse können dem Ad-hoch Objekt Felder zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.75",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Singletons\nSingletons sind Objekte, die nur ein Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Ein solches Objekt wird mit dem Schlüsselwort `object` gekennzeichnet und kann nicht einer Variable zugewiesen werden, da es erst bei der ersten Benutzung erzeugt wird. Deshalb kann es auch nicht erzeugt werden. Die Erzeugung erfolgt automatisch beim ersten Aufruf, der in der Punktnotation mit dem Namen des Singletons erfolgt. Ein Singleton kann aus Feldern und Methoden bestehen. Ein Konstruktor kann jedoch nicht angewendet werden, da die Erzeugung ohne Übergabeparameter stattfindet."
    }
   ]
  },
  {
   "artifact_name": "m.76",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Falls in einer Klasse mehrere Companion Objekte gewünscht werden, ist ab dem Zweiten das Schlüsselwort `companion` wegzulassen und außerdem ein Name anzugeben. Außerhalb der Klasse kann auf das Objekt nur durch die Klasse und nicht mit einem Objekt der Klasse zugegriffen werden."
    }
   ]
  },
  {
   "artifact_name": "m.77",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "#### Aufgabe - Nummernschilder\nImplementieren Sie eine Klasse `Auto`, die drei Felder besitzt: die `ps` (`Int`), eine `farbe` (`String`) und ein `nummernschild` (`String`). Die Nummernschilder sollen der Einfachheit nach dem Format *(A-Z)(A-Z)-(1-9)(0-9)* vergeben werden. Jedes ist einzigartig. Verwenden Sie für die Umsetzung ein `companion object`, das ein Feld, in dem alle vergebenen Nummernschilder gespeichert werden, besitzt. Fügen Sie dem Objekt zusätzlich eine Funktion hinzu, die ein noch nicht vergebenes Schild generiert. Das Suchen nach einem passenden Nummernschild kann per Brute-Force erfolgen. Auf die Laufzeit muss nicht geachtet werden."
    }
   ]
  },
  {
   "artifact_name": "m.78",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion4.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 4 - Aufzählung</h2>\n\n\nMit Hilfe einer Enumeration kann ein eigener, limitierter Datentyp erstellt werden, der nur vordefinierte Werte annehmen kann. Der Klasse wird dafür das Schlüsselwort `enum` vorangestellt. Soll ein Wert des Enums verwendet werden, muss zusätzlich der Name der Enumeration angegeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.79",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Da Enums als vollständige Klassen angesehen werden, können ihnen Felder und sogar Methoden hinzugefügt werden. Sollen Felder mit einem bestimmten Wert, der von dem Wert des Enums abhängt, gefüllt werden, erfolgt die Übergabe der Parameter hinter dem Wert des Enums."
    }
   ]
  },
  {
   "artifact_name": "m.80",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion5.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 5 - Vererbung</h2>\n\n\nIn Kotlin kann nicht von einer beliebigen Klasse geerbt werden. Diese muss als Voraussetzung den Vorsatz `open` besitzen. Dadurch wird signalisiert, dass eine Vererbung stattfinden darf. Der Namen der Klasse, von der geerbt werden soll, ist mit einem `:` getrennt hinter den Parameterklammern der erbenden Klasse zu schreiben. Dem Konstruktor der Super-Klasse werden die Parameter direkt im Kopf der Klasse übergeben. "
    }
   ]
  },
  {
   "artifact_name": "m.81",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Felder und Methoden überschreiben\nSollen Felder oder Methoden der Super-Klasse in der Sub-Klasse überschrieben werden, müssen diese ebenfalls mit `open` gekennzeichnet werden. Erst dann ist es möglich das gleiche Feld oder die gleiche Methode in der Sub-Klasse mit dem Zusatz `override` zu definieren. Soll auf das Feld oder die Methode der Oberklasse zugegriffen werden, findet das Schlüsselwort `super` Anwendung. Bei Mehrfachvererbung wird die nächst höhere Klasse angesprochen."
    }
   ]
  },
  {
   "artifact_name": "m.82",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Möglichkeit uninitierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlüsselwort `abstract` vorangestellt und können ohne Probleme vererbt werden. Die Sub-Klassen müssen jedoch die Methoden vervollständigen."
    }
   ]
  },
  {
   "artifact_name": "m.83",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<div class=\"alert alert-block alert-danger\">\n<b>TODO</b> Sealed class und interface in kotlin 1.5.0 anschauen\n</div>\n\n### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlüsselwort `sealed` vorangestellt. Sie besitzt einen privaten Konstruktor. Von dieser darf nur in dem selben Paket oder der selben Kompiliereinheit geerbet werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweigung der *default*-Fall weggelassen werden."
    }
   ]
  },
  {
   "artifact_name": "m.84",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion6.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 6 - Schnittstellen</h2>\n\n\nEin wichtiges objektorientiertes Konzept ist das der Schnittstelle. Ein bekanntes Beispiel das `Comparable`-Interface, das eine `compareTo()`-Methode voraussetzt. Aber anstelle des Vorschreibens von Methoden können auch Zugriffe definiert werden. Eine Schnittstelle besitzt das Schlüsselwort `interface` und wird bei der implementierenden Klasse, ähnlich zum Erben, angegeben. In einem Interface können sowohl Methoden voll implementiert oder nur deren Kopf angegeben werden, sodass diese von jeder Klasse selbst vervollständigt werden müssen. Außerdem können sie auch Felder beinhalten.\nKotlin bietet bereits einige vorgefertigte Schnittstellen an:\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.85",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion7.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 7 - Generizität</h2>\n\n\n### Generische Klassen\nBei manchen Softwareprojekten kommt man an generischen Klassen nicht vorbei, falls mehrfache Arbeit vermieden werden soll. Das Konzept an sich unterscheidet sich in Kotlin und Java nicht. Der generische Datentyp wird nach dem Klassennamen in `<>` angegeben und kann in der Klasse anstelle normalen Datentypen eingesetzt werden."
    }
   ]
  },
  {
   "artifact_name": "m.86",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Soll der generische Datentyp eingeschränkt werden, kann dies durch ein Interface passieren. Dieses gibt vor, welche Methoden der Datentyp implementieren muss."
    }
   ]
  },
  {
   "artifact_name": "m.87",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Generische Erweiterungsmethoden\nDas Konzept und die Implementierung von Erweiterungsmethoden wurde bereits in Abschnitt 1 kennengelernt. Es kann aber auch auf generische Klassen übertragen werden. So können beispielsweise einer generischen Liste neue Methoden hinzugefügt werden."
    }
   ]
  },
  {
   "artifact_name": "m.88",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion8.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 8 - Ausnahmebehandlung</h2>\n\n\nWährend in Java zwischen *checked* (die Möglichkeit einer Ausnahme muss behandelt werden) und *unchecked Exceptions* (Ausnahmen müssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` können Exceptions selbst ausgelöst werden. Außerdem kann ein solcher Ausdruck einer Variablen zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.89",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Zusammenfassung.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Zusammenfassung</h2>\n"
    }
   ]
  },
  {
   "artifact_name": "m.90",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Zusammenfassung.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h1 style=\"display:none\">Zusammenfassung</h1>\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlüsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, übernimmt der Compiler die Erzeugung eines Standardkonstruktors, sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) für diese Felder. Dadurch lassen sich rudimentäre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, ähnlich zu Java, mit dem Namen der Klasse, sowie den für den Konstruktor benötigten Parameter. Jedoch wird das Schlüsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufügen. Die einfachste Möglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natürlich ist auch eine *klassische*, aus Java bekannte, Implementierung möglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch händisch ein Konstruktor hinzugefügt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primärer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefügt.\n* sekundärer Konstruktor: Eine Anweisung, die auf einen primären Konstruktor verweist und eine alternative Handhabung des primären Konstruktors ermöglicht.\n\nZunächst soll der **primäre Konstruktor** betrachtet werden. Dieser ist für die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler für alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der übergebene Wert dem Feld zugewiesen. Es ist nicht möglich diesen Vorgang zu verändern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Möglichkeit ist der **Konstruktor mit `init`-Block**. Dieser ähnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlüsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) übergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf können alle Felder initialisert und auch zusätzlicher Code, der bei Erzeugung der Klasse ausgeführt werden soll, hinzugefügt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenähnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** möglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern können aber auch vordefinierte Werte verwendet werden.  \nDie Wahl der richtigen Form des primären Konstruktors für einen speziellen Fall spart Zeit und Codezeilen. Während bei einer rudimentären Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zusätzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen können auch miteinander kombiniert werden. Der Kompiler fügt diese im Hintergrund zu einem zusammenhängenden Konstruktor zusammen.  \nEiner Klasse können **mehrere primäre Konstruktoren**, die unterschiedliche Parameterprofile besitzen, hinzugefügt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse, sondern im Kopf des Konstruktors angegeben. Diese ähneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlüsselwort `constructor` gefolgt von den Parametern und dem Rumpf verwendet.    \n**Sekundäre Konstruktoren** können benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafür muss auf einen primärer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlüsselwort `constructor`, gefolgt  von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primären Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rückgabe\n\nDie Rückgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlüsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter übergeben. Um ihn im Rumpf verwenden zu können, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausführung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Möglichkeit eigene Getter zu definieren, können kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp, noch eine Initialisierung. Durch die Definition eines methonenähnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehängt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurückgegriffen und keine nochmalige Berechnung durchgeführt.  \nEin ähnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Außerdem wird ihnen das Schlüsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lässt, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprüft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden unterstützt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zusätzlich können auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module können Sie sich als größere Pakete vorstellen.\n* `public`: Das Element kann überall benutzt werden.\n\n\n\nZusätzlich zu Feldern und Konstruktoren sind ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Kopf wie Funktionen, werden jedoch in einer Klasse implementiert. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode überschrieben werden, wird der überschreibenden Methode das Schlüsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Möglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem für die Speicherung von Daten geeignet und besitzt das Schlüsselwort `data class`. Im Kopf der Klasse können nur Felder und keine Parameter angegeben werden. Für diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zusätzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei den Methoden nicht berücksichtigt.  \nDie Methode `componentN()` gibt den Wert des Feldes mit der Nummer `N` zurück. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur aufsteigend zugewiesen.  \n`copy()` hingegen gibt ein identisches Objekt zu dem zurück, auf das sie aufgerufen wird. Falls zusätzlich als Parameter Paare vom Namen des Feldes und dessen Wert (beispielsweise `x=4` für Feld `x`) angegeben werden, hat das Feld des neuen Objektes den übergebenen Wert.\n    \n\nWährend in Java Objekte nur mit Klassen erzeugt werden können, sind in Kotlin diese beiden Konzepte auch getrennt möglich.  \nIn **Ad-hoc Objekten** können Daten ähnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variablen gespeichert werden. Das hier zu verwendende Schlüsselwort lautet `object`, gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewöhnlich mit `nameObjekt.nameFeld` zugegriffen werden.  \n**Singletons** sind, wie der Name es auch schon vermuten lässt, Objekte die nur ein einziges Mal erzeugt werden können und bis zum Ende der Ausführung bestehen. Die Implementierung erinnert an eine Klasse, jedoch wird anstelle von `class` das Schlüsselwort `object` angegeben. Außerdem können einem Singleton keine Parameter übergeben werden. Den Feldern müssen somit selbst berechnete oder vordefinierte Werte zugewiesen werden. Eine explizite Erzeugung des Singletons ist nicht möglich. Bei der ersten Verwendung  übernimmt dies der Kompiler.  \nMit einem **Companion Object** können die aus Java bekannten statischen Aspekte einer Klasse simuliert werden. Ein solches Objekt ist für alle Objekte der Klasse gleich und kann von Allen gleichermaßen verwendet werden. Diese werden nur in Klassen vorgefunden und mit `companion object` eingeleitet. In dessen Rumpf ist eine Definition von Feldern und Methoden möglich. Soll eine Klasse mehrere `companion objects` besitzen, wird ab dem Zweiten das Schlüsselwort `companion` weggelassen und stattdessen ein Name vergeben. Der Aufruf auf ein solches Objekt sieht folgendermaßen aus: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist, der Bau eines eigenen Datentyps mit vordefinierten Werten. Kotlin sieht eine Aufzählung als eine Klasse an, weswegen der Kopf mit den Schlüsselwörtern `enum class` einzuleiten ist. In dem Rumpf können die möglichen Werte mit Komma getrennt angegeben werden. Um dem Kompiler zu signalisieren, dass der letzte mögliche Wert erreicht wurde, ist ein Semikolon anzufügen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist aufgrund der Verarbeitung als Klasse möglich und erweitert die Funktionsweise erheblich. Sollen dem Konstruktor Parameter übergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum, wie bei einer normalen Klasse, zu übergeben, ist nicht möglich.  \n\n\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen müssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der Unterklasse überschrieben werden, müssen diese in der Super-Klasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse können diese dann mit `override` überschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden sollen, kann dies mit dem Schlüsselwort `super` geschehen.  \nBenötigt die Unterklasse keinen eigenen primären Konstruktor, da weitere Felder hinzugefügt werden, besteht die Möglichkeit dies nur durch sekundäre Konstruktoren zu implementieren. Diese müssen auf den primären Konstruktor der Oberklasse verweisen.  \nHäufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlüsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht nötig. Falls Felder oder Methoden mit `abstract` gekennzeichnet werden und nur deren Kopf angegeben wird, müssen erbende Sub-Klassen diese *fertig* implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und können nur von Klassen der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung möglich ist. Der `else`-Block kann weggelassen werden, weil alle Sub-Klassen bei Kompilierzeit bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlüsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle können Felder und Methoden sowohl fertig implementiert, als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, müssen die vordefinierten Felder und Methoden vervollständigen. \n\n <details>\n  <summary>Wie aus Java bekannt, bietet Kotlin einige vordefinierte Schnittstellen.</summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzählung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizität**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschränkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Eigenschaften aufweist, können diesem generische Schnittstellen vorgeschrieben werden. Sie werden nach dem Namen mit `:` getrennt angegeben.  \nDes Weiteren können auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verändert sich nichts, da der Kompiler den Typ automatisch erkennt.\n\n\nDie **Ausnahmebehandlung** wurde in Kotlin vereinfacht. Während bei Java noch zwischen *checked* und *unchecked Exceptions* unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Ausnahmen zu behandeln.  \nMit `throw` können selbst Fehler ausgelöst werden. Außerdem kann ein solcher Ausdruck einer Variable zugewiesen werden.  \nAbgefangen werden können Exceptions, wie in Java, mit einem `try & catch`-Block. Soll nach der Ausführung einer der beiden Blöcke noch *aufgeräumt* werden, hilft der Anhang eines `finally`-Blocks. Außerdem kann bei dem Vorhandensein von `finally` der `catch`-Block weggelassen werden.  \nEigene Ausnahmen können durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Beschreibung als Parameter des Datentyps `String` übergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.91",
   "versions": [
    {
     "start_checkpoint": 1622445465202,
     "origin": "c.80.0"
    }
   ]
  },
  {
   "artifact_name": "m.92",
   "versions": [
    {
     "start_checkpoint": 1622448059191,
     "markdown": "### Aufgabe - Software\n<img src=\"/images/Aufgabenstellung-Vererbung\" style=\"float:right\" />"
    }
   ]
  },
  {
   "artifact_name": "m.93",
   "versions": [
    {
     "start_checkpoint": 1622448064602,
     "markdown": "### Aufgabe - Software\n<img src=\"/images/Aufgabenstellung-Vererbung.png\" style=\"float:right\" />"
    }
   ]
  },
  {
   "artifact_name": "m.94",
   "versions": [
    {
     "start_checkpoint": 1622448078339,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right\" />"
    }
   ]
  },
  {
   "artifact_name": "m.95",
   "versions": [
    {
     "start_checkpoint": 1622448092913,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />"
    }
   ]
  },
  {
   "artifact_name": "m.96",
   "versions": [
    {
     "start_checkpoint": 1622449657117,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />\nWandeln Sie das vereinfachte Klassendiagramm in Code um."
    }
   ]
  },
  {
   "artifact_name": "m.97",
   "versions": [
    {
     "start_checkpoint": 1622449754014,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />\nWandeln Sie das vereinfachte Klassendiagramm in Code um. Die Methoden `starte()`, `schreiben()` und `spielen()` sollen lediglich eine Ausgabe auslösen. Sie können sich an folgendes Beispiel halten:  \nDie Textverarbeitungssoftware Office wird gestartet.  \nDie Textverarbeitungssoftware Office schreibt...  \nDas Computerspiel Cyberpunk 2077 wird gestartet.  \nDas Computerspiel Cyberpunk 2077 wird gespielt...  \n"
    }
   ]
  },
  {
   "artifact_name": "m.98",
   "versions": [
    {
     "start_checkpoint": 1622449760455,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />\n\n\nWandeln Sie das vereinfachte Klassendiagramm in Code um. Die Methoden `starte()`, `schreiben()` und `spielen()` sollen lediglich eine Ausgabe auslösen. Sie können sich an folgendes Beispiel halten:  \nDie Textverarbeitungssoftware Office wird gestartet.  \nDie Textverarbeitungssoftware Office schreibt...  \nDas Computerspiel Cyberpunk 2077 wird gestartet.  \nDas Computerspiel Cyberpunk 2077 wird gespielt...  \n"
    }
   ]
  },
  {
   "artifact_name": "m.99",
   "versions": [
    {
     "start_checkpoint": 1622449937766,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />\n\n\nWandeln Sie das vereinfachte Klassendiagramm in Code um. Die Methoden `starte()`, `schreiben()` und `spielen()` sollen lediglich eine Ausgabe auslösen. Sie können sich an folgendes Beispiel halten:  \n\n\nDie Textverarbeitungssoftware Office wird gestartet.  \nDie Textverarbeitungssoftware Office schreibt...  \nDas Computerspiel Cyberpunk 2077 wird gestartet.  \nDas Computerspiel Cyberpunk 2077 wird gespielt...  \n"
    }
   ]
  },
  {
   "artifact_name": "m.100",
   "versions": [
    {
     "start_checkpoint": 1622450204455,
     "markdown": "### Aufgabe - Generische Liste\n\nImplementieren Sie eine generische, einfach verkettete Liste `Liste`, die neue Elemente vorne hinzufügt und entnimmt. Die Liste speichert als einzigstes das erste Element. In einer privaten Klasse `Element` soll der Wert und eine Referenz auf das nächste Element zu finden sein. "
    }
   ]
  },
  {
   "artifact_name": "m.101",
   "versions": [
    {
     "start_checkpoint": 1622460905154,
     "markdown": "### Aufgabe - Generische Liste\n\nImplementieren Sie eine generische, einfach verkettete Liste `Liste`, die neue Elemente vorne hinzufügt (`hinzufuegen`) und entnimmt (`entfernen`). `hinzufuegen()` bekommt den Wert des Elements übergeben. Falls die Operation fehlschlägt, soll `false` zurückgegeben werden. Entfernen gibt den Wert des entfernten Elements oder `null` zurück. Die Liste speichert als einziges das erste Element. In einer privaten Klasse `Element` soll der Wert und eine Referenz auf das nächste Element zu finden sein. "
    }
   ]
  },
  {
   "artifact_name": "m.102",
   "versions": [
    {
     "start_checkpoint": 1622461792805,
     "markdown": "### Aufgabe - Schnittstelle für eine Liste\nIn Konzepte der Programmierung wurde die einfach verkettete Liste intensiv behandelt. Implementieren Sie eine Schnittstelle, die eine solche Liste von `Int`s vorgibt. Es soll ein erstes Element und zwei Methoden, die Elemente hinzufügt und entfernt. Wählen Sie einen passenden Variablentyp, Parameter und Rückgaben. Da eine Schnittstelle schwer zu überprüfen ist, gibt es zu dieser Aufgabe keinen Test."
    }
   ]
  },
  {
   "artifact_name": "m.103",
   "versions": [
    {
     "start_checkpoint": 1622461989425,
     "markdown": "### Aufgabe - Schnittstelle für eine Liste\nIn Konzepte der Programmierung wurde die einfach verkettete Liste intensiv behandelt. Implementieren Sie eine Schnittstelle `Liste`, die eine solche Liste von Elemente vorgibt. Es soll ein erstes Element und zwei Methoden, die Elemente hinzufügt und entfernt. Wählen Sie einen passenden Variablentyp, Parameter und Rückgaben. Da eine Schnittstelle schwer zu überprüfen ist, gibt es zu dieser Aufgabe keinen Test."
    }
   ]
  },
  {
   "artifact_name": "m.104",
   "versions": [
    {
     "start_checkpoint": 1622462864423,
     "markdown": "### Aufgabe - Parkplatzverwaltung mit Ausnahmen\nIn Lektion 1 wurde eine Parkplatzverwaltung implementiert. Erweitern Sie ihre Lösung oder die Musterlösung insoweit ab, dass die Methode `einparken()` `Unit` zurückgibt und bei Fehlschlag einen eigens definierten Fehler `ParkplatzVoll` wirft. Diesem soll die Nummer des Parkplatzes übergeben werden, aus der eine schöne Fehlermeldung generiert werden soll. Schreiben Sie zusätzlich ein Hauptprogramm, in dem Sie einen Fehler absichtlich auslösen und abfangen. Mit diesem können Sie ihre Lösung testen."
    }
   ]
  },
  {
   "artifact_name": "m.105",
   "versions": [
    {
     "start_checkpoint": 1622557421858,
     "markdown": "Werden die Methoden händisch implementiert, können diesen aber abweichende Sichtbarkeiten zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.106",
   "versions": [
    {
     "start_checkpoint": 1622557838870,
     "markdown": "Werden die Methoden händisch implementiert, können diesen teilweise abweichende Sichtbarkeiten zugewiesen werden. Der Getter muss den identischen Sichtbarkeitstyp aufweisen. Im Gegensatz dazu kann dem Setter die gleich oder eine *engere* Sichtbarkeit zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.107",
   "versions": [
    {
     "start_checkpoint": 1622557863403,
     "markdown": "Werden die Methoden händisch implementiert, können diesen teilweise abweichende Sichtbarkeiten zugewiesen werden. Der Getter muss den identischen Sichtbarkeitstyp aufweisen. Im Gegensatz dazu kann dem Setter die gleich oder eine *engere* Sichtbarkeit vorangestellt werden."
    }
   ]
  },
  {
   "artifact_name": "m.108",
   "versions": [
    {
     "start_checkpoint": 1622558305043,
     "markdown": "Im Folgenden werden alle Klassen, Felder und Methoden in der Regel öffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als `public` verlangt. Sie können aber natürlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen auf die Getter und Setter implementieren."
    }
   ]
  },
  {
   "artifact_name": "m.109",
   "versions": [
    {
     "start_checkpoint": 1622558336335,
     "markdown": "<div class=\"alert alert-block alert-info\">\n<b>TODO</b> Sichtbarkeiten im Code???\n</div>\n\nIm Folgenden werden alle Klassen, Felder und Methoden in der Regel öffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als `public` verlangt. Sie können aber natürlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen auf die Getter und Setter implementieren."
    }
   ]
  },
  {
   "artifact_name": "m.110",
   "versions": [
    {
     "start_checkpoint": 1622558346077,
     "markdown": "<div class=\"alert alert-block alert-info\">\nIm Folgenden werden alle Klassen, Felder und Methoden in der Regel öffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als `public` verlangt. Sie können aber natürlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen auf die Getter und Setter implementieren.\n</div>\n\n"
    }
   ]
  },
  {
   "artifact_name": "m.111",
   "versions": [
    {
     "start_checkpoint": 1622558366022,
     "markdown": "<div class=\"alert alert-block alert-info\">\nIm Folgenden werden alle Klassen, Felder und Methoden in der Regel öffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als <code>public</code> verlangt. Sie können aber natürlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen auf die Getter und Setter implementieren.\n</div>\n\n"
    }
   ]
  },
  {
   "artifact_name": "m.112",
   "versions": [
    {
     "start_checkpoint": 1622558394999,
     "markdown": "<div class=\"alert alert-block alert-info\">\nIm Folgenden werden alle Klassen, Felder und Methoden in der Regel öffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als <code>public</code> verlangt. Sie können aber natürlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen für die Getter und Setter beschränken.\n</div>"
    }
   ]
  }
 ],
 "rawCells": [],
 "snippets": [],
 "output": [
  {
   "artifact_name": "o.0",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.1.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_6.jupyter.kts (4:57 - 62) Cannot access 'alter': it is private in 'Person'"
      }
     ]
    },
    {
     "start_checkpoint": 1619166409884,
     "parent": "c.1.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Person 1, Line_0_jupyter$Person@642b2176: \nName: Max Mustermann, Alter: 21\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.1",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.2.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Marke von a1: BMW, Farbe von a1: Gelb.\nFarbe von a1 nach Umlackierung: Rot.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.2",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.3.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Marke von c1: Fuhitsu, ist c1 an?: false.\nist c1 an?: true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.3",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.4.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Die Flasche mit der Farbe Grau ist zu 20% gefüllt.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.4",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.5.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Bett b1: Länge 160, Breite 200, belegt false\nBett b2: Länge 0, Breite 50, belegt true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.5",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.6.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Tisch t1: Länge 100, Breite 100, Farbe Braun\nTisch t2: Länge 0, Breite 50, Farbe Weiß\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.6",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.7.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Stuhl s1: Länge 20, Breite 20, belegt true\nStuhl s2: Länge 0, Breite 30, belegt false\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.7",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.8.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Konstruktor eines normalen Fensters\nFenster fensterNormal: Länge 50, Breite 0, Zustand Gebraucht \n\nKonstruktor eines quadratischen Fensters\nFenster fensterQuadrat: Länge 60, Breite 60, Zustand Schmutzig \n\nKonstruktor eines neuen Fensters\nFenster fensterNeu: Länge 100, Breite 120, Zustand Neu\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.8",
   "versions": [
    {
     "start_checkpoint": 1619167416345,
     "parent": "c.12.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Batterie eigeneBatterie: Kapazität 2000, Wiederaufladbar true, Ladezyklen 42, Status Gebraucht\nBatterie neueBatterie: Kapazität 3000, Wiederaufladbar false, Ladezyklen 0, Status Neu\nBatterie BBBatterie: Kapazität 2400, Wiederaufladbar false, Ladezyklen 0, Status Neu\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.9",
   "versions": [
    {
     "start_checkpoint": 1619167469117,
     "parent": "c.12.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Batterie eigeneBatterie: Kapazität 2000, Wiederaufladbar true, Ladezyklen 42, Status Gebraucht\nBatterie neueBatterie: Kapazität 3000, Wiederaufladbar false, Ladezyklen 0, Status Neu\nBatterie BBBatterie: Kapazität 2400, Wiederaufladbar false, Ladezyklen 0, Status Neu\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.10",
   "versions": [
    {
     "start_checkpoint": 1619167525913,
     "parent": "c.12.4",
     "raw": [
      {
       "name": "stdout",
       "text": "Batterie eigeneBatterie: Kapazität 2000, Wiederaufladbar true, Ladezyklen 42, Status Gebraucht.\nBatterie neueBatterie: Kapazität 3000, Wiederaufladbar false, Ladezyklen 0, Status Neu.\nBatterie BBBatterie: Kapazität 2400, Wiederaufladbar false, Ladezyklen 0, Status Neu.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.11",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.13.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Person p1, Line_0_jupyter$Person@642b2176: \nName: Max Mustermann, Alter: 21\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.12",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.14.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Batterie eigeneBatterie: Kapazität 2000, Wiederaufladbar true, Ladezyklen 42, Status Gebraucht\nBatterie neueBatterie: Kapazität 3000, Wiederaufladbar false, Ladezyklen 0, Status Neu\nBatterie BBBatterie: Kapazität 2400, Wiederaufladbar false, Ladezyklen 0, Status Neu\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.13",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.15.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_11.jupyter.kts (5:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (10:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (15:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (20:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (25:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (30:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (35:13 - 18) Unresolved reference: Pizza"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.14",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.16.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_21.jupyter.kts (50:13 - 18) None of the following functions can be called with the arguments supplied: \npublic constructor Pizza(groeße: Int) defined in Line_21_jupyter.Pizza\npublic constructor Pizza(groeße: Int, belaege: List<String>, geschnitten: Boolean) defined in Line_21_jupyter.Pizza"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.15",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.17.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Person p1: Name: Max Mustermann, Alter -1\nPerson p1: Name: Max Mustermann, Alter 21\nPerson p1: Name: Max Mustermann, Alter 21\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.16",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.18.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Person p1: Name: Max Mustermann, Alter 21, Volljährig true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.17",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.19.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Volljährigkeit wird berechnet...\ntrue\ntrue\n"
      }
     ]
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.19.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Wird berechnet...\ntrue\ntrue\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.18",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.20.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Volljährig\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.19",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.21.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "false\ntrue\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.20",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.22.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Vor Geburtstag: Max Mustermann ist 30 Jahre alt.\nNach Geburtstag: Max Mustermann ist 31 Jahre alt.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.21",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.23.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt p1: Punkt(x=0, y=0, z=0)\np1 und p2 sind ungleich.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.22",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.24.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: 2\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.23",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.25.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "p1: Punkt(x=0, y=1, z=2)\np2: Punkt(x=0, y=1, z=2)\np3: Punkt(x=4, y=1, z=2)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.24",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.26.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt p1 ist im Ursprung: true, Punkt(x=0, y=0, z=0)\nPunkt p2 ist im Ursprung: false, Punkt(x=1, y=1, z=1)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.25",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.27.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Kotlin\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.26",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.28.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Berechnung ohne Singleton: 15\nSingleton Rechner wurde erzeugt.\nBerechnung mit Singleton: 15\nZufallszahl des Singletons: 4\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.27",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.29.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Die Marikelnummer von Max ist 0.\nDie Marikelnummer von Anna ist 1.\nDie Marikelnummer von Simon ist 2.\nDie Marikelnummer von Sophie ist 3.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.28",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.30.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Die Nummer des Standard Companion Objects ist 1.\nDie Nummer des Companion Objects Zwei ist 2.\nDie Nummer des Companion Objects Drei ist 3.\nEs ist aktuell 15:48:34.186670 Uhr.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.29",
   "versions": [
    {
     "start_checkpoint": 1619273462931,
     "parent": "c.32.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Marikelnummer von Max ist 0.\nDie Marikelnummer von Anna ist 1.\nDie Marikelnummer von Simon ist 2.\nDie Marikelnummer von Sophie ist 3.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.30",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.33.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Alle Tests bestanden!\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.31",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.34.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Alle Tests bestanden!\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.32",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.35.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Der Name von montag ist MONTAG\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.33",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.36.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Alle Einträge des Enums: MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG, SAMSTAG, SONNTAG, \nVollständiger Name von FREITAG: FREITAG\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.34",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.37.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Montag ist ein Tag des Wochenendes: false, Nummer des Tags: 1, Zufallszahl: 8\nSamstag ist ein Tag des Wochenendes: true, Nummer des Tags: 6, Zufallszahl: 8\n"
      }
     ]
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.37.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Montag ist ein Tag des Wochenendes: false, Nummer des Tags: 1, Zufallszahl: 3\nSamstag ist ein Tag des Wochenendes: true, Nummer des Tags: 6, Zufallszahl: 3\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.35",
   "versions": [
    {
     "start_checkpoint": 1619344965296,
     "parent": "c.40.5",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Line_6_jupyter$Person@6c6fdf5d\ns1: Line_6_jupyter$Student@187c8f96\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.36",
   "versions": [
    {
     "start_checkpoint": 1619344997121,
     "parent": "c.40.6",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Line_7_jupyter$Person@25e9f5e6\ns1: Line_7_jupyter$Student@512319dc\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.37",
   "versions": [
    {
     "start_checkpoint": 1619345039116,
     "parent": "c.40.7",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt.\ns1: Ich bin Erika Mustermann und bin 21 Jahre alt.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.38",
   "versions": [
    {
     "start_checkpoint": 1619345077293,
     "parent": "c.40.8",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt.\ns1: Ich bin Erika Mustermann, bin 21 Jahre alt und besitze die Matrikelnummer §matrikelnummer.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.39",
   "versions": [
    {
     "start_checkpoint": 1619345085096,
     "parent": "c.40.9",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt.\ns1: Ich bin Erika Mustermann, bin 21 Jahre alt und besitze die Matrikelnummer 0.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.40",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.45.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt. Für die Horde!\nMax Mustermann hat Geburtstag. Alles Gute!\np1: Ich bin Max Mustermann und bin 26 Jahre alt. Für die Horde!\ns1: Ich bin Erika Mustermann, bin 21 Jahre alt und habe die Matrikelnummer 0. Für die Allianz! Oder vielleicht doch: Für die Horde!?\nErika Mustermann hat Geburtstag. Alles Gute!\ns1: Ich bin Erika Mustermann, bin 20 Jahre alt und habe die Matrikelnummer 0. Für die Allianz! Oder vielleicht doch: Für die Horde!?\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.41",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.46.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt p1: x: 4, y: 2, z: 8\nPunkt p2: x: 0, y: 0, z: 0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.42",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.47.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Laptop wurde eingeschalten.\nStandcomputer wurde eingeschalten.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.43",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.48.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_13.jupyter.kts (2:41 - 47) Cannot access '<init>': it is private in 'Fehler'\nLine_13.jupyter.kts (2:41 - 47) This type is sealed, so it can be inherited by only its own nested classes or objects\nLine_13.jupyter.kts (3:27 - 29) Data class must have at least one primary constructor parameter\nLine_13.jupyter.kts (3:32 - 38) Cannot access '<init>': it is private in 'Fehler'\nLine_13.jupyter.kts (3:32 - 38) This type is sealed, so it can be inherited by only its own nested classes or objects\nLine_13.jupyter.kts (4:26 - 28) Data class must have at least one primary constructor parameter\nLine_13.jupyter.kts (4:31 - 37) Cannot access '<init>': it is private in 'Fehler'\nLine_13.jupyter.kts (4:31 - 37) This type is sealed, so it can be inherited by only its own nested classes or objects\nLine_13.jupyter.kts (9:8 - 22) Incompatible types: Line_13_jupyter.Laufzeitfehler and Line_13_jupyter.Kompilierfehler\nLine_13.jupyter.kts (10:5 - 23) Check for instance is always 'true'\nLine_13.jupyter.kts (11:8 - 22) Incompatible types: Line_13_jupyter.Referenzfehler and Line_13_jupyter.Kompilierfehler"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.44",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.49.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "rechner.dieZahl: 42\nrechner.add2(5,3): 8\nrechner.add3(5,9,3): 17\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.45",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.50.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "s1: Speicher(platz1=1, platz2=2, platz3=3)\ns2: Speicher(platz1=[1, 2, 3], platz2=[1, 2, 3], platz3=[1, 2, 3])\ns3: Speicher(platz1=Kotlin, platz2=Java, platz3=C)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.46",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.51.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "gleichheitstestInt.istGleich(3,3): true\ngleichheitstestInt.istGleich(10,3): false\ngleichheitstestString.istGleich('Kotlin','Kotlin'): true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.47",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.52.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "istGleich(3,3): true\nistGleich('Kotlin','Kotlin'): true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.48",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.53.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Entferntes Element: 1\nliste: [3, 6, 8, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.49",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "c.57.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt p1: Punkt(x=0, y=0, z=0)\nPunkt p2: Punkt(x=1, y=1, z=1)\np1 und p2 sind ungleich.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.50",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "c.58.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_23.jupyter.kts (3:31 - 38) Unresolved reference: Abstand\nLine_23.jupyter.kts (6:26 - 34) Unresolved reference: Position\nLine_23.jupyter.kts (6:41 - 49) Unresolved reference: Position\nLine_23.jupyter.kts (6:56 - 64) Unresolved reference: Position\nLine_23.jupyter.kts (6:71 - 79) Unresolved reference: Position\nLine_23.jupyter.kts (7:26 - 34) Unresolved reference: Position\nLine_23.jupyter.kts (7:41 - 49) Unresolved reference: Position\nLine_23.jupyter.kts (7:57 - 65) Unresolved reference: Position\nLine_23.jupyter.kts (7:72 - 80) Unresolved reference: Position\nLine_23.jupyter.kts (10:9 - 24) Unresolved reference: berechneAbstand\nLine_23.jupyter.kts (13:19 - 21) Unresolved reference: it"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.51",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "c.59.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Alle Tests bestanden!\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.52",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "c.61.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Es ist ein Laufzeitfehler aufgetreten.\n"
      }
     ]
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.61.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Es ist ein Referenzfehler aufgetreten.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.53",
   "versions": [
    {
     "start_checkpoint": 1622203944610,
     "parent": "c.13.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Person p1: Line_0$Person@61ec3f97\nName: Max Mustermann, Alter: 21\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.54",
   "versions": [
    {
     "start_checkpoint": 1622204008193,
     "parent": "c.13.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Person p1: Line_1$Person@653ab1f7\nName: Max Mustermann, Alter: 21\n",
       "output_type": "stream"
      }
     ]
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.13.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Person p1: Line_0$Person@1be52985\nName: Max Mustermann, Alter: 21\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.55",
   "versions": [
    {
     "start_checkpoint": 1622204182191,
     "parent": "c.3.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Marke von c1: Fuhitsu, ist c1 an?: false.\nIst c1 an?: true\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.56",
   "versions": [
    {
     "start_checkpoint": 1622204907095,
     "parent": "c.8.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Konstruktion eines normalen Fensters\nFenster fensterNormal: Länge 50, Breite 0, Zustand Gebraucht \n\nKonstruktion eines quadratischen Fensters\nFenster fensterQuadrat: Länge 60, Breite 60, Zustand Schmutzig \n\nKonstruktion eines neuen Fensters\nFenster fensterNeu: Länge 100, Breite 120, Zustand Neu\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.57",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "c.66.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Alle Tests bestanden!\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.58",
   "versions": [
    {
     "start_checkpoint": 1622209406266,
     "parent": "c.21.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Versuch 1: false\nVersuch 2: true\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.59",
   "versions": [
    {
     "start_checkpoint": 1622209870934,
     "parent": "c.24.1",
     "raw": [
      {
       "name": "stdout",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: 2, 3\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.60",
   "versions": [
    {
     "start_checkpoint": 1622210144419,
     "parent": "c.24.2",
     "raw": [
      {
       "name": "stdout",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: 2\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.61",
   "versions": [
    {
     "start_checkpoint": 1622210151826,
     "parent": "c.24.3",
     "raw": [
      {
       "name": "stdout",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: z\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.62",
   "versions": [
    {
     "start_checkpoint": 1622210205883,
     "parent": "c.24.4",
     "raw": [
      {
       "name": "stdout",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: 2\na: 0, b: 1\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.63",
   "versions": [
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.3.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Marke von c1: Fuhitsu, ist c1 an?: false.\nIst c1 an?: true\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.64",
   "versions": [
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.7.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Stuhl s1: Länge 20, Breite 20, belegt true\nStuhl s2: Länge 0, Breite 30, belegt false\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.65",
   "versions": [
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.25.1",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Punkt(x=0, y=1, z=2)\np2: Punkt(x=0, y=1, z=2)\np3: Punkt(x=4, y=1, z=2)\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.66",
   "versions": [
    {
     "start_checkpoint": 1622211105740,
     "parent": "c.30.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Nummer des Standard Companion Objects ist 1.\nDie Nummer des Companion Objects Zwei ist 2.\nDie Nummer des Companion Objects Drei ist 3.\nEs ist aktuell 16:16:29.853940 Uhr.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.67",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.62.0",
     "raw": [
      {
       "execution_count": 14,
       "output_type": "execute_result",
       "data": {
        "text/plain": "63"
       },
       "metadata": {}
      }
     ]
    },
    {
     "start_checkpoint": 1622290272824,
     "parent": "c.62.0",
     "raw": [
      {
       "execution_count": 41,
       "output_type": "execute_result",
       "data": {
        "text/plain": "66"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.68",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.63.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Zeichenkette Kotlin kann nicht in eine ganze Zahl umgewandelt werden.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.69",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.64.0",
     "raw": [
      {
       "execution_count": 16,
       "output_type": "execute_result",
       "data": {
        "text/plain": "17"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.70",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.35.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Der Name von montag ist MONTAG.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.71",
   "versions": [
    {
     "start_checkpoint": 1622286007574,
     "parent": "c.40.10",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt.\ns1: Mein Name ist Erika Mustermann, ich bin 21 Jahre alt und besitze die Matrikelnummer 0.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.72",
   "versions": [
    {
     "start_checkpoint": 1622286066819,
     "parent": "c.40.11",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Mein Name ist Max Mustermann und ich bin 25 Jahre alt.\ns1: Mein Name ist Erika Mustermann, ich bin 21 Jahre alt und besitze die Matrikelnummer 0.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.73",
   "versions": [
    {
     "start_checkpoint": 1622286097813,
     "parent": "c.45.1",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Mein Name ist Max Mustermann und ich bin 25 Jahre alt. Für die Horde!\nMax Mustermann hat Geburtstag. Alles Gute!\np1: Mein Name ist Max Mustermann und ich bin 26 Jahre alt. Für die Horde!\ns1: Mein Name ist Erika Mustermann, ich bin 21 Jahre alt und habe die Matrikelnummer 0. Für die Allianz! Oder vielleicht doch: Für die Horde!?\nErika Mustermann hat Geburtstag. Alles Gute!\ns1: Mein Name ist Erika Mustermann, ich bin 20 Jahre alt und habe die Matrikelnummer 0. Für die Allianz! Oder vielleicht doch: Für die Horde!?\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.74",
   "versions": [
    {
     "start_checkpoint": 1622286553284,
     "parent": "c.45.3",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Mein Name ist Max Mustermann und ich bin 25 Jahre alt. Für die Horde!\nMax Mustermann hat Geburtstag. Alles Gute!\np1: Mein Name ist Max Mustermann und ich bin 26 Jahre alt. Für die Horde!\ns1: Mein Name ist Erika Mustermann, ich bin 21 Jahre alt und habe die Matrikelnummer 0. Für die Allianz! Oder vielleicht doch: Für die Horde!?\nErika Mustermann hat Geburtstag. Alles Gute!\ns1: Mein Name ist Erika Mustermann, ich bin 20 Jahre alt und habe die Matrikelnummer 0. Für die Allianz! Oder vielleicht doch: Für die Horde!?\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.75",
   "versions": [
    {
     "start_checkpoint": 1622286910420,
     "parent": "c.61.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Es ist ein Kompilierfehler aufgetreten.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.76",
   "versions": [
    {
     "start_checkpoint": 1622286961921,
     "parent": "c.61.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Es ist ein Referenzfehler aufgetreten.\n",
       "output_type": "stream"
      }
     ]
    },
    {
     "start_checkpoint": 1622286964294,
     "parent": "c.61.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Laufzeitfehler(f=2)\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.77",
   "versions": [
    {
     "start_checkpoint": 1622287051823,
     "parent": "c.61.3",
     "raw": [
      {
       "name": "stdout",
       "text": "Es ist ein Kompilierfehler Kompilierfehler(fehlercode=42) aufgetreten.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.78",
   "versions": [
    {
     "start_checkpoint": 1622290123775,
     "parent": "c.53.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Entferntes Element: 1\nlisteq: [3, 6, 8, 10]\nEntferntes Element: e\nlistew: [f, w, t, q]\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.79",
   "versions": [
    {
     "start_checkpoint": 1622290183581,
     "parent": "c.53.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Entferntes Element: 1\nlisteq: [3, 6, 8, 10]\nEntferntes Element: e\nliste2: [f, w, t, q]\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.80",
   "versions": [
    {
     "start_checkpoint": 1622290193733,
     "parent": "c.53.3",
     "raw": [
      {
       "name": "stdout",
       "text": "Entferntes Element von liste1: 1\nlisteq: [3, 6, 8, 10]\nEntferntes Element von liste2: e\nliste2: [f, w, t, q]\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.81",
   "versions": [
    {
     "start_checkpoint": 1622290204256,
     "parent": "c.53.5",
     "raw": [
      {
       "name": "stdout",
       "text": "Entferntes Element von liste1: 1\nlisteq: [3, 6, 8, 10]\nEntferntes Element von liste2: e\nliste2: [f, w, t, q]\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.82",
   "versions": [
    {
     "start_checkpoint": 1622290304056,
     "parent": "c.62.1",
     "raw": [
      {
       "execution_count": 45,
       "output_type": "execute_result",
       "data": {
        "text/plain": "35"
       },
       "metadata": {}
      }
     ]
    },
    {
     "start_checkpoint": 1622290305955,
     "parent": "c.62.1",
     "raw": [
      {
       "execution_count": 46,
       "output_type": "execute_result",
       "data": {
        "text/plain": "7"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.83",
   "versions": [
    {
     "start_checkpoint": 1622290337397,
     "parent": "c.62.2",
     "raw": [
      {
       "execution_count": 47,
       "output_type": "execute_result",
       "data": {
        "text/plain": "53"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.84",
   "versions": [
    {
     "start_checkpoint": 1622290370267,
     "parent": "c.62.3",
     "raw": [
      {
       "name": "stdout",
       "text": "Int\n",
       "output_type": "stream"
      },
      {
       "execution_count": 50,
       "output_type": "execute_result",
       "data": {
        "text/plain": "95"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.85",
   "versions": [
    {
     "start_checkpoint": 1622290408459,
     "parent": "c.62.4",
     "raw": [
      {
       "execution_count": 53,
       "output_type": "execute_result",
       "data": {
        "text/plain": "27"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.86",
   "versions": [
    {
     "start_checkpoint": 1622290541161,
     "parent": "c.63.1",
     "raw": [
      {
       "execution_count": 57,
       "output_type": "execute_result",
       "data": {
        "text/plain": "231"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.87",
   "versions": [
    {
     "start_checkpoint": 1622290562913,
     "parent": "c.63.3",
     "raw": [
      {
       "execution_count": 59,
       "output_type": "execute_result",
       "data": {
        "text/plain": "231"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.88",
   "versions": [
    {
     "start_checkpoint": 1622290572241,
     "parent": "c.63.4",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Zeichenkette Kotlin kann nicht in eine ganze Zahl umgewandelt werden.\njava.lang.NumberFormatException: For input string: \"Kotlin\"\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.89",
   "versions": [
    {
     "start_checkpoint": 1622290587221,
     "parent": "c.63.5",
     "raw": [
      {
       "execution_count": 61,
       "output_type": "execute_result",
       "data": {
        "text/plain": "231"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.90",
   "versions": [
    {
     "start_checkpoint": 1622290655058,
     "parent": "c.63.7",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Zeichenkette Kotlin kann nicht in eine ganze Zahl umgewandelt werden.\njava.lang.NumberFormatException: For input string: \"Kotlin\"\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.91",
   "versions": [
    {
     "start_checkpoint": 1622291067351,
     "parent": "c.73.2",
     "raw": [
      {
       "execution_count": 69,
       "output_type": "execute_result",
       "data": {
        "text/plain": "2"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.92",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "c.74.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Laptop wurde eingeschalten.\nStandcomputer wurde eingeschalten.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.93",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "c.75.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Der Parameter muss zwischen 0 und 100 sein, ist aber -57\nLine_66$KeineProzentzahl: Der Parameter muss zwischen 0 und 100 sein, ist aber -57\norg.jetbrains.kotlinx.jupyter.ReplEvalRuntimeException: Der Parameter muss zwischen 0 und 100 sein, ist aber -57\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.InternalEvaluatorImpl.eval(InternalEvaluatorImpl.kt:91)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.CellExecutorImpl$execute$1$result$1.invoke(CellExecutorImpl.kt:63)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.CellExecutorImpl$execute$1$result$1.invoke(CellExecutorImpl.kt:62)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.withHost(repl.kt:536)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.CellExecutorImpl.execute(CellExecutorImpl.kt:62)\n\tat org.jetbrains.kotlinx.jupyter.repl.CellExecutor$DefaultImpls.execute$default(CellExecutor.kt:13)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl$eval$1.invoke(repl.kt:371)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl$eval$1.invoke(repl.kt:361)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.withEvalContext(repl.kt:346)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.eval(repl.kt:361)\n\tat org.jetbrains.kotlinx.jupyter.ProtocolKt$shellMessagesHandler$res$1.invoke(protocol.kt:291)\n\tat org.jetbrains.kotlinx.jupyter.ProtocolKt$shellMessagesHandler$res$1.invoke(protocol.kt:290)\n\tat org.jetbrains.kotlinx.jupyter.JupyterConnection$runExecution$execThread$1.invoke(connection.kt:162)\n\tat org.jetbrains.kotlinx.jupyter.JupyterConnection$runExecution$execThread$1.invoke(connection.kt:160)\n\tat kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)\nCaused by: Line_66$KeineProzentzahl: Der Parameter muss zwischen 0 und 100 sein, ist aber -57\n\tat Line_66.<init>(Line_66.jupyter-kts:8)\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:64)\n\tat java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:500)\n\tat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:481)\n\tat kotlin.script.experimental.jvm.BasicJvmScriptEvaluator.evalWithConfigAndOtherScriptsResults(BasicJvmScriptEvaluator.kt:96)\n\tat kotlin.script.experimental.jvm.BasicJvmScriptEvaluator.invoke$suspendImpl(BasicJvmScriptEvaluator.kt:41)\n\tat kotlin.script.experimental.jvm.BasicJvmScriptEvaluator.invoke(BasicJvmScriptEvaluator.kt)\n\tat kotlin.script.experimental.jvm.BasicJvmReplEvaluator.eval(BasicJvmReplEvaluator.kt:51)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.InternalEvaluatorImpl$eval$resultWithDiagnostics$1.invokeSuspend(InternalEvaluatorImpl.kt:84)\n\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n\tat kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106)\n\tat kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)\n\tat kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:84)\n\tat kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:59)\n\tat kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source)\n\tat kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt:38)\n\tat kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.InternalEvaluatorImpl.eval(InternalEvaluatorImpl.kt:84)\n\t... 14 more\n\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.94",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "c.78.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Es konnten keine zwei Autos mit dem gleichen Nummernschild gefunden werden.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.95",
   "versions": [
    {
     "start_checkpoint": 1622445448043,
     "parent": "c.78.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Super! Alle Nummernschilder sind einzigartig.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.96",
   "versions": [
    {
     "start_checkpoint": 1622445629223,
     "parent": "c.81.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Super! Alle Nummernschilder sind einzigartig.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.97",
   "versions": [
    {
     "start_checkpoint": 1622446438359,
     "parent": "c.84.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Richtig! Es traten keine Fehler auf.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.98",
   "versions": [
    {
     "start_checkpoint": 1622448670796,
     "parent": "c.87.0",
     "raw": [
      {
       "execution_count": 29,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Office"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.99",
   "versions": [
    {
     "start_checkpoint": 1622448728040,
     "parent": "c.88.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.100",
   "versions": [
    {
     "start_checkpoint": 1622448767131,
     "parent": "c.89.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.101",
   "versions": [
    {
     "start_checkpoint": 1622448836926,
     "parent": "c.90.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.102",
   "versions": [
    {
     "start_checkpoint": 1622448873498,
     "parent": "c.91.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      },
      {
       "execution_count": 35,
       "output_type": "execute_result",
       "data": {
        "text/plain": "[Line_39.Software]"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.103",
   "versions": [
    {
     "start_checkpoint": 1622448912229,
     "parent": "c.92.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.104",
   "versions": [
    {
     "start_checkpoint": 1622448923282,
     "parent": "c.93.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.105",
   "versions": [
    {
     "start_checkpoint": 1622448961246,
     "parent": "c.94.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.106",
   "versions": [
    {
     "start_checkpoint": 1622448968685,
     "parent": "c.95.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\nFehler\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.107",
   "versions": [
    {
     "start_checkpoint": 1622449325160,
     "parent": "c.96.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\nFehler\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.108",
   "versions": [
    {
     "start_checkpoint": 1622449328804,
     "parent": "c.97.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.109",
   "versions": [
    {
     "start_checkpoint": 1622449386830,
     "parent": "c.98.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.110",
   "versions": [
    {
     "start_checkpoint": 1622449412581,
     "parent": "c.99.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.111",
   "versions": [
    {
     "start_checkpoint": 1622449427152,
     "parent": "c.100.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.112",
   "versions": [
    {
     "start_checkpoint": 1622449455419,
     "parent": "c.101.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.113",
   "versions": [
    {
     "start_checkpoint": 1622449459194,
     "parent": "c.102.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\nFehler! java.lang.Exception: Test\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.114",
   "versions": [
    {
     "start_checkpoint": 1622449563208,
     "parent": "c.103.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.115",
   "versions": [
    {
     "start_checkpoint": 1622449581627,
     "parent": "c.104.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\nSuper! Ihre Lösung ist richtig.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.116",
   "versions": [
    {
     "start_checkpoint": 1622461253120,
     "parent": "c.105.0",
     "raw": [
      {
       "execution_count": 86,
       "output_type": "execute_result",
       "data": {
        "text/plain": "[]"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.117",
   "versions": [
    {
     "start_checkpoint": 1622461274695,
     "parent": "c.106.0",
     "raw": [
      {
       "execution_count": 87,
       "output_type": "execute_result",
       "data": {
        "text/plain": "[kotlin.Any]"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.118",
   "versions": [
    {
     "start_checkpoint": 1622462409997,
     "parent": "c.111.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Line_112$ParkplatzVoll: Der Parkplatz 2 ist belegt.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.119",
   "versions": [
    {
     "start_checkpoint": 1622462466361,
     "parent": "c.112.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Line_113$ParkplatzVoll: Der Parkplatz 2 ist belegt.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.120",
   "versions": [
    {
     "start_checkpoint": 1622462480225,
     "parent": "c.113.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Line_114$ParkplatzVoll: Der Parkplatz 2 ist belegt.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.121",
   "versions": [
    {
     "start_checkpoint": 1622554526806,
     "parent": "c.114.0",
     "raw": [
      {
       "execution_count": 101,
       "output_type": "execute_result",
       "data": {
        "text/plain": "3"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.122",
   "versions": [
    {
     "start_checkpoint": 1622554535077,
     "parent": "c.115.0",
     "raw": [
      {
       "execution_count": 102,
       "output_type": "execute_result",
       "data": {
        "text/plain": "3"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.123",
   "versions": [
    {
     "start_checkpoint": 1622554558291,
     "parent": "c.116.0",
     "raw": [
      {
       "execution_count": 103,
       "output_type": "execute_result",
       "data": {
        "text/plain": "3"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.124",
   "versions": [
    {
     "start_checkpoint": 1622554574252,
     "parent": "c.117.0",
     "raw": [
      {
       "execution_count": 104,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=2, naechster=Element(wert=1, naechster=null))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.125",
   "versions": [
    {
     "start_checkpoint": 1622554722608,
     "parent": "c.118.0",
     "raw": [
      {
       "execution_count": 105,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=2, naechster=Element(wert=1, naechster=null))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.126",
   "versions": [
    {
     "start_checkpoint": 1622554905062,
     "parent": "c.119.0",
     "raw": [
      {
       "execution_count": 106,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=3, naechstes=null)"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.127",
   "versions": [
    {
     "start_checkpoint": 1622554928149,
     "parent": "c.122.0",
     "raw": [
      {
       "execution_count": 109,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=1, naechstes=null)"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.128",
   "versions": [
    {
     "start_checkpoint": 1622554936285,
     "parent": "c.123.0",
     "raw": [
      {
       "execution_count": 110,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=2, naechstes=null)"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.129",
   "versions": [
    {
     "start_checkpoint": 1622555013679,
     "parent": "c.124.0",
     "raw": [
      {
       "execution_count": 111,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=2, naechstes=Element(wert=1, naechstes=null))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.130",
   "versions": [
    {
     "start_checkpoint": 1622555057935,
     "parent": "c.125.0",
     "raw": [
      {
       "execution_count": 112,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=10, naechstes=Element(wert=9, naechstes=Element(wert=8, naechstes=Element(wert=7, naechstes=Element(wert=6, naechstes=Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))))))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.131",
   "versions": [
    {
     "start_checkpoint": 1622555146041,
     "parent": "c.126.0",
     "raw": [
      {
       "execution_count": 114,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=10, naechstes=Element(wert=9, naechstes=Element(wert=8, naechstes=Element(wert=7, naechstes=Element(wert=6, naechstes=Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))))))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.132",
   "versions": [
    {
     "start_checkpoint": 1622555280381,
     "parent": "c.127.0",
     "raw": [
      {
       "execution_count": 115,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=10, naechstes=Element(wert=9, naechstes=Element(wert=8, naechstes=Element(wert=7, naechstes=Element(wert=6, naechstes=Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))))))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.133",
   "versions": [
    {
     "start_checkpoint": 1622555291808,
     "parent": "c.128.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber 5\nFehler! Der Wert des zweiten Elements sollte 10 sein, ist aber 4\n",
       "output_type": "stream"
      },
      {
       "execution_count": 116,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.134",
   "versions": [
    {
     "start_checkpoint": 1622555329392,
     "parent": "c.129.0",
     "raw": [
      {
       "execution_count": 117,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.135",
   "versions": [
    {
     "start_checkpoint": 1622555376241,
     "parent": "c.130.0",
     "raw": [
      {
       "execution_count": 118,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.136",
   "versions": [
    {
     "start_checkpoint": 1622555441324,
     "parent": "c.131.0",
     "raw": [
      {
       "execution_count": 119,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.137",
   "versions": [
    {
     "start_checkpoint": 1622555549197,
     "parent": "c.134.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Das Element mit dem Wert 5 konnte nicht enfernt werden. Line_142$Liste@1948a75e\nFehler! Das Element mit dem Wert 4 konnte nicht enfernt werden. Line_142$Liste@1948a75e\nFehler! Das Element mit dem Wert 3 konnte nicht enfernt werden. Line_142$Liste@1948a75e\nFehler! Das Element mit dem Wert 2 konnte nicht enfernt werden. Line_142$Liste@1948a75e\nFehler! Das Element mit dem Wert 1 konnte nicht enfernt werden. Line_142$Liste@1948a75e\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.138",
   "versions": [
    {
     "start_checkpoint": 1622555562967,
     "parent": "c.135.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Das Element mit dem Wert 5 konnte nicht enfernt werden. Line_144$Liste@74226377\nFehler! Das Element mit dem Wert 4 konnte nicht enfernt werden. Line_144$Liste@74226377\nFehler! Das Element mit dem Wert 3 konnte nicht enfernt werden. Line_144$Liste@74226377\nFehler! Das Element mit dem Wert 2 konnte nicht enfernt werden. Line_144$Liste@74226377\nFehler! Das Element mit dem Wert 1 konnte nicht enfernt werden. Line_144$Liste@74226377\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.139",
   "versions": [
    {
     "start_checkpoint": 1622555573766,
     "parent": "c.136.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Das Element mit dem Wert 5 konnte nicht enfernt werden. Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))\nFehler! Das Element mit dem Wert 4 konnte nicht enfernt werden. Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))\nFehler! Das Element mit dem Wert 3 konnte nicht enfernt werden. Element(wert=2, naechstes=Element(wert=1, naechstes=null))\nFehler! Das Element mit dem Wert 2 konnte nicht enfernt werden. Element(wert=1, naechstes=null)\nFehler! Das Element mit dem Wert 1 konnte nicht enfernt werden. null\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.140",
   "versions": [
    {
     "start_checkpoint": 1622555585074,
     "parent": "c.137.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Das Element mit dem Wert 5 konnte nicht enfernt werden. Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))\nFehler! Das Element mit dem Wert 4 konnte nicht enfernt werden. Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))\nFehler! Das Element mit dem Wert 3 konnte nicht enfernt werden. Element(wert=2, naechstes=Element(wert=1, naechstes=null))\nFehler! Das Element mit dem Wert 2 konnte nicht enfernt werden. Element(wert=1, naechstes=null)\nFehler! Das Element mit dem Wert 1 konnte nicht enfernt werden. null\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.141",
   "versions": [
    {
     "start_checkpoint": 1622555767250,
     "parent": "c.139.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Super! Ihre Lösung hat alle Tests bestanden.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.142",
   "versions": [
    {
     "start_checkpoint": 1622557161983,
     "parent": "c.140.0",
     "raw": [
      {
       "execution_count": 136,
       "output_type": "execute_result",
       "data": {
        "text/plain": "test"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.143",
   "versions": [
    {
     "start_checkpoint": 1622557178954,
     "parent": "c.141.0",
     "raw": [
      {
       "execution_count": 139,
       "output_type": "execute_result",
       "data": {
        "text/plain": "test"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.144",
   "versions": [
    {
     "start_checkpoint": 1622557527039,
     "parent": "c.142.0",
     "raw": [
      {
       "execution_count": 143,
       "output_type": "execute_result",
       "data": {
        "text/plain": "test"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.145",
   "versions": [
    {
     "start_checkpoint": 1622557707412,
     "parent": "c.143.0",
     "raw": [
      {
       "execution_count": 146,
       "output_type": "execute_result",
       "data": {
        "text/plain": "test"
       },
       "metadata": {}
      }
     ]
    }
   ]
  }
 ]
}