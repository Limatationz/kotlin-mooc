{
 "checkpoints": [
  {
   "timestamp": 1619004012983,
   "notebook": 0,
   "targetCells": [
    {
     "cell": "m.0.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "c.0.0",
     "changeType": "added",
     "index": 1
    }
   ]
  },
  {
   "timestamp": 1619166384323,
   "notebook": 1,
   "targetCells": [
    {
     "cell": "m.1.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "c.1.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.2.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "c.2.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "m.3.0",
     "changeType": "added",
     "index": 4
    },
    {
     "cell": "c.3.0",
     "changeType": "added",
     "index": 5
    },
    {
     "cell": "m.4.0",
     "changeType": "added",
     "index": 6
    },
    {
     "cell": "c.4.0",
     "changeType": "added",
     "index": 7
    },
    {
     "cell": "m.5.0",
     "changeType": "added",
     "index": 8
    },
    {
     "cell": "c.5.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "m.6.0",
     "changeType": "added",
     "index": 10
    },
    {
     "cell": "c.6.0",
     "changeType": "added",
     "index": 11
    },
    {
     "cell": "m.7.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "c.7.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "m.8.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "c.8.0",
     "changeType": "added",
     "index": 15
    },
    {
     "cell": "m.9.0",
     "changeType": "added",
     "index": 16
    },
    {
     "cell": "c.9.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "c.10.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "m.10.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "c.11.0",
     "changeType": "added",
     "index": 20
    }
   ]
  },
  {
   "timestamp": 1619166409884,
   "notebook": 2,
   "targetCells": [
    {
     "cell": "c.1.0",
     "changeType": "output changed",
     "output": [
      "o.0.1"
     ],
     "index": 1
    },
    {
     "cell": "c.12.0",
     "changeType": "added",
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167416345,
   "notebook": 3,
   "targetCells": [
    {
     "cell": "c.12.1",
     "changeType": "edited",
     "output": [
      "o.8.0"
     ],
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167430512,
   "notebook": 4,
   "targetCells": [
    {
     "cell": "c.12.2",
     "changeType": "edited",
     "output": [],
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167469117,
   "notebook": 5,
   "targetCells": [
    {
     "cell": "c.12.2",
     "changeType": "output changed",
     "output": [
      "o.9.0"
     ],
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167519480,
   "notebook": 6,
   "targetCells": [
    {
     "cell": "c.12.3",
     "changeType": "edited",
     "output": [],
     "index": 17
    }
   ]
  },
  {
   "timestamp": 1619167525913,
   "notebook": 7,
   "targetCells": [
    {
     "cell": "c.12.4",
     "changeType": "edited",
     "output": [
      "o.10.0"
     ],
     "index": 17
    },
    {
     "cell": "m.9.1",
     "changeType": "edited",
     "index": 16
    }
   ]
  },
  {
   "timestamp": 1619273398309,
   "notebook": 8,
   "targetCells": [
    {
     "cell": "c.13.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "c.14.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "m.11.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "c.15.0",
     "changeType": "added",
     "index": 19
    },
    {
     "cell": "c.16.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "m.12.0",
     "changeType": "added",
     "index": 21
    },
    {
     "cell": "c.17.0",
     "changeType": "added",
     "index": 22
    },
    {
     "cell": "m.13.0",
     "changeType": "added",
     "index": 23
    },
    {
     "cell": "c.18.0",
     "changeType": "added",
     "index": 24
    },
    {
     "cell": "m.14.0",
     "changeType": "added",
     "index": 25
    },
    {
     "cell": "c.19.0",
     "changeType": "added",
     "index": 26
    },
    {
     "cell": "m.15.0",
     "changeType": "added",
     "index": 27
    },
    {
     "cell": "c.20.0",
     "changeType": "added",
     "index": 28
    },
    {
     "cell": "m.16.0",
     "changeType": "added",
     "index": 29
    },
    {
     "cell": "c.21.0",
     "changeType": "added",
     "index": 30
    },
    {
     "cell": "m.17.0",
     "changeType": "added",
     "index": 31
    },
    {
     "cell": "m.18.0",
     "changeType": "added",
     "index": 32
    },
    {
     "cell": "c.22.0",
     "changeType": "added",
     "index": 33
    },
    {
     "cell": "m.19.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "m.20.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "c.23.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "m.21.0",
     "changeType": "added",
     "index": 37
    },
    {
     "cell": "c.24.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "m.22.0",
     "changeType": "added",
     "index": 39
    },
    {
     "cell": "c.25.0",
     "changeType": "added",
     "index": 40
    },
    {
     "cell": "m.23.0",
     "changeType": "added",
     "index": 41
    },
    {
     "cell": "c.26.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "m.24.0",
     "changeType": "added",
     "index": 43
    },
    {
     "cell": "m.25.0",
     "changeType": "added",
     "index": 44
    },
    {
     "cell": "c.27.0",
     "changeType": "added",
     "index": 45
    },
    {
     "cell": "m.26.0",
     "changeType": "added",
     "index": 46
    },
    {
     "cell": "c.28.0",
     "changeType": "added",
     "index": 47
    },
    {
     "cell": "m.27.0",
     "changeType": "added",
     "index": 48
    },
    {
     "cell": "c.29.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "m.28.0",
     "changeType": "added",
     "index": 50
    },
    {
     "cell": "c.30.0",
     "changeType": "added",
     "index": 51
    },
    {
     "cell": "c.31.0",
     "changeType": "added",
     "index": 53
    }
   ]
  },
  {
   "timestamp": 1619273440670,
   "notebook": 9,
   "targetCells": [
    {
     "cell": "c.32.0",
     "changeType": "added",
     "index": 50
    }
   ]
  },
  {
   "timestamp": 1619273462931,
   "notebook": 10,
   "targetCells": [
    {
     "cell": "c.32.1",
     "changeType": "edited",
     "output": [
      "o.29.0"
     ],
     "index": 50
    }
   ]
  },
  {
   "timestamp": 1619344122936,
   "notebook": 11,
   "targetCells": [
    {
     "cell": "m.29.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "c.33.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "c.34.0",
     "changeType": "added",
     "index": 36
    },
    {
     "cell": "m.30.0",
     "changeType": "added",
     "index": 50
    },
    {
     "cell": "m.31.0",
     "changeType": "added",
     "index": 54
    },
    {
     "cell": "c.35.0",
     "changeType": "added",
     "index": 55
    },
    {
     "cell": "m.32.0",
     "changeType": "added",
     "index": 56
    },
    {
     "cell": "c.36.0",
     "changeType": "added",
     "index": 57
    },
    {
     "cell": "m.33.0",
     "changeType": "added",
     "index": 58
    },
    {
     "cell": "c.37.0",
     "changeType": "added",
     "index": 59
    },
    {
     "cell": "c.38.0",
     "changeType": "added",
     "index": 60
    },
    {
     "cell": "m.34.0",
     "changeType": "added",
     "index": 61
    },
    {
     "cell": "m.35.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "m.36.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "m.37.0",
     "changeType": "added",
     "index": 64
    },
    {
     "cell": "c.39.0",
     "changeType": "added",
     "index": 65
    }
   ]
  },
  {
   "timestamp": 1619344680409,
   "notebook": 12,
   "targetCells": [
    {
     "cell": "c.40.0",
     "changeType": "added",
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344804639,
   "notebook": 13,
   "targetCells": [
    {
     "cell": "c.40.1",
     "changeType": "edited",
     "output": [],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344843467,
   "notebook": 14,
   "targetCells": [
    {
     "cell": "c.40.2",
     "changeType": "edited",
     "output": [],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344920701,
   "notebook": 15,
   "targetCells": [
    {
     "cell": "c.40.3",
     "changeType": "edited",
     "output": [],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344948011,
   "notebook": 16,
   "targetCells": [
    {
     "cell": "c.40.4",
     "changeType": "edited",
     "output": [],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344965296,
   "notebook": 17,
   "targetCells": [
    {
     "cell": "c.40.5",
     "changeType": "edited",
     "output": [
      "o.35.0"
     ],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619344997121,
   "notebook": 18,
   "targetCells": [
    {
     "cell": "c.40.6",
     "changeType": "edited",
     "output": [
      "o.36.0"
     ],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619345039116,
   "notebook": 19,
   "targetCells": [
    {
     "cell": "c.40.7",
     "changeType": "edited",
     "output": [
      "o.37.0"
     ],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619345077293,
   "notebook": 20,
   "targetCells": [
    {
     "cell": "c.40.8",
     "changeType": "edited",
     "output": [
      "o.38.0"
     ],
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1619345085096,
   "notebook": 21,
   "targetCells": [
    {
     "cell": "c.40.9",
     "changeType": "edited",
     "output": [
      "o.39.0"
     ],
     "index": 62
    },
    {
     "cell": "m.34.1",
     "changeType": "edited",
     "index": 61
    },
    {
     "cell": "c.41.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "c.42.0",
     "changeType": "added",
     "index": 64
    },
    {
     "cell": "c.43.0",
     "changeType": "added",
     "index": 65
    }
   ]
  },
  {
   "timestamp": 1619427664533,
   "notebook": 22,
   "targetCells": [
    {
     "cell": "m.38.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "c.44.0",
     "changeType": "added",
     "index": 60
    },
    {
     "cell": "m.39.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "c.45.0",
     "changeType": "added",
     "index": 64
    },
    {
     "cell": "m.40.0",
     "changeType": "added",
     "index": 65
    },
    {
     "cell": "c.46.0",
     "changeType": "added",
     "index": 66
    },
    {
     "cell": "m.41.0",
     "changeType": "added",
     "index": 67
    },
    {
     "cell": "c.47.0",
     "changeType": "added",
     "index": 68
    },
    {
     "cell": "m.42.0",
     "changeType": "added",
     "index": 69
    },
    {
     "cell": "c.48.0",
     "changeType": "added",
     "index": 70
    },
    {
     "cell": "m.43.0",
     "changeType": "added",
     "index": 71
    },
    {
     "cell": "c.49.0",
     "changeType": "added",
     "index": 72
    },
    {
     "cell": "m.44.0",
     "changeType": "added",
     "index": 73
    },
    {
     "cell": "c.50.0",
     "changeType": "added",
     "index": 74
    },
    {
     "cell": "m.45.0",
     "changeType": "added",
     "index": 75
    },
    {
     "cell": "c.51.0",
     "changeType": "added",
     "index": 76
    },
    {
     "cell": "m.46.0",
     "changeType": "added",
     "index": 77
    },
    {
     "cell": "c.52.0",
     "changeType": "added",
     "index": 78
    },
    {
     "cell": "m.47.0",
     "changeType": "added",
     "index": 79
    },
    {
     "cell": "c.53.0",
     "changeType": "added",
     "index": 80
    },
    {
     "cell": "c.54.0",
     "changeType": "added",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1619427699980,
   "notebook": 23,
   "targetCells": [
    {
     "cell": "m.38.1",
     "changeType": "edited",
     "index": 0
    }
   ]
  },
  {
   "timestamp": 1619530334504,
   "notebook": 24,
   "targetCells": [
    {
     "cell": "c.55.0",
     "changeType": "added",
     "index": 60
    },
    {
     "cell": "c.56.0",
     "changeType": "added",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1622203535195,
   "notebook": 25,
   "targetCells": [
    {
     "cell": "m.48.0",
     "changeType": "added",
     "index": 2
    },
    {
     "cell": "m.49.0",
     "changeType": "added",
     "index": 18
    },
    {
     "cell": "m.50.0",
     "changeType": "added",
     "index": 34
    },
    {
     "cell": "c.57.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "m.51.0",
     "changeType": "added",
     "index": 45
    },
    {
     "cell": "c.58.0",
     "changeType": "added",
     "index": 46
    },
    {
     "cell": "c.59.0",
     "changeType": "added",
     "index": 47
    },
    {
     "cell": "c.60.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "m.52.0",
     "changeType": "added",
     "index": 71
    },
    {
     "cell": "c.61.0",
     "changeType": "added",
     "index": 72
    },
    {
     "cell": "m.53.0",
     "changeType": "added",
     "index": 83
    },
    {
     "cell": "c.62.0",
     "changeType": "added",
     "index": 84
    },
    {
     "cell": "m.54.0",
     "changeType": "added",
     "index": 85
    },
    {
     "cell": "c.63.0",
     "changeType": "added",
     "index": 86
    },
    {
     "cell": "m.55.0",
     "changeType": "added",
     "index": 87
    },
    {
     "cell": "c.64.0",
     "changeType": "added",
     "index": 88
    },
    {
     "cell": "m.56.0",
     "changeType": "added",
     "index": 89
    },
    {
     "cell": "c.65.0",
     "changeType": "added",
     "index": 90
    }
   ]
  },
  {
   "timestamp": 1622203932351,
   "notebook": 26,
   "targetCells": [
    {
     "cell": "m.38.2",
     "changeType": "edited",
     "index": 0
    }
   ]
  },
  {
   "timestamp": 1622203944610,
   "notebook": 27,
   "targetCells": [
    {
     "cell": "m.38.3",
     "changeType": "edited",
     "index": 0
    },
    {
     "cell": "c.13.1",
     "changeType": "edited",
     "output": [
      "o.53.0"
     ],
     "index": 1
    }
   ]
  },
  {
   "timestamp": 1622204008193,
   "notebook": 28,
   "targetCells": [
    {
     "cell": "c.13.2",
     "changeType": "edited",
     "output": [
      "o.54.0"
     ],
     "index": 1
    },
    {
     "cell": "m.48.1",
     "changeType": "edited",
     "index": 2
    }
   ]
  },
  {
   "timestamp": 1622204182191,
   "notebook": 29,
   "targetCells": [
    {
     "cell": "m.48.2",
     "changeType": "edited",
     "index": 2
    },
    {
     "cell": "m.3.1",
     "changeType": "edited",
     "index": 4
    },
    {
     "cell": "c.3.1",
     "changeType": "edited",
     "output": [
      "o.55.0"
     ],
     "index": 5
    }
   ]
  },
  {
   "timestamp": 1622204322287,
   "notebook": 30,
   "targetCells": [
    {
     "cell": "c.3.2",
     "changeType": "edited",
     "output": [],
     "index": 5
    },
    {
     "cell": "m.4.1",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204355567,
   "notebook": 31,
   "targetCells": [
    {
     "cell": "m.4.2",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204374734,
   "notebook": 32,
   "targetCells": [
    {
     "cell": "m.4.3",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204384000,
   "notebook": 33,
   "targetCells": [
    {
     "cell": "m.4.4",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204391516,
   "notebook": 34,
   "targetCells": [
    {
     "cell": "m.4.5",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204421079,
   "notebook": 35,
   "targetCells": [
    {
     "cell": "m.4.6",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204433050,
   "notebook": 36,
   "targetCells": [
    {
     "cell": "m.4.7",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204441673,
   "notebook": 37,
   "targetCells": [
    {
     "cell": "m.4.8",
     "changeType": "edited",
     "index": 6
    }
   ]
  },
  {
   "timestamp": 1622204457914,
   "notebook": 38,
   "targetCells": [
    {
     "cell": "m.4.9",
     "changeType": "edited",
     "index": 6
    },
    {
     "cell": "m.5.1",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1622204477080,
   "notebook": 39,
   "targetCells": [
    {
     "cell": "m.5.2",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1622204494036,
   "notebook": 40,
   "targetCells": [
    {
     "cell": "m.5.3",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1622204513712,
   "notebook": 41,
   "targetCells": [
    {
     "cell": "m.5.4",
     "changeType": "edited",
     "index": 8
    }
   ]
  },
  {
   "timestamp": 1622204534951,
   "notebook": 42,
   "targetCells": [
    {
     "cell": "m.5.5",
     "changeType": "edited",
     "index": 8
    },
    {
     "cell": "m.6.1",
     "changeType": "edited",
     "index": 10
    }
   ]
  },
  {
   "timestamp": 1622204907095,
   "notebook": 43,
   "targetCells": [
    {
     "cell": "c.7.1",
     "changeType": "edited",
     "output": [],
     "index": 13
    },
    {
     "cell": "c.8.1",
     "changeType": "edited",
     "output": [
      "o.56.0"
     ],
     "index": 15
    }
   ]
  },
  {
   "timestamp": 1622205474347,
   "notebook": 44,
   "targetCells": [
    {
     "cell": "m.9.2",
     "changeType": "edited",
     "index": 16
    },
    {
     "cell": "m.49.1",
     "changeType": "edited",
     "index": 18
    },
    {
     "cell": "m.12.1",
     "changeType": "edited",
     "index": 21
    }
   ]
  },
  {
   "timestamp": 1622205682750,
   "notebook": 45,
   "targetCells": [
    {
     "cell": "m.12.2",
     "changeType": "edited",
     "index": 21
    }
   ]
  },
  {
   "timestamp": 1622205747266,
   "notebook": 46,
   "targetCells": [
    {
     "cell": "m.12.3",
     "changeType": "edited",
     "index": 21
    }
   ]
  },
  {
   "timestamp": 1622208996780,
   "notebook": 47,
   "targetCells": [
    {
     "cell": "m.57.0",
     "changeType": "added",
     "index": 12
    },
    {
     "cell": "m.58.0",
     "changeType": "added",
     "index": 14
    },
    {
     "cell": "c.66.0",
     "changeType": "added",
     "index": 20
    },
    {
     "cell": "c.67.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "c.68.0",
     "changeType": "added",
     "index": 90
    },
    {
     "cell": "m.13.1",
     "changeType": "edited",
     "index": 23
    },
    {
     "cell": "m.14.1",
     "changeType": "edited",
     "index": 25
    }
   ]
  },
  {
   "timestamp": 1622209186075,
   "notebook": 48,
   "targetCells": [
    {
     "cell": "m.14.2",
     "changeType": "edited",
     "index": 25
    }
   ]
  },
  {
   "timestamp": 1622209235576,
   "notebook": 49,
   "targetCells": [
    {
     "cell": "m.14.3",
     "changeType": "edited",
     "index": 25
    },
    {
     "cell": "m.15.1",
     "changeType": "edited",
     "index": 27
    },
    {
     "cell": "m.16.1",
     "changeType": "edited",
     "index": 29
    }
   ]
  },
  {
   "timestamp": 1622209406266,
   "notebook": 50,
   "targetCells": [
    {
     "cell": "m.16.2",
     "changeType": "edited",
     "index": 29
    },
    {
     "cell": "c.21.1",
     "changeType": "edited",
     "output": [
      "o.58.0"
     ],
     "index": 30
    },
    {
     "cell": "m.17.1",
     "changeType": "edited",
     "index": 31
    }
   ]
  },
  {
   "timestamp": 1622209516136,
   "notebook": 51,
   "targetCells": [
    {
     "cell": "m.17.2",
     "changeType": "edited",
     "index": 31
    },
    {
     "cell": "m.18.1",
     "changeType": "edited",
     "index": 32
    }
   ]
  },
  {
   "timestamp": 1622209678258,
   "notebook": 52,
   "targetCells": [
    {
     "cell": "m.18.2",
     "changeType": "edited",
     "index": 32
    }
   ]
  },
  {
   "timestamp": 1622209719335,
   "notebook": 53,
   "targetCells": [
    {
     "cell": "m.18.3",
     "changeType": "edited",
     "index": 32
    },
    {
     "cell": "m.50.1",
     "changeType": "edited",
     "index": 34
    }
   ]
  },
  {
   "timestamp": 1622209870934,
   "notebook": 54,
   "targetCells": [
    {
     "cell": "m.50.2",
     "changeType": "edited",
     "index": 34
    },
    {
     "cell": "m.21.1",
     "changeType": "edited",
     "index": 39
    },
    {
     "cell": "c.24.1",
     "changeType": "edited",
     "output": [
      "o.59.0"
     ],
     "index": 40
    }
   ]
  },
  {
   "timestamp": 1622210144419,
   "notebook": 55,
   "targetCells": [
    {
     "cell": "c.24.2",
     "changeType": "edited",
     "output": [
      "o.60.0"
     ],
     "index": 40
    }
   ]
  },
  {
   "timestamp": 1622210151826,
   "notebook": 56,
   "targetCells": [
    {
     "cell": "c.24.3",
     "changeType": "edited",
     "output": [
      "o.61.0"
     ],
     "index": 40
    }
   ]
  },
  {
   "timestamp": 1622210205883,
   "notebook": 57,
   "targetCells": [
    {
     "cell": "c.24.4",
     "changeType": "edited",
     "output": [
      "o.62.0"
     ],
     "index": 40
    },
    {
     "cell": "m.22.1",
     "changeType": "edited",
     "index": 41
    },
    {
     "cell": "m.20.1",
     "changeType": "edited",
     "index": 37
    },
    {
     "cell": "c.25.1",
     "changeType": "edited",
     "output": [],
     "index": 42
    },
    {
     "cell": "m.23.1",
     "changeType": "edited",
     "index": 43
    }
   ]
  },
  {
   "timestamp": 1622210381391,
   "notebook": 58,
   "targetCells": [
    {
     "cell": "m.20.2",
     "changeType": "edited",
     "index": 37
    },
    {
     "cell": "m.23.2",
     "changeType": "edited",
     "index": 43
    },
    {
     "cell": "m.51.1",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210510241,
   "notebook": 59,
   "targetCells": [
    {
     "cell": "m.51.2",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210675867,
   "notebook": 60,
   "targetCells": [
    {
     "cell": "m.51.3",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210700458,
   "notebook": 61,
   "targetCells": [
    {
     "cell": "m.51.4",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210723976,
   "notebook": 62,
   "targetCells": [
    {
     "cell": "m.51.5",
     "changeType": "edited",
     "index": 45
    }
   ]
  },
  {
   "timestamp": 1622210797522,
   "notebook": 63,
   "targetCells": [
    {
     "cell": "m.51.6",
     "changeType": "edited",
     "index": 45
    },
    {
     "cell": "m.25.1",
     "changeType": "edited",
     "index": 48
    },
    {
     "cell": "m.26.1",
     "changeType": "edited",
     "index": 50
    },
    {
     "cell": "c.13.2",
     "changeType": "output changed",
     "output": [
      "o.54.1"
     ],
     "index": 1
    },
    {
     "cell": "c.3.2",
     "changeType": "output changed",
     "output": [
      "o.63.0"
     ],
     "index": 5
    },
    {
     "cell": "c.7.1",
     "changeType": "output changed",
     "output": [
      "o.64.0"
     ],
     "index": 13
    },
    {
     "cell": "c.19.0",
     "changeType": "output changed",
     "output": [
      "o.17.1"
     ],
     "index": 26
    },
    {
     "cell": "c.20.1",
     "changeType": "edited",
     "output": [],
     "index": 28
    },
    {
     "cell": "c.25.1",
     "changeType": "output changed",
     "output": [
      "o.65.0"
     ],
     "index": 42
    },
    {
     "cell": "m.30.1",
     "changeType": "edited",
     "index": 52
    }
   ]
  },
  {
   "timestamp": 1622211105740,
   "notebook": 64,
   "targetCells": [
    {
     "cell": "m.30.2",
     "changeType": "edited",
     "index": 52
    },
    {
     "cell": "m.28.1",
     "changeType": "edited",
     "index": 54
    },
    {
     "cell": "c.30.1",
     "changeType": "edited",
     "output": [
      "o.66.0"
     ],
     "index": 55
    }
   ]
  },
  {
   "timestamp": 1622285607950,
   "notebook": 65,
   "targetCells": [
    {
     "cell": "c.69.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "c.70.0",
     "changeType": "added",
     "index": 53
    },
    {
     "cell": "c.71.0",
     "changeType": "added",
     "index": 62
    },
    {
     "cell": "c.72.0",
     "changeType": "added",
     "index": 90
    },
    {
     "cell": "m.31.1",
     "changeType": "edited",
     "index": 56
    },
    {
     "cell": "c.37.0",
     "changeType": "output changed",
     "output": [
      "o.34.1"
     ],
     "index": 61
    },
    {
     "cell": "c.61.0",
     "changeType": "output changed",
     "output": [
      "o.52.1"
     ],
     "index": 72
    },
    {
     "cell": "c.62.0",
     "changeType": "output changed",
     "output": [
      "o.67.0"
     ],
     "index": 84
    },
    {
     "cell": "c.63.0",
     "changeType": "output changed",
     "output": [
      "o.68.0"
     ],
     "index": 86
    },
    {
     "cell": "c.64.0",
     "changeType": "output changed",
     "output": [
      "o.69.0"
     ],
     "index": 88
    },
    {
     "cell": "c.35.1",
     "changeType": "edited",
     "output": [
      "o.70.0"
     ],
     "index": 57
    },
    {
     "cell": "m.32.1",
     "changeType": "edited",
     "index": 58
    }
   ]
  },
  {
   "timestamp": 1622285770045,
   "notebook": 66,
   "targetCells": [
    {
     "cell": "m.32.2",
     "changeType": "edited",
     "index": 58
    }
   ]
  },
  {
   "timestamp": 1622285787057,
   "notebook": 67,
   "targetCells": [
    {
     "cell": "m.32.3",
     "changeType": "edited",
     "index": 58
    },
    {
     "cell": "m.33.1",
     "changeType": "edited",
     "index": 60
    },
    {
     "cell": "c.71.0",
     "changeType": "removed",
     "index": 62
    }
   ]
  },
  {
   "timestamp": 1622286007574,
   "notebook": 68,
   "targetCells": [
    {
     "cell": "m.34.2",
     "changeType": "edited",
     "index": 62
    },
    {
     "cell": "c.40.10",
     "changeType": "edited",
     "output": [
      "o.71.0"
     ],
     "index": 63
    }
   ]
  },
  {
   "timestamp": 1622286066819,
   "notebook": 69,
   "targetCells": [
    {
     "cell": "c.40.11",
     "changeType": "edited",
     "output": [
      "o.72.0"
     ],
     "index": 63
    },
    {
     "cell": "m.39.1",
     "changeType": "edited",
     "index": 64
    }
   ]
  },
  {
   "timestamp": 1622286097813,
   "notebook": 70,
   "targetCells": [
    {
     "cell": "m.39.2",
     "changeType": "edited",
     "index": 64
    },
    {
     "cell": "c.45.1",
     "changeType": "edited",
     "output": [
      "o.73.0"
     ],
     "index": 65
    }
   ]
  },
  {
   "timestamp": 1622286517509,
   "notebook": 71,
   "targetCells": [
    {
     "cell": "c.45.2",
     "changeType": "edited",
     "output": [],
     "index": 65
    }
   ]
  },
  {
   "timestamp": 1622286553284,
   "notebook": 72,
   "targetCells": [
    {
     "cell": "c.45.3",
     "changeType": "edited",
     "output": [
      "o.74.0"
     ],
     "index": 65
    },
    {
     "cell": "m.40.1",
     "changeType": "edited",
     "index": 66
    },
    {
     "cell": "c.46.1",
     "changeType": "edited",
     "output": [],
     "index": 67
    },
    {
     "cell": "m.41.1",
     "changeType": "edited",
     "index": 68
    }
   ]
  },
  {
   "timestamp": 1622286762980,
   "notebook": 73,
   "targetCells": [
    {
     "cell": "m.41.2",
     "changeType": "edited",
     "index": 68
    }
   ]
  },
  {
   "timestamp": 1622286789527,
   "notebook": 74,
   "targetCells": [
    {
     "cell": "m.41.3",
     "changeType": "edited",
     "index": 68
    }
   ]
  },
  {
   "timestamp": 1622286800210,
   "notebook": 75,
   "targetCells": [
    {
     "cell": "m.41.4",
     "changeType": "edited",
     "index": 68
    },
    {
     "cell": "m.52.1",
     "changeType": "edited",
     "index": 70
    }
   ]
  },
  {
   "timestamp": 1622286910420,
   "notebook": 76,
   "targetCells": [
    {
     "cell": "m.52.2",
     "changeType": "edited",
     "index": 70
    },
    {
     "cell": "c.61.1",
     "changeType": "edited",
     "output": [
      "o.75.0"
     ],
     "index": 71
    }
   ]
  },
  {
   "timestamp": 1622286961921,
   "notebook": 77,
   "targetCells": [
    {
     "cell": "c.61.2",
     "changeType": "edited",
     "output": [
      "o.76.0"
     ],
     "index": 71
    }
   ]
  },
  {
   "timestamp": 1622286964294,
   "notebook": 78,
   "targetCells": [
    {
     "cell": "c.61.2",
     "changeType": "output changed",
     "output": [
      "o.76.1"
     ],
     "index": 71
    }
   ]
  },
  {
   "timestamp": 1622287051823,
   "notebook": 79,
   "targetCells": [
    {
     "cell": "c.61.3",
     "changeType": "edited",
     "output": [
      "o.77.0"
     ],
     "index": 71
    }
   ]
  },
  {
   "timestamp": 1622289820200,
   "notebook": 80,
   "targetCells": [
    {
     "cell": "m.43.1",
     "changeType": "edited",
     "index": 72
    },
    {
     "cell": "c.49.1",
     "changeType": "edited",
     "output": [],
     "index": 73
    },
    {
     "cell": "m.44.1",
     "changeType": "edited",
     "index": 74
    }
   ]
  },
  {
   "timestamp": 1622290018952,
   "notebook": 81,
   "targetCells": [
    {
     "cell": "m.44.2",
     "changeType": "edited",
     "index": 74
    },
    {
     "cell": "m.46.1",
     "changeType": "edited",
     "index": 78
    },
    {
     "cell": "c.52.1",
     "changeType": "edited",
     "output": [],
     "index": 79
    },
    {
     "cell": "m.47.1",
     "changeType": "edited",
     "index": 80
    }
   ]
  },
  {
   "timestamp": 1622290123775,
   "notebook": 82,
   "targetCells": [
    {
     "cell": "m.47.2",
     "changeType": "edited",
     "index": 80
    },
    {
     "cell": "c.53.1",
     "changeType": "edited",
     "output": [
      "o.78.0"
     ],
     "index": 81
    }
   ]
  },
  {
   "timestamp": 1622290183581,
   "notebook": 83,
   "targetCells": [
    {
     "cell": "c.53.2",
     "changeType": "edited",
     "output": [
      "o.79.0"
     ],
     "index": 81
    }
   ]
  },
  {
   "timestamp": 1622290193733,
   "notebook": 84,
   "targetCells": [
    {
     "cell": "c.53.3",
     "changeType": "edited",
     "output": [
      "o.80.0"
     ],
     "index": 81
    }
   ]
  },
  {
   "timestamp": 1622290201805,
   "notebook": 85,
   "targetCells": [
    {
     "cell": "c.53.4",
     "changeType": "edited",
     "output": [],
     "index": 81
    }
   ]
  },
  {
   "timestamp": 1622290204256,
   "notebook": 86,
   "targetCells": [
    {
     "cell": "c.53.5",
     "changeType": "edited",
     "output": [
      "o.81.0"
     ],
     "index": 81
    },
    {
     "cell": "m.53.1",
     "changeType": "edited",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1622290261257,
   "notebook": 87,
   "targetCells": [
    {
     "cell": "m.53.2",
     "changeType": "edited",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1622290272824,
   "notebook": 88,
   "targetCells": [
    {
     "cell": "m.53.3",
     "changeType": "edited",
     "index": 82
    },
    {
     "cell": "c.62.0",
     "changeType": "output changed",
     "output": [
      "o.67.1"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290304056,
   "notebook": 89,
   "targetCells": [
    {
     "cell": "c.62.1",
     "changeType": "edited",
     "output": [
      "o.82.0"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290305955,
   "notebook": 90,
   "targetCells": [
    {
     "cell": "c.62.1",
     "changeType": "output changed",
     "output": [
      "o.82.1"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290337397,
   "notebook": 91,
   "targetCells": [
    {
     "cell": "c.62.2",
     "changeType": "edited",
     "output": [
      "o.83.0"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290370267,
   "notebook": 92,
   "targetCells": [
    {
     "cell": "c.62.3",
     "changeType": "edited",
     "output": [
      "o.84.0"
     ],
     "index": 83
    }
   ]
  },
  {
   "timestamp": 1622290408459,
   "notebook": 93,
   "targetCells": [
    {
     "cell": "c.62.4",
     "changeType": "edited",
     "output": [
      "o.85.0"
     ],
     "index": 83
    },
    {
     "cell": "m.54.1",
     "changeType": "edited",
     "index": 84
    }
   ]
  },
  {
   "timestamp": 1622290479536,
   "notebook": 94,
   "targetCells": [
    {
     "cell": "m.54.2",
     "changeType": "edited",
     "index": 84
    },
    {
     "cell": "c.63.1",
     "changeType": "edited",
     "output": [],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290541161,
   "notebook": 95,
   "targetCells": [
    {
     "cell": "c.63.1",
     "changeType": "output changed",
     "output": [
      "o.86.0"
     ],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290547559,
   "notebook": 96,
   "targetCells": [
    {
     "cell": "c.63.2",
     "changeType": "edited",
     "output": [],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290562913,
   "notebook": 97,
   "targetCells": [
    {
     "cell": "c.63.3",
     "changeType": "edited",
     "output": [
      "o.87.0"
     ],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290572241,
   "notebook": 98,
   "targetCells": [
    {
     "cell": "c.63.4",
     "changeType": "edited",
     "output": [
      "o.88.0"
     ],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290587221,
   "notebook": 99,
   "targetCells": [
    {
     "cell": "c.63.5",
     "changeType": "edited",
     "output": [
      "o.89.0"
     ],
     "index": 85
    }
   ]
  },
  {
   "timestamp": 1622290607436,
   "notebook": 100,
   "targetCells": [
    {
     "cell": "c.63.6",
     "changeType": "edited",
     "output": [],
     "index": 85
    },
    {
     "cell": "m.54.3",
     "changeType": "edited",
     "index": 84
    }
   ]
  },
  {
   "timestamp": 1622290655058,
   "notebook": 101,
   "targetCells": [
    {
     "cell": "c.63.7",
     "changeType": "edited",
     "output": [
      "o.90.0"
     ],
     "index": 85
    },
    {
     "cell": "m.55.1",
     "changeType": "edited",
     "index": 86
    }
   ]
  },
  {
   "timestamp": 1622290741126,
   "notebook": 102,
   "targetCells": [
    {
     "cell": "m.55.2",
     "changeType": "edited",
     "index": 86
    },
    {
     "cell": "m.56.1",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290867816,
   "notebook": 103,
   "targetCells": [
    {
     "cell": "m.56.2",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290882283,
   "notebook": 104,
   "targetCells": [
    {
     "cell": "m.56.3",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290897345,
   "notebook": 105,
   "targetCells": [
    {
     "cell": "m.56.4",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290907792,
   "notebook": 106,
   "targetCells": [
    {
     "cell": "m.56.5",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622290917172,
   "notebook": 107,
   "targetCells": [
    {
     "cell": "m.56.6",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622291027879,
   "notebook": 108,
   "targetCells": [
    {
     "cell": "m.56.7",
     "changeType": "edited",
     "index": 88
    },
    {
     "cell": "c.73.0",
     "changeType": "added",
     "index": 89
    }
   ]
  },
  {
   "timestamp": 1622291059093,
   "notebook": 109,
   "targetCells": [
    {
     "cell": "c.73.1",
     "changeType": "edited",
     "output": [],
     "index": 89
    }
   ]
  },
  {
   "timestamp": 1622291067351,
   "notebook": 110,
   "targetCells": [
    {
     "cell": "c.73.2",
     "changeType": "edited",
     "output": [
      "o.91.0"
     ],
     "index": 89
    }
   ]
  },
  {
   "timestamp": 1622291072276,
   "notebook": 111,
   "targetCells": [
    {
     "cell": "c.73.2",
     "changeType": "removed",
     "index": 89
    },
    {
     "cell": "m.56.8",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622291555802,
   "notebook": 112,
   "targetCells": [
    {
     "cell": "m.56.9",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622291748840,
   "notebook": 113,
   "targetCells": [
    {
     "cell": "m.56.10",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622292522022,
   "notebook": 114,
   "targetCells": [
    {
     "cell": "m.56.11",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622292705723,
   "notebook": 115,
   "targetCells": [
    {
     "cell": "m.56.12",
     "changeType": "edited",
     "index": 88
    }
   ]
  },
  {
   "timestamp": 1622312494538,
   "notebook": 116,
   "targetCells": [
    {
     "cell": "c.74.0",
     "changeType": "added",
     "index": 69
    },
    {
     "cell": "c.75.0",
     "changeType": "added",
     "index": 87
    },
    {
     "cell": "c.76.0",
     "changeType": "added",
     "index": 89
    },
    {
     "cell": "m.31.2",
     "changeType": "edited",
     "index": 56
    }
   ]
  },
  {
   "timestamp": 1622312896740,
   "notebook": 117,
   "targetCells": [
    {
     "cell": "m.53.4",
     "changeType": "edited",
     "index": 82
    }
   ]
  },
  {
   "timestamp": 1622312964703,
   "notebook": 118,
   "targetCells": [
    {
     "cell": "m.53.5",
     "changeType": "edited",
     "index": 82
    },
    {
     "cell": "m.55.3",
     "changeType": "edited",
     "index": 86
    },
    {
     "cell": "m.56.13",
     "changeType": "edited",
     "index": 88
    },
    {
     "cell": "m.38.4",
     "changeType": "edited",
     "index": 0
    }
   ]
  },
  {
   "timestamp": 1622313227273,
   "notebook": 119,
   "targetCells": [
    {
     "cell": "m.38.5",
     "changeType": "edited",
     "index": 0
    }
   ]
  },
  {
   "timestamp": 1622313230222,
   "notebook": 120,
   "targetCells": [
    {
     "cell": "m.38.6",
     "changeType": "edited",
     "index": 0
    },
    {
     "cell": "c.77.0",
     "changeType": "added",
     "index": 1
    }
   ]
  },
  {
   "timestamp": 1622445305424,
   "notebook": 121,
   "targetCells": [
    {
     "cell": "m.59.0",
     "changeType": "added",
     "index": 0
    },
    {
     "cell": "m.60.0",
     "changeType": "added",
     "index": 1
    },
    {
     "cell": "m.61.0",
     "changeType": "added",
     "index": 3
    },
    {
     "cell": "m.62.0",
     "changeType": "added",
     "index": 5
    },
    {
     "cell": "m.63.0",
     "changeType": "added",
     "index": 9
    },
    {
     "cell": "m.64.0",
     "changeType": "added",
     "index": 13
    },
    {
     "cell": "m.65.0",
     "changeType": "added",
     "index": 17
    },
    {
     "cell": "m.66.0",
     "changeType": "added",
     "index": 22
    },
    {
     "cell": "m.67.0",
     "changeType": "added",
     "index": 26
    },
    {
     "cell": "m.68.0",
     "changeType": "added",
     "index": 33
    },
    {
     "cell": "m.69.0",
     "changeType": "added",
     "index": 35
    },
    {
     "cell": "m.70.0",
     "changeType": "added",
     "index": 38
    },
    {
     "cell": "m.71.0",
     "changeType": "added",
     "index": 40
    },
    {
     "cell": "m.72.0",
     "changeType": "added",
     "index": 42
    },
    {
     "cell": "m.73.0",
     "changeType": "added",
     "index": 46
    },
    {
     "cell": "m.74.0",
     "changeType": "added",
     "index": 49
    },
    {
     "cell": "m.75.0",
     "changeType": "added",
     "index": 51
    },
    {
     "cell": "m.76.0",
     "changeType": "added",
     "index": 55
    },
    {
     "cell": "m.77.0",
     "changeType": "added",
     "index": 57
    },
    {
     "cell": "c.78.0",
     "changeType": "added",
     "index": 58
    },
    {
     "cell": "m.78.0",
     "changeType": "added",
     "index": 59
    },
    {
     "cell": "m.79.0",
     "changeType": "added",
     "index": 63
    },
    {
     "cell": "m.80.0",
     "changeType": "added",
     "index": 65
    },
    {
     "cell": "m.81.0",
     "changeType": "added",
     "index": 67
    },
    {
     "cell": "m.82.0",
     "changeType": "added",
     "index": 71
    },
    {
     "cell": "m.83.0",
     "changeType": "added",
     "index": 73
    },
    {
     "cell": "m.84.0",
     "changeType": "added",
     "index": 75
    },
    {
     "cell": "m.85.0",
     "changeType": "added",
     "index": 77
    },
    {
     "cell": "m.86.0",
     "changeType": "added",
     "index": 79
    },
    {
     "cell": "m.87.0",
     "changeType": "added",
     "index": 83
    },
    {
     "cell": "m.88.0",
     "changeType": "added",
     "index": 85
    },
    {
     "cell": "m.89.0",
     "changeType": "added",
     "index": 91
    },
    {
     "cell": "m.90.0",
     "changeType": "added",
     "index": 92
    },
    {
     "cell": "c.79.0",
     "changeType": "added",
     "index": 93
    }
   ]
  },
  {
   "timestamp": 1622445448043,
   "notebook": 122,
   "targetCells": [
    {
     "cell": "c.78.1",
     "changeType": "edited",
     "output": [
      "o.95.0"
     ],
     "index": 58
    },
    {
     "cell": "c.80.0",
     "changeType": "added",
     "index": 65
    }
   ]
  }
 ],
 "notebook": {
  "artifact_name": "n.0",
  "versions": [
   {
    "start_checkpoint": 1619004012983,
    "cells": [
     "m.0.0",
     "c.0.0"
    ]
   },
   {
    "start_checkpoint": 1619166384323,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619166409884,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.0",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167416345,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.1",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167430512,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.2",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167469117,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.2",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167519480,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.0",
     "c.12.3",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619167525913,
    "cells": [
     "m.1.0",
     "c.1.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.12.4",
     "c.9.0",
     "c.10.0",
     "m.10.0",
     "c.11.0"
    ]
   },
   {
    "start_checkpoint": 1619273398309,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.19.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.27.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.10.0",
     "c.31.0"
    ]
   },
   {
    "start_checkpoint": 1619273440670,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.19.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.27.0",
     "c.29.0",
     "c.32.0",
     "m.28.0",
     "c.30.0",
     "m.10.0",
     "c.31.0"
    ]
   },
   {
    "start_checkpoint": 1619273462931,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.19.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.27.0",
     "c.29.0",
     "c.32.1",
     "m.28.0",
     "c.30.0",
     "m.10.0",
     "c.31.0"
    ]
   },
   {
    "start_checkpoint": 1619344122936,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344680409,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.0",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344804639,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.1",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344843467,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.2",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344920701,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.3",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344948011,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.4",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344965296,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.5",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619344997121,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.6",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619345039116,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.7",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619345077293,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.0",
     "c.40.8",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619345085096,
    "cells": [
     "m.1.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.38.0",
     "m.34.1",
     "c.40.9",
     "c.41.0",
     "c.42.0",
     "c.43.0",
     "m.35.0",
     "m.36.0",
     "m.37.0",
     "c.39.0"
    ]
   },
   {
    "start_checkpoint": 1619427664533,
    "cells": [
     "m.38.0",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.44.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.42.0",
     "c.48.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.37.0",
     "c.54.0"
    ]
   },
   {
    "start_checkpoint": 1619427699980,
    "cells": [
     "m.38.1",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.44.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.42.0",
     "c.48.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.37.0",
     "c.54.0"
    ]
   },
   {
    "start_checkpoint": 1619530334504,
    "cells": [
     "m.38.1",
     "c.13.0",
     "m.2.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.11.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.29.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.23.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.24.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.55.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.42.0",
     "c.48.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.37.0",
     "c.56.0"
    ]
   },
   {
    "start_checkpoint": 1622203535195,
    "cells": [
     "m.38.1",
     "c.13.0",
     "m.48.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622203932351,
    "cells": [
     "m.38.2",
     "c.13.0",
     "m.48.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622203944610,
    "cells": [
     "m.38.3",
     "c.13.1",
     "m.48.0",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204008193,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.1",
     "c.2.0",
     "m.3.0",
     "c.3.0",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204182191,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.1",
     "m.4.0",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204322287,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.1",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204355567,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.2",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204374734,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.3",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204384000,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.4",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204391516,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.5",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204421079,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.6",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204433050,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.7",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204441673,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.8",
     "c.4.0",
     "m.5.0",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204457914,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.1",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204477080,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.2",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204494036,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.3",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204513712,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.4",
     "c.5.0",
     "m.6.0",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204534951,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.0",
     "m.8.0",
     "c.8.0",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622204907095,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.1",
     "m.8.0",
     "c.8.1",
     "m.9.1",
     "c.14.0",
     "m.49.0",
     "c.15.0",
     "c.16.0",
     "m.12.0",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622205474347,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.1",
     "m.8.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.16.0",
     "m.12.1",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622205682750,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.1",
     "m.8.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.16.0",
     "m.12.2",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622205747266,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.7.0",
     "c.7.1",
     "m.8.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.16.0",
     "m.12.3",
     "c.17.0",
     "m.13.0",
     "c.18.0",
     "m.14.0",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.60.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.65.0"
    ]
   },
   {
    "start_checkpoint": 1622208996780,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.1",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209186075,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.2",
     "c.19.0",
     "m.15.0",
     "c.20.0",
     "m.16.0",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209235576,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.1",
     "c.21.0",
     "m.17.0",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209406266,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.1",
     "m.18.0",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209516136,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.1",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209678258,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.2",
     "c.22.0",
     "m.50.0",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209719335,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.1",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.0",
     "c.24.0",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622209870934,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.1",
     "c.24.1",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210144419,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.1",
     "c.24.2",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210151826,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.0",
     "c.57.0",
     "m.21.1",
     "c.24.3",
     "m.22.0",
     "c.25.0",
     "m.23.0",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210205883,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.1",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.1",
     "c.26.0",
     "m.51.0",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210381391,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.1",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210510241,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.2",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210675867,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.3",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210700458,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.4",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210723976,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.0",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.5",
     "c.58.0",
     "c.59.0",
     "m.25.0",
     "c.27.0",
     "m.26.0",
     "c.28.0",
     "m.30.0",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622210797522,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.27.0",
     "m.26.1",
     "c.28.0",
     "m.30.1",
     "c.29.0",
     "m.28.0",
     "c.30.0",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622211105740,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.27.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.29.0",
     "m.28.1",
     "c.30.1",
     "m.31.0",
     "c.35.0",
     "m.32.0",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.67.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.68.0"
    ]
   },
   {
    "start_checkpoint": 1622285607950,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.1",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.71.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622285770045,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.2",
     "c.36.0",
     "m.33.0",
     "c.37.0",
     "c.71.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622285787057,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.1",
     "c.40.9",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286007574,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.10",
     "m.39.0",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286066819,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.1",
     "c.45.0",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286097813,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.1",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286517509,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.2",
     "m.40.0",
     "c.46.0",
     "m.41.0",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286553284,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.1",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286762980,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.2",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286789527,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.3",
     "c.47.0",
     "m.52.0",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286800210,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.1",
     "c.61.0",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286910420,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.1",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286961921,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.2",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622286964294,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.2",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622287051823,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.0",
     "c.49.0",
     "m.44.0",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622289820200,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.1",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.0",
     "c.52.0",
     "m.47.0",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290018952,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.1",
     "c.53.0",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290123775,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.1",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290183581,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.2",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290193733,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.3",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290201805,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.4",
     "m.53.0",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290204256,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.1",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290261257,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.2",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290272824,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.0",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290304056,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.1",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290305955,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.1",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290337397,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.2",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290370267,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.3",
     "m.54.0",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290408459,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.1",
     "c.63.0",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290479536,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.1",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290541161,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.1",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290547559,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.2",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290562913,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.3",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290572241,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.4",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290587221,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.2",
     "c.63.5",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290607436,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.6",
     "m.55.0",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290655058,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.1",
     "c.64.0",
     "m.56.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290741126,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.1",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290867816,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.2",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290882283,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.3",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290897345,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.4",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290907792,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.5",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622290917172,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.6",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291027879,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.7",
     "c.73.0",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291059093,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.7",
     "c.73.1",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291067351,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.7",
     "c.73.2",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291072276,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.8",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291555802,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.9",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622291748840,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.10",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622292522022,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.11",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622292705723,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.1",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.47.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.64.0",
     "m.56.12",
     "c.72.0"
    ]
   },
   {
    "start_checkpoint": 1622312494538,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.3",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.75.0",
     "m.56.12",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622312896740,
    "cells": [
     "m.38.3",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.4",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.2",
     "c.75.0",
     "m.56.12",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622312964703,
    "cells": [
     "m.38.4",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.5",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.56.13",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622313227273,
    "cells": [
     "m.38.5",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.5",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.56.13",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622313230222,
    "cells": [
     "m.38.6",
     "c.77.0",
     "c.13.2",
     "m.48.2",
     "c.2.0",
     "m.3.1",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.5.5",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.57.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.9.2",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.12.3",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.14.3",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.18.3",
     "c.22.0",
     "m.50.2",
     "c.33.0",
     "c.34.0",
     "m.20.2",
     "c.57.0",
     "m.21.1",
     "c.24.4",
     "m.22.1",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.51.6",
     "c.58.0",
     "c.59.0",
     "m.25.1",
     "c.69.0",
     "m.26.1",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.28.1",
     "c.30.1",
     "m.31.2",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.33.1",
     "c.37.0",
     "m.34.2",
     "c.40.11",
     "m.39.2",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.41.4",
     "c.74.0",
     "m.52.2",
     "c.61.3",
     "m.43.1",
     "c.49.1",
     "m.44.2",
     "c.50.0",
     "m.45.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.47.2",
     "c.53.5",
     "m.53.5",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.56.13",
     "c.76.0"
    ]
   },
   {
    "start_checkpoint": 1622445305424,
    "cells": [
     "m.59.0",
     "m.60.0",
     "c.13.2",
     "m.61.0",
     "c.2.0",
     "m.62.0",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.63.0",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.64.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.65.0",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.66.0",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.67.0",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.68.0",
     "c.22.0",
     "m.69.0",
     "c.33.0",
     "c.34.0",
     "m.70.0",
     "c.57.0",
     "m.71.0",
     "c.24.4",
     "m.72.0",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.73.0",
     "c.58.0",
     "c.59.0",
     "m.74.0",
     "c.69.0",
     "m.75.0",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.76.0",
     "c.30.1",
     "m.77.0",
     "c.78.0",
     "m.78.0",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.79.0",
     "c.37.0",
     "m.80.0",
     "c.40.11",
     "m.81.0",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.82.0",
     "c.74.0",
     "m.83.0",
     "c.61.3",
     "m.84.0",
     "c.49.1",
     "m.85.0",
     "c.50.0",
     "m.86.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.87.0",
     "c.53.5",
     "m.88.0",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.89.0",
     "m.90.0",
     "c.79.0"
    ]
   },
   {
    "start_checkpoint": 1622445448043,
    "cells": [
     "m.59.0",
     "m.60.0",
     "c.13.2",
     "m.61.0",
     "c.2.0",
     "m.62.0",
     "c.3.2",
     "m.4.9",
     "c.4.0",
     "m.63.0",
     "c.5.0",
     "m.6.1",
     "c.6.0",
     "m.64.0",
     "c.7.1",
     "m.58.0",
     "c.8.1",
     "m.65.0",
     "c.14.0",
     "m.49.1",
     "c.15.0",
     "c.66.0",
     "m.66.0",
     "c.17.0",
     "m.13.1",
     "c.18.0",
     "m.67.0",
     "c.19.0",
     "m.15.1",
     "c.20.1",
     "m.16.2",
     "c.21.1",
     "m.17.2",
     "m.68.0",
     "c.22.0",
     "m.69.0",
     "c.33.0",
     "c.34.0",
     "m.70.0",
     "c.57.0",
     "m.71.0",
     "c.24.4",
     "m.72.0",
     "c.25.1",
     "m.23.2",
     "c.26.0",
     "m.73.0",
     "c.58.0",
     "c.59.0",
     "m.74.0",
     "c.69.0",
     "m.75.0",
     "c.28.0",
     "m.30.2",
     "c.70.0",
     "m.76.0",
     "c.30.1",
     "m.77.0",
     "c.78.1",
     "m.78.0",
     "c.35.1",
     "m.32.3",
     "c.36.0",
     "m.79.0",
     "c.37.0",
     "c.80.0",
     "m.80.0",
     "c.40.11",
     "m.81.0",
     "c.45.3",
     "m.40.1",
     "c.46.1",
     "m.82.0",
     "c.74.0",
     "m.83.0",
     "c.61.3",
     "m.84.0",
     "c.49.1",
     "m.85.0",
     "c.50.0",
     "m.86.0",
     "c.51.0",
     "m.46.1",
     "c.52.1",
     "m.87.0",
     "c.53.5",
     "m.88.0",
     "c.62.4",
     "m.54.3",
     "c.63.7",
     "m.55.3",
     "c.75.0",
     "m.89.0",
     "m.90.0",
     "c.79.0"
    ]
   }
  ]
 },
 "codeCells": [
  {
   "output_histories": {},
   "artifact_name": "c.0",
   "versions": [
    {
     "start_checkpoint": 1619004012983,
     "parent": "n.0.0",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.0"
   },
   "artifact_name": "c.1",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "literal": "class Person (val name: String, var alter: Int)\n\nval p1 = Person(\"Max Mustermann\", 21)\nprintln(\"Person 1, $p1: \\nName: ${p1.name}, Alter: ${p1.alter}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 63
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.1"
   },
   "artifact_name": "c.2",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.121",
     "literal": "class Auto (\n    val marke: String, //Es wird ein Feld mit dem Namen marke und ein Getter hinzugefgt und bei Erzeugung mit dem bergebenen Wert gefllt.\n    var farbe: String, //Es wird ein Feld mit dem Namen farbe und einem Getter sowie Setter hinzugefgt und bei Erzeugung mit dem bergebenen Wert gefllt.\n    ps: Int //Dies ist lediglich ein bergabeparameter, der im Konstruktor verwendet werden kann.\n)\n\nval a1 = Auto (\"BMW\", \"Gelb\", 220)\nprintln(\"Marke von a1: ${a1.marke}, Farbe von a1: ${a1.farbe}.\") //Benutzung der Getter von marke und farbe\n//println(a1.ps) -> Error, da ps kein Feld sondern nur ein bergabeparameter ist\n//a1.marke = \"Audi\" -> Error, da das Feld marke nicht verndert werden kann und auch keinen Setter besitzt\na1.farbe = \"Rot\" //Aufruf des Setters von farbe. Das Feld farbe kann verndert werden, da ein Setter vorhanden ist und das Feld den Typ var besitzt\nprintln(\"Farbe von a1 nach Umlackierung: ${a1.farbe}.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 54
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.2",
    "1": "o.55",
    "2": "o.63"
   },
   "artifact_name": "c.3",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "literal": "class Computer (){\n    val marke: String = \"Fuhitsu\"\n    var istAn: Boolean = false\n}\n\nval c1 = Computer ()\nprintln(\"Marke von c1: ${c1.marke}, ist c1 an?: ${c1.istAn}.\") //Benutzung der Getter von marke und istAn\n// c1.marke = \"LD\" -> Error, da das Feld marke nicht verndert werden kann und auch keinen Setter besitzt\nc1.istAn = true //Aufruf des Setters von istAn. Das Feld istAn kann verndert werden, da ein Setter vorhanden ist und das Feld den Typ var besitzt\nprintln(\"ist c1 an?: ${c1.istAn}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 33
     }
    },
    {
     "start_checkpoint": 1622204182191,
     "parent": "n.0.29",
     "literal": "class Computer (){\n    val marke: String = \"Fuhitsu\"\n    var istAn: Boolean = false\n}\n\nval c1 = Computer ()\nprintln(\"Marke von c1: ${c1.marke}, ist c1 an?: ${c1.istAn}.\") //Benutzung der Getter von marke und istAn\n// c1.marke = \"LD\" -> Error, da das Feld marke nicht verndert werden kann und auch keinen Setter besitzt\nc1.istAn = true //Aufruf des Setters von istAn. Das Feld istAn kann verndert werden, da ein Setter vorhanden ist und das Feld den Typ var besitzt\nprintln(\"Ist c1 an?: ${c1.istAn}\")"
    },
    {
     "start_checkpoint": 1622204322287,
     "parent": "n.0.121",
     "literal": "class Computer (){\n    val marke: String = \"Fuhitsu\"\n    var istAn: Boolean = false\n}\n\nval c1 = Computer ()\nprintln(\"Marke von c1: ${c1.marke}, ist c1 an?: ${c1.istAn}.\") //Benutzung der Getter von marke und istAn\n//c1.marke = \"LD\" -> Error, da das Feld marke nicht verndert werden kann und keinen Setter besitzt\nc1.istAn = true //Aufruf des Setters von istAn. Das Feld istAn kann verndert werden, da ein Setter vorhanden und das Feld vom Typ var ist\nprintln(\"Ist c1 an?: ${c1.istAn}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.3"
   },
   "artifact_name": "c.4",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.121",
     "literal": "class Flasche (val farbe: String, var fllung: Int)\nval f1 = Flasche (\"Grau\", 20)\nprintln(\"Die Flasche mit der Farbe ${f1.farbe} ist zu ${f1.fllung}% gefllt.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 78
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.4"
   },
   "artifact_name": "c.5",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.121",
     "literal": "class Bett (\n    laenge: Int, breite: Int, belegt: Boolean //bergabeparameter bei Objekterzeugung. Knnen im init-Block verwendet werden.\n){\n    val laenge: Int\n    val breite: Int\n    var belegt: Boolean\n    \n    init { //primrer Konstruktor mit init-Block. In diesem kann auf die Parameter zugegriffen werden.\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.belegt = belegt\n    }\n}\nval b1 = Bett (160, 200, false)\nval b2 = Bett (-100, 50, true)\nprintln(\"Bett b1: Lnge ${b1.laenge}, Breite ${b1.breite}, belegt ${b1.belegt}\")\nprintln(\"Bett b2: Lnge ${b2.laenge}, Breite ${b2.breite}, belegt ${b2.belegt}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 16,
      "ch": 79
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.5"
   },
   "artifact_name": "c.6",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.121",
     "literal": "class Tisch (\n    laenge: Int, breite: Int, farbe: String //bergabeparameter bei Objekterzeugung. Knnen den Feldern direkt zugewiesen werden.\n){\n    val laenge: Int = if (laenge > 0) laenge else 0\n    val breite = if (breite > 0) breite else 0 //Kurzschreibweise ist zulssig. Dabei wird der Datentyp des Parameters bernommen\n    var farbe: String = farbe\n}\n\nval t1 = Tisch (100, 100, \"Braun\")\nval t2 = Tisch (-100, 50, \"Wei\")\nprintln(\"Tisch t1: Lnge ${t1.laenge}, Breite ${t1.breite}, Farbe ${t1.farbe}\")\nprintln(\"Tisch t2: Lnge ${t2.laenge}, Breite ${t2.breite}, Farbe ${t2.farbe}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 78
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.6",
    "1": "o.64"
   },
   "artifact_name": "c.7",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "literal": "class Stuhl (laenge: Int, breite: Int, var belegt: Boolean){\n    val laenge = if (laenge > 0) laenge else 0\n    val breite: Int\n    \n    init {\n        this.breite = if (breite > 0) breite else 0\n    }\n}\nval s1 = Stuhl (20, 20, true)\nval s2 = Stuhl (-20, 30, false)\nprintln(\"Stuhl s1: Lnge ${s1.laenge}, Breite ${s1.breite}, belegt ${s1.belegt}\")\nprintln(\"Stuhl s2: Lnge ${s2.laenge}, Breite ${s2.breite}, belegt ${s2.belegt}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 80
     }
    },
    {
     "start_checkpoint": 1622204907095,
     "parent": "n.0.121",
     "literal": "class Stuhl (laenge: Int, breite: Int, var belegt: Boolean){ //belegt: Defaultkonstruktor\n    val laenge = if (laenge > 0) laenge else 0 //laenge: direkte Zuweisung\n    val breite: Int\n\n    init { //breite: init-Block\n        this.breite = if (breite > 0) breite else 0\n    }\n}\n\nval s1 = Stuhl (20, 20, true)\nval s2 = Stuhl (-20, 30, false)\nprintln(\"Stuhl s1: Lnge ${s1.laenge}, Breite ${s1.breite}, belegt ${s1.belegt}\")\nprintln(\"Stuhl s2: Lnge ${s2.laenge}, Breite ${s2.breite}, belegt ${s2.belegt}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.7",
    "1": "o.56"
   },
   "artifact_name": "c.8",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "literal": "class Fenster { //Parameterklammern fehlen\n    val laenge: Int\n    val breite: Int\n    var zustand: String\n    \n    //Konstruktor eines normalen Fensters\n    constructor (laenge: Int, breite: Int, zustand: String){\n        println(\"Konstruktor eines normalen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.zustand = zustand\n    }\n    //Konstruktor eines quadratischen Fensters\n    constructor (laenge: Int, zustand: String){\n        println(\"Konstruktor eines quadratischen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = laenge\n        this.zustand = zustand\n    }\n    //Konstruktor eines neuen Fensters\n    constructor (laenge: Int, breite: Int){\n        println(\"Konstruktor eines neuen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.zustand = \"Neu\"\n    }\n}\n\nval fensterNormal = Fenster (50, -80, \"Gebraucht\")\nprintln(\"Fenster fensterNormal: Lnge ${fensterNormal.laenge}, Breite ${fensterNormal.breite}, Zustand ${fensterNormal.zustand} \\n\")\nval fensterQuadrat = Fenster (60, \"Schmutzig\")\nprintln(\"Fenster fensterQuadrat: Lnge ${fensterQuadrat.laenge}, Breite ${fensterQuadrat.breite}, Zustand ${fensterQuadrat.zustand} \\n\")\nval fensterNeu = Fenster (100, 120)\nprintln(\"Fenster fensterNeu: Lnge ${fensterNeu.laenge}, Breite ${fensterNeu.breite}, Zustand ${fensterNeu.zustand}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 33,
      "ch": 116
     }
    },
    {
     "start_checkpoint": 1622204907095,
     "parent": "n.0.121",
     "literal": "class Fenster { //Parameterklammern fehlen\n    val laenge: Int\n    val breite: Int\n    var zustand: String\n    \n    //Konstruktor eines normalen Fensters\n    constructor (laenge: Int, breite: Int, zustand: String){\n        println(\"Konstruktion eines normalen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.zustand = zustand\n    }\n    //Konstruktor eines quadratischen Fensters\n    constructor (laenge: Int, zustand: String){\n        println(\"Konstruktion eines quadratischen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = laenge\n        this.zustand = zustand\n    }\n    //Konstruktor eines neuen Fensters\n    constructor (laenge: Int, breite: Int){\n        println(\"Konstruktion eines neuen Fensters\")\n        this.laenge = if (laenge > 0) laenge else 0\n        this.breite = if (breite > 0) breite else 0\n        this.zustand = \"Neu\"\n    }\n}\n\nval fensterNormal = Fenster (50, -80, \"Gebraucht\")\nprintln(\"Fenster fensterNormal: Lnge ${fensterNormal.laenge}, Breite ${fensterNormal.breite}, Zustand ${fensterNormal.zustand} \\n\")\nval fensterQuadrat = Fenster (60, \"Schmutzig\")\nprintln(\"Fenster fensterQuadrat: Lnge ${fensterQuadrat.laenge}, Breite ${fensterQuadrat.breite}, Zustand ${fensterQuadrat.zustand} \\n\")\nval fensterNeu = Fenster (100, 120)\nprintln(\"Fenster fensterNeu: Lnge ${fensterNeu.laenge}, Breite ${fensterNeu.breite}, Zustand ${fensterNeu.zustand}\")"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.9",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.10",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.11",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "1": "o.8",
    "2": "o.9",
    "4": "o.10"
   },
   "artifact_name": "c.12",
   "versions": [
    {
     "start_checkpoint": 1619166409884,
     "parent": "n.0.2",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1619167416345,
     "parent": "n.0.3",
     "literal": "//primrer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundrer Konstruktor: Neue Batterie mit Angabe von Kapazitt und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\")\n    //sekundrer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false, 0, \"Neu\")\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\")\nprintln(\"Batterie eigeneBatterie: Kapazitt ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}\")\nval neueBatterie = Batterie(3000, false)\nprintln(\"Batterie neueBatterie: Kapazitt ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}\")\nval BBBatterie = Batterie()\nprintln(\"Batterie BBBatterie: Kapazitt ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}\")"
    },
    {
     "start_checkpoint": 1619167430512,
     "parent": "n.0.4",
     "literal": "//primrer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundrer Konstruktor: Neue Batterie mit Angabe von Kapazitt und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\")\n    //sekundrer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false)\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\")\nprintln(\"Batterie eigeneBatterie: Kapazitt ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}\")\nval neueBatterie = Batterie(3000, false)\nprintln(\"Batterie neueBatterie: Kapazitt ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}\")\nval BBBatterie = Batterie()\nprintln(\"Batterie BBBatterie: Kapazitt ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}\")"
    },
    {
     "start_checkpoint": 1619167519480,
     "parent": "n.0.6",
     "literal": "//primrer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundrer Konstruktor: Neue Batterie mit Angabe von Kapazitt und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\") //Benutzt den primren Konstruktor\n    //sekundrer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false) //Benutzt den anderen sekundren Konstruktor\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\") //primrer Konstruktor\nprintln(\"Batterie eigeneBatterie: Kapazitt ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}\")\nval neueBatterie = Batterie(3000, false) //sekundrer Konstruktor: Neue Batterie mit Angabe von Kapazitt und Wiederaufladbarkeit\nprintln(\"Batterie neueBatterie: Kapazitt ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}\")\nval BBBatterie = Batterie() //sekundrer Konstruktor: Neue BB Einmalbatterie\nprintln(\"Batterie BBBatterie: Kapazitt ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}\")"
    },
    {
     "start_checkpoint": 1619167525913,
     "parent": "n.0.7",
     "literal": "//primrer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundrer Konstruktor: Neue Batterie mit Angabe von Kapazitt und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\") //Benutzt den primren Konstruktor\n    //sekundrer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false) //Benutzt den anderen sekundren Konstruktor\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\") //primrer Konstruktor\nprintln(\"Batterie eigeneBatterie: Kapazitt ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}.\")\nval neueBatterie = Batterie(3000, false) //sekundrer Konstruktor: Neue Batterie mit Angabe von Kapazitt und Wiederaufladbarkeit\nprintln(\"Batterie neueBatterie: Kapazitt ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}.\")\nval BBBatterie = Batterie() //sekundrer Konstruktor: Neue BB Einmalbatterie\nprintln(\"Batterie BBBatterie: Kapazitt ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}.\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.11",
    "1": "o.53",
    "2": "o.54"
   },
   "artifact_name": "c.13",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.25",
     "literal": "class Person (val name: String, var alter: Int)\n\nval p1 = Person(\"Max Mustermann\", 21)\nprintln(\"Person p1, $p1: \\nName: ${p1.name}, Alter: ${p1.alter}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 64
     }
    },
    {
     "start_checkpoint": 1622203944610,
     "parent": "n.0.27",
     "literal": "class Person (val name: String, var alter: Int)\n\nval p1 = Person(\"Max Mustermann\", 21)\nprintln(\"Person p1: $p1\\nName: ${p1.name}, Alter: ${p1.alter}\")"
    },
    {
     "start_checkpoint": 1622204008193,
     "parent": "n.0.121",
     "literal": "class Person (val name: String, var alter: Int)\n\nval p1 = Person(\"Max Mustermann\", 21)\nprintln(\"Person p1: $p1\")\nprintln(\"Name: ${p1.name}, Alter: ${p1.alter}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.12"
   },
   "artifact_name": "c.14",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "//primrer Konstruktor: Defaultkonstruktor\nclass Batterie (val kapazitaet: Int, val wiederaufladbar: Boolean, var ladezyklen: Int, val status: String){\n    //sekundrer Konstruktor: Neue Batterie mit Angabe von Kapazitt und Wiederaufladbarkeit\n    constructor (kapazitaet: Int, wiederaufladbar: Boolean) : this(kapazitaet, wiederaufladbar, 0, \"Neu\") //Benutzt den primren Konstruktor\n    //sekundrer Konstruktor: Neue BB Einmalbatterie\n    constructor () : this(2400, false) //Benutzt den anderen sekundren Konstruktor\n}\nval eigeneBatterie = Batterie(2000, true, 42, \"Gebraucht\") //primrer Konstruktor\nprintln(\"Batterie eigeneBatterie: Kapazitt ${eigeneBatterie.kapazitaet}, Wiederaufladbar ${eigeneBatterie.wiederaufladbar}, Ladezyklen ${eigeneBatterie.ladezyklen}, Status ${eigeneBatterie.status}\")\nval neueBatterie = Batterie(3000, false) //sekundrer Konstruktor: Neue Batterie mit Angabe von Kapazitt und Wiederaufladbarkeit\nprintln(\"Batterie neueBatterie: Kapazitt ${neueBatterie.kapazitaet}, Wiederaufladbar ${neueBatterie.wiederaufladbar}, Ladezyklen ${neueBatterie.ladezyklen}, Status ${neueBatterie.status}\")\nval BBBatterie = Batterie() //sekundrer Konstruktor: Neue BB Einmalbatterie\nprintln(\"Batterie BBBatterie: Kapazitt ${BBBatterie.kapazitaet}, Wiederaufladbar ${BBBatterie.wiederaufladbar}, Ladezyklen ${BBBatterie.ladezyklen}, Status ${BBBatterie.status}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 178
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.13"
   },
   "artifact_name": "c.15",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "//TODO\n\n//Tests\nvar fehler = 0\nval test1 = Pizza(25, listOf(\"Schinken\"), false)\nif( test1.groee != 25 || test1.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test1.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 1! Richtig wre: Gre 25, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test1.groee}, Belge ${test1.belaege}, Geschnitten ${test1.geschnitten}\")\n}\nval test2 = Pizza(31, listOf(\"Schinken\"), false)\nif( test2.groee != -1 || test2.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test2.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 2! Richtig wre: Gre -1, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test2.groee}, Belge ${test2.belaege}, Geschnitten ${test2.geschnitten}\")\n}\nval test3 = Pizza(14, listOf(\"Schinken\"), false)\nif( test3.groee != -1 || test3.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test3.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 3! Richtig wre: Gre -1, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test3.groee}, Belge ${test3.belaege}, Geschnitten ${test3.geschnitten}\")\n}\nval test4 = Pizza(31, listOf(\"Schinken\"), false)\nif( test4.groee != -1 || test4.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test4.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 4! Richtig wre: Gre -1, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test4.groee}, Belge ${test4.belaege}, Geschnitten ${test4.geschnitten}\")\n}\nval test5 = Pizza(28, emptyList(), true)\nif( test5.groee != 28 || test5.belaege != listOf(\"Tomatensoe\", \"Mozzarella\") || test5.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 5! Richtig wre: Gre 28, Belge [Tomatensoe, Mozzarella], Geschnitten true \\n  Ist: Gre ${test5.groee}, Belge ${test5.belaege}, Geschnitten ${test5.geschnitten}\")\n}\nval test6 = Pizza(15)\nif( test6.groee != 15 || test6.belaege != listOf(\"Tomatensoe\", \"Mozzarella\") || test6.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 6! Richtig wre: Gre 15, Belge [Tomatensoe, Mozzarella], Geschnitten true \\n  Ist: Gre ${test6.groee}, Belge ${test6.belaege}, Geschnitten ${test6.geschnitten}\")\n}\nval test7 = Pizza()\nif( test7.groee != 25 || test7.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Thunfisch\", \"Zwiebeln\", \"Peperoni\") || test7.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 7! Richtig wre: Gre 25, Belge [Tomatensoe, Mozzarella, Thunfisch, Zwiebeln, Peperoni], Geschnitten false \\n  Ist: Gre ${test7.groee}, Belge ${test7.belaege}, Geschnitten ${test7.geschnitten}\")\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 42,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.14"
   },
   "artifact_name": "c.16",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.25",
     "literal": "//Lsung\nclass Pizza (groee: Int, belaege: List<String>, geschnitten: Boolean){\n    val groee: Int\n    val belaege: MutableList<String>\n    val geschnitten: Boolean\n    \n    init {\n        this.groee = if (15 <= groee && groee <= 30) groee else -1\n        this.belaege = mutableListOf(\"Tomatensoe\", \"Mozzarella\")\n        this.belaege += belaege\n        this.geschnitten = geschnitten\n    }\n    \n    constructor (groee: Int) : this(groee, emptyList(), true)\n    constructor () : this(25, listOf(\"Thunfisch\", \"Zwiebeln\", \"Peperoni\"), true)\n}\n\n//Tests\nvar fehler = 0\nval test1 = Pizza(25, listOf(\"Schinken\"), false)\nif( test1.groee != 25 || test1.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test1.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 1! Richtig wre: Gre 25, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test1.groee}, Belge ${test1.belaege}, Geschnitten ${test1.geschnitten}\")\n}\nval test2 = Pizza(31, listOf(\"Schinken\"), false)\nif( test2.groee != -1 || test2.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test2.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 2! Richtig wre: Gre -1, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test2.groee}, Belge ${test2.belaege}, Geschnitten ${test2.geschnitten}\")\n}\nval test3 = Pizza(14, listOf(\"Schinken\"), false)\nif( test3.groee != -1 || test3.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test3.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 3! Richtig wre: Gre -1, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test3.groee}, Belge ${test3.belaege}, Geschnitten ${test3.geschnitten}\")\n}\nval test4 = Pizza(31, listOf(\"Schinken\"), false)\nif( test4.groee != -1 || test4.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test4.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 4! Richtig wre: Gre -1, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test4.groee}, Belge ${test4.belaege}, Geschnitten ${test4.geschnitten}\")\n}\nval test5 = Pizza(28, emptyList(), true)\nif( test5.groee != 28 || test5.belaege != listOf(\"Tomatensoe\", \"Mozzarella\") || test5.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 5! Richtig wre: Gre 28, Belge [Tomatensoe, Mozzarella], Geschnitten true \\n  Ist: Gre ${test5.groee}, Belge ${test5.belaege}, Geschnitten ${test5.geschnitten}\")\n}\nval test6 = Pizza(15)\nif( test6.groee != 15 || test6.belaege != listOf(\"Tomatensoe\", \"Mozzarella\") || test6.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 6! Richtig wre: Gre 15, Belge [Tomatensoe, Mozzarella], Geschnitten true \\n  Ist: Gre ${test6.groee}, Belge ${test6.belaege}, Geschnitten ${test6.geschnitten}\")\n}\nval test7 = Pizza()\nif( test7.groee != 25 || test7.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Thunfisch\", \"Zwiebeln\", \"Peperoni\") || test7.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 7! Richtig wre: Gre 25, Belge [Tomatensoe, Mozzarella, Thunfisch, Zwiebeln, Peperoni], Geschnitten false \\n  Ist: Gre ${test7.groee}, Belge ${test7.belaege}, Geschnitten ${test7.geschnitten}\")\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 57,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.15"
   },
   "artifact_name": "c.17",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name: String = name\n        get() = \"Name: $field\" //Wird auf das Feld name zugegeriffen, wird der String \"Name: name\" zurckgegeben\n        //Kein Setter mglich, da val\n    var alter = if (alter > 0) alter else -1\n        get() = field //Standardgetter\n        set(value){ //Eigener Setter. Der neue Wert wird in value gespeichert\n            field = if (value > field) value else field //Das Feld wird auf den neuen Wert gesetzt, falls dieser grer als der Aktuelle ist.\n        }\n}\nval p1 = Person (\"Max Mustermann\", -10)\nprintln(\"Person p1: ${p1.name}, Alter ${p1.alter}\")\np1.alter = 21\nprintln(\"Person p1: ${p1.name}, Alter ${p1.alter}\")\np1.alter = -10\nprintln(\"Person p1: ${p1.name}, Alter ${p1.alter}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 15,
      "ch": 50
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.16"
   },
   "artifact_name": "c.18",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name: String = name\n        get() = \"Name: $field\" //Wird auf das Feld name zugegeriffen, wird der String \"Name: name\" zurckgegeben\n        //Kein Setter mglich, da val\n    var alter = if (alter > 0) alter else -1\n        get() = field //Standardgetter\n        set(value){ //Eigener Setter. Der neue Wert wird in value gespeichert\n            field = if (value > field) value else field //Das Feld wird auf den neuen Wert gesetzt, falls dieser grer als der Aktuelle ist.\n        }\n    val istVolljaerig //Datentyp Boolean aus dem Getter\n        get() = alter > 17\n}\nval p1 = Person (\"Max Mustermann\", 21)\nprintln(\"Person p1: ${p1.name}, Alter ${p1.alter}, Volljhrig ${p1.istVolljaerig}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 13,
      "ch": 82
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.17"
   },
   "artifact_name": "c.19",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    val istVolljaehrig: Boolean by lazy {\n        println(\"Wird berechnet...\")\n        alter > 18\n    }\n}\nval p1 = Person(\"Erika Musterfrau\", 32)\nprintln(p1.istVolljaehrig)\nprintln(p1.istVolljaehrig)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 10,
      "ch": 25
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.18"
   },
   "artifact_name": "c.20",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    lateinit var istVolljaehrig: String\n    \n    fun berechneIstVolljaehrig(){\n        istVolljaehrig = if (alter > 17) \"Volljhrig\" else \"Nicht Volljhrig\"\n    }\n}\nval p1 = Person (\"Max Mustermann\", 30)\n//println(p1.istVolljaehrig) //Error: UninitializedPropertyAccessException: lateinit property istVolljaehrig has not been initialized\np1.berechneIstVolljaehrig() //istVolljaehrig wird berechnet\nprintln(p1.istVolljaehrig)",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 25
     }
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    lateinit var istVolljaehrig: String //istVolljaehrig wird nicht bei Objekterzeugung berechnet\n    \n    fun berechneIstVolljaehrig() { //Diese Methode berechnet den Wert des Feldes istVolljaehrig\n        istVolljaehrig = if (alter > 17) \"Volljhrig\" else \"Nicht Volljhrig\"\n    }\n}\nval p1 = Person (\"Max Mustermann\", 30)\n//println(p1.istVolljaehrig) -> Fehler: UninitializedPropertyAccessException: lateinit property istVolljaehrig has not been initialized\np1.berechneIstVolljaehrig() //istVolljaehrig wird berechnet\nprintln(p1.istVolljaehrig)"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.19",
    "1": "o.58"
   },
   "artifact_name": "c.21",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    lateinit var istVolljaehrig: String\n    \n    fun berechneIstVolljaehrig(){\n        istVolljaehrig = if (alter > 17) \"Volljhrig\" else \"Nicht Volljhrig\"\n    }\n    fun istInitialisiert() = this::istVolljaehrig.isInitialized\n}\n\nval p1 = Person (\"Max Mustermann\", 30)\nprintln(p1.istInitialisiert())\np1.berechneIstVolljaehrig() //istVolljaehrig wird berechnet\nprintln(p1.istInitialisiert())",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 29
     }
    },
    {
     "start_checkpoint": 1622209406266,
     "parent": "n.0.121",
     "literal": "public class Person (name: String, alter: Int){\n    val name = name\n    var alter = alter\n    lateinit var istVolljaehrig: String\n    \n    fun berechneIstVolljaehrig(){\n        istVolljaehrig = if (alter > 17) \"Volljhrig\" else \"Nicht Volljhrig\"\n    }\n    fun istInitialisiert() = this::istVolljaehrig.isInitialized\n}\n\nval p1 = Person (\"Max Mustermann\", 30)\nprintln(\"Versuch 1: ${p1.istInitialisiert()}\")\np1.berechneIstVolljaehrig() //istVolljaehrig wird berechnet\nprintln(\"Versuch 2: ${p1.istInitialisiert()}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.20"
   },
   "artifact_name": "c.22",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "class Person(val name: String, var alter: Int){\n    fun hatGeburtstag() = alter++ //Objektmethode\n    override fun toString() = \"$name ist $alter Jahre alt.\" //Objektmethode die die Methode toString() berschreibt\n}\n\nval p1 = Person(\"Max Mustermann\", 30)\nprintln(\"Vor Geburtstag: $p1\")\np1.hatGeburtstag()\nprintln(\"Nach Geburtstag: $p1\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 30
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.21"
   },
   "artifact_name": "c.23",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.24",
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int)\nval p1 = Punkt (0,0,0)\nprintln(\"Punkt p1: $p1\") //Verwendung der automatisch generierten toString()-Methode\nval p2 = Punkt (1,1,1)\nif (p1 == p2) //Verwendung der automatisch generierten equals()-Methode\n    println(\"p1 und p2 sind gleich.\")\nelse\n    println(\"p1 und p2 sind ungleich.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 38
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.22",
    "1": "o.59",
    "2": "o.60",
    "3": "o.61",
    "4": "o.62"
   },
   "artifact_name": "c.24",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "val p1 = Punkt (0,1,2)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y, z) = p1\nprintln(\"x: $x, y: $y, z: $z\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 29
     }
    },
    {
     "start_checkpoint": 1622209870934,
     "parent": "n.0.54",
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int, val a: Int)\nval p1 = Punkt (0,1,2, 3)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y, z, a) = p1\nprintln(\"x: $x, y: $y, z: $z, $a\")"
    },
    {
     "start_checkpoint": 1622210144419,
     "parent": "n.0.55",
     "literal": "val p1 = Punkt (0,1,2)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y, z) = p1\nprintln(\"x: $x, y: $y, z: $z\")"
    },
    {
     "start_checkpoint": 1622210151826,
     "parent": "n.0.56",
     "literal": "val p1 = Punkt (0,1,2)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y) = p1\nprintln(\"x: $x, y: $y, z: z\")"
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.121",
     "literal": "val p1 = Punkt (0,1,2)\nprintln(\"p1.component1(): ${p1.component1()}\")\nval (x, y, z) = p1 //speichert die ersten drei Felder von p1 in den Variablen x, y, z\nprintln(\"x: $x, y: $y, z: $z\")\nval (a, b) = p1 //speichert die ersten zwei Felder von p1 in den Variablen a, b\nprintln(\"a: $a, b: $b\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.23",
    "1": "o.65"
   },
   "artifact_name": "c.25",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "val p1 = Punkt (0,1,2)\nval p2 = p1.copy()\nprintln(\"p1: $p1\")\nprintln(\"p2: $p2\")\nval p3 = p1.copy(x=4)\nprintln(\"p3: $p3\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 17
     }
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.121",
     "literal": "val p1 = Punkt (0,1,2)\nval p2 = p1.copy() //p1 und p2 sind unabhngige Objekte\nprintln(\"p1: $p1\")\nprintln(\"p2: $p2\")\nval p3 = p1.copy(x=4)\nprintln(\"p3: $p3\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.24"
   },
   "artifact_name": "c.26",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "data class Punkt (val x: Int, val y: Int, val z: Int){\n    val istUrsprung = x == 0 && y == 0 && z == 0\n}\nval p1 = Punkt (0,0,0)\nprintln(\"Punkt p1 ist im Ursprung: ${p1.istUrsprung}, $p1\")\nval p2 = Punkt (1,1,1)\nprintln(\"Punkt p2 ist im Ursprung: ${p2.istUrsprung}, $p2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 58
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.25"
   },
   "artifact_name": "c.27",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "private val satz = object {\n    val subjekt = \"Kotlin\"\n    val praedikat = \"ist\"\n    val objekt = \"Programmiersprache\"\n    val vollstaendig = \"Kotlin ist eine Programmiersprache\"\n}\n\nprintln(\"Das Subjekt des Satzes ${satz.vollstaendig} ist ${satz.subjekt} \")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 74
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.26"
   },
   "artifact_name": "c.28",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.121",
     "literal": "object Rechner {\n    val zahl: Int\n    init {\n        println(\"Singleton Rechner wurde erzeugt.\")\n        zahl = (0..10).random()\n    }\n    \n    fun addieren(a: Int, b: Int) = a + b\n}\n\nval a = 5\nval b = 10\nprintln(\"Berechnung ohne Singleton: ${a+b}\")\nprintln(\"Berechnung mit Singleton: ${Rechner.addieren(a,b)}\")\nprintln(\"Zufallszahl des Singletons: ${Rechner.zahl}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 53
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.27"
   },
   "artifact_name": "c.29",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "class Student(val name: String, var alter: Int){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    \n    var matrikelnummer: Int\n    \n    init {\n        matrikelnummer = zaehler\n    }\n}\n\nval s1 = Student (\"Max\", 21)\nval s2 = Student (\"Anna\", 25)\nval s3 = Student (\"Simon\", 26)\nval s4 = Student (\"Sophie\", 19)\nprintln(\"Die Marikelnummer von ${s1.name} ist ${s1.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s2.name} ist ${s2.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s3.name} ist ${s3.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s4.name} ist ${s4.matrikelnummer}.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 20,
      "ch": 68
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.28",
    "1": "o.66"
   },
   "artifact_name": "c.30",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "literal": "import java.time.LocalTime\n\nclass Zahlen(){\n    companion object {\n        var nummer = 1\n            get() = field\n    }\n    object Zwei {\n        var nummer = 2\n    }\n    object Drei {\n        var nummer = 3\n    }\n    object Zeit {\n        fun gibZeit() = LocalTime.now()\n    }\n}\n\nprintln(\"Die Nummer des Standard Companion Objects ist ${Zahlen.nummer}.\")\nprintln(\"Die Nummer des Companion Objects Zwei ist ${Zahlen.Zwei.nummer}.\")\nprintln(\"Die Nummer des Companion Objects Drei ist ${Zahlen.Drei.nummer}.\")\nprintln(\"Es ist aktuell ${Zahlen.Zeit.gibZeit()} Uhr.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 21,
      "ch": 54
     }
    },
    {
     "start_checkpoint": 1622211105740,
     "parent": "n.0.121",
     "literal": "import java.time.LocalTime\n\nclass Zahlen(){\n    companion object {\n        var nummer = 1\n            get() = field\n    }\n    object Zwei {\n        var nummer = 2\n    }\n    object Drei {\n        var nummer = 3\n    }\n    object Zeit {\n        fun gibZeit() = LocalTime.now()\n    }\n}\n\nprintln(\"Die Nummer des Standard Companion Objects ist ${Zahlen.nummer}.\")\nprintln(\"Die Nummer des Companion Objects Zwei ist ${Zahlen.Zwei.nummer}.\")\nprintln(\"Die Nummer des Companion Objects Drei ist ${Zahlen.Drei.nummer}.\")\nprintln(\"Es ist aktuell ${Zahlen.Zeit.gibZeit()} Uhr.\")\n\nval zwei = Zahlen()\n//println(zwei.Zwei.nummer) -> Fehler: Nested object 'Zwei' accessed via instance reference"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.31",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.8",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "1": "o.29"
   },
   "artifact_name": "c.32",
   "versions": [
    {
     "start_checkpoint": 1619273440670,
     "parent": "n.0.9",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1619273462931,
     "parent": "n.0.10",
     "literal": "var zaehler = 0\n\nclass Student(val name: String, var alter: Int){\n    \n    var matrikelnummer: Int\n    \n    init {\n        matrikelnummer = zaehler++\n    }\n}\n\nval s1 = Student (\"Max\", 21)\nval s2 = Student (\"Anna\", 25)\nval s3 = Student (\"Simon\", 26)\nval s4 = Student (\"Sophie\", 19)\nprintln(\"Die Marikelnummer von ${s1.name} ist ${s1.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s2.name} ist ${s2.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s3.name} ist ${s3.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s4.name} ist ${s4.matrikelnummer}.\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.30"
   },
   "artifact_name": "c.33",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.121",
     "literal": "//TODO\n\n//Test\nvar fehler = 0\nval p1 = Parkplatzverwaltung(mutableListOf(true, true, false, false, true))\nif (p1.toString() != \"xx--x\"){\n    println(\"Fehler! p1 sollte eigentlich 'xx--x' sein, ist jedoch '$p1'\")\n    fehler++\n}\nif (!p1.einparken(3)){\n    println(\"Fehler! Parkplatz Nummer 3 sollte eigentlich belegt werden knnen. Parkplatz: $p1\")\n    fehler++\n}\nif (p1.einparken(3)){\n    println(\"Fehler! Parkplatz Nummer 3 sollte eigentlich nicht belegt werden knnen. Parkplatz: $p1\")\n    fehler++\n}\nif (p1.toString() != \"xx-xx\"){\n    println(\"Fehler! p1 sollte eigentlich 'xx--x' sein, ist jedoch '$p1'\")\n    fehler++\n}\nval p2 = Parkplatzverwaltung()\nif (p2.toString() != \"-----\"){\n    println(\"Fehler! p2 sollte eigentlich '-----' sein, ist jedoch '$p2'\")\n    fehler++\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 29,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.31"
   },
   "artifact_name": "c.34",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.121",
     "literal": "//Lsung\nclass Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Boolean {\n        return if (!parkplatz[nummer]) {\n            parkplatz[nummer] = true\n            true\n        }\n        else {\n            false\n        }\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval p1 = Parkplatzverwaltung(mutableListOf(true, true, false, false, true))\nif (p1.toString() != \"xx--x\"){\n    println(\"Fehler! p1 sollte eigentlich 'xx--x' sein, ist jedoch '$p1'\")\n    fehler++\n}\nif (!p1.einparken(3)){\n    println(\"Fehler! Parkplatz Nummer 3 sollte eigentlich belegt werden knnen. Parkplatz: $p1\")\n    fehler++\n}\nif (p1.einparken(3)){\n    println(\"Fehler! Parkplatz Nummer 3 sollte eigentlich nicht belegt werden knnen. Parkplatz: $p1\")\n    fehler++\n}\nif (p1.toString() != \"xx-xx\"){\n    println(\"Fehler! p1 sollte eigentlich 'xx--x' sein, ist jedoch '$p1'\")\n    fehler++\n}\nval p2 = Parkplatzverwaltung()\nif (p2.toString() != \"-----\"){\n    println(\"Fehler! p2 sollte eigentlich '-----' sein, ist jedoch '$p2'\")\n    fehler++\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 52,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.32",
    "1": "o.70"
   },
   "artifact_name": "c.35",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.65",
     "literal": "enum class Wochentag {\n    MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG, SAMSTAG, SONNTAG\n}\n\nclass Tag (val name : Wochentag)\n\nval montag = Tag(Wochentag.MONTAG)\nprintln(\"Der Name von montag ist ${montag.name}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 48
     }
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.121",
     "literal": "enum class Wochentag {\n    MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG, SAMSTAG, SONNTAG\n}\n\nclass Tag (val name : Wochentag)\n\nval montag = Tag(Wochentag.MONTAG)\nprintln(\"Der Name von montag ist ${montag.name}.\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.33"
   },
   "artifact_name": "c.36",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.121",
     "literal": "print(\"Alle Eintrge des Enums: \")\nWochentag.values().forEach { \n    print(\"$it, \")\n}\n\nprintln()\nprintln(\"Vollstndiger Name von FREITAG: ${Wochentag.valueOf(\"FREITAG\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 73
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.34"
   },
   "artifact_name": "c.37",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.121",
     "literal": "enum class Wochentag (val nummer: Int){\n    MONTAG(1), DIENSTAG(2), MITTWOCH(3), DONNERSTAG(4), FREITAG(5), SAMSTAG(6), SONNTAG(7);\n    \n    val zufallszahl = (0..10).random()\n    \n    fun istWochenende() = if (this == SAMSTAG || this == SONNTAG) true else false\n}\n\nval montag = Wochentag.MONTAG\nprintln(\"Montag ist ein Tag des Wochenendes: ${montag.istWochenende()}, Nummer des Tags: ${montag.nummer}, Zufallszahl: ${montag.zufallszahl}\")\nval samstag = Wochentag.SAMSTAG\nprintln(\"Samstag ist ein Tag des Wochenendes: ${samstag.istWochenende()}, Nummer des Tags: ${samstag.nummer}, Zufallszahl: ${montag.zufallszahl}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 11,
      "ch": 145
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.38",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.39",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "5": "o.35",
    "6": "o.36",
    "7": "o.37",
    "8": "o.38",
    "9": "o.39",
    "10": "o.71",
    "11": "o.72"
   },
   "artifact_name": "c.40",
   "versions": [
    {
     "start_checkpoint": 1619344680409,
     "parent": "n.0.12",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1619344804639,
     "parent": "n.0.13",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}"
    },
    {
     "start_checkpoint": 1619344843467,
     "parent": "n.0.14",
     "literal": "open class Person(val name: String, var alter: Int){\n    fun wasBinIch() = println(\"Ich bin eine Person\")\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}"
    },
    {
     "start_checkpoint": 1619344920701,
     "parent": "n.0.15",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}"
    },
    {
     "start_checkpoint": 1619344948011,
     "parent": "n.0.16",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)"
    },
    {
     "start_checkpoint": 1619344965296,
     "parent": "n.0.17",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1619344997121,
     "parent": "n.0.18",
     "literal": "open class Person(val name: String, var alter: Int)\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: ${p1.toString()}\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1619345039116,
     "parent": "n.0.19",
     "literal": "open class Person(val name: String, var alter: Int){\n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1619345077293,
     "parent": "n.0.20",
     "literal": "open class Person(val name: String, var alter: Int){\n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override fun toString() = \"Ich bin $name, bin $alter Jahre alt und besitze die Matrikelnummer matrikelnummer.\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.65",
     "literal": "open class Person(val name: String, var alter: Int){\n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override fun toString() = \"Ich bin $name, bin $alter Jahre alt und besitze die Matrikelnummer $matrikelnummer.\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1622286007574,
     "parent": "n.0.68",
     "literal": "open class Person(val name: String, var alter: Int) { //Super-Klasse\n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){ //Sub-Klasse, die von Person erbt\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und besitze die Matrikelnummer $matrikelnummer.\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1622286066819,
     "parent": "n.0.121",
     "literal": "open class Person(val name: String, var alter: Int) { //Super-Klasse\n    override fun toString() = \"Mein Name ist $name und ich bin $alter Jahre alt.\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){ //Sub-Klasse, die von Person erbt\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und besitze die Matrikelnummer $matrikelnummer.\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.41",
   "versions": [
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.21",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.42",
   "versions": [
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.21",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.43",
   "versions": [
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.21",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.44",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.22",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.40",
    "1": "o.73",
    "3": "o.74"
   },
   "artifact_name": "c.45",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "open class Person(val name: String, var alter: Int){\n    open val schlachtruf\n        get() = \"Fr die Horde!\"\n    \n    open fun hatGeburtstag() {\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter++\n    } \n    override fun toString() = \"Ich bin $name und bin $alter Jahre alt. $schlachtruf\"\n}\n\nclass Student(name: String, alter: Int) : Person (name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override val schlachtruf\n        get() = \"Fr die Allianz!\"\n    \n    override fun hatGeburtstag() {\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter--\n    } \n    \n    override fun toString() = \"Ich bin $name, bin $alter Jahre alt und habe die Matrikelnummer $matrikelnummer. $schlachtruf Oder vielleicht doch: ${super.schlachtruf}?\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\np1.hatGeburtstag()\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")\ns1.hatGeburtstag()\nprintln(\"s1: $s1\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 36,
      "ch": 17
     }
    },
    {
     "start_checkpoint": 1622286097813,
     "parent": "n.0.70",
     "literal": "open class Person(val name: String, var alter: Int){\n    open val schlachtruf\n        get() = \"Fr die Horde!\"\n    \n    open fun hatGeburtstag() {\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter++\n    } \n    override fun toString() = \"Mein Name ist $name und ich bin $alter Jahre alt. $schlachtruf\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override val schlachtruf\n        get() = \"Fr die Allianz!\"\n    \n    override fun hatGeburtstag() {\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter--\n    } \n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und habe die Matrikelnummer $matrikelnummer. $schlachtruf Oder vielleicht doch: ${super.schlachtruf}?\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\np1.hatGeburtstag()\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")\ns1.hatGeburtstag()\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1622286517509,
     "parent": "n.0.71",
     "literal": "open class Person(val name: String, var alter: Int){\n    open val schlachtruf //Dieses Feld kann von den Sub-Klassen berschrieben werden\n        get() = \"Fr die Horde!\"\n    \n    open fun hatGeburtstag() { //Diese Methode kann von den Sub-Klassen berschrieben werden\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter++\n    } \n    override fun toString() = \"Mein Name ist $name und ich bin $alter Jahre alt. $schlachtruf\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override val schlachtruf\n        get() = \"Fr die Allianz!\"\n    \n    override fun hatGeburtstag() { //berschreibt die Methode hatGeburtstag der Super-Klasse\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter--\n    } \n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und habe die Matrikelnummer $matrikelnummer. $schlachtruf Oder vielleicht doch: ${super.schlachtruf}?\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\np1.hatGeburtstag()\nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")\ns1.hatGeburtstag()\nprintln(\"s1: $s1\")"
    },
    {
     "start_checkpoint": 1622286553284,
     "parent": "n.0.121",
     "literal": "open class Person(val name: String, var alter: Int){\n    open val schlachtruf //Dieses Feld kann von den Sub-Klassen berschrieben werden\n        get() = \"Fr die Horde!\"\n    \n    open fun hatGeburtstag() { //Diese Methode kann von den Sub-Klassen berschrieben werden\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter++\n    } \n    override fun toString() = \"Mein Name ist $name und ich bin $alter Jahre alt. $schlachtruf\"\n}\n\nclass Student(name: String, alter: Int) : Person(name, alter){\n    companion object {\n        var zaehler = 0\n            get() = field++\n    }\n    val matrikelnummer = zaehler\n    \n    override val schlachtruf\n        get() = \"Fr die Allianz!\"\n    \n    override fun hatGeburtstag() { //berschreibt die Methode hatGeburtstag der Super-Klasse\n        println(\"$name hat Geburtstag. Alles Gute!\")\n        alter--\n    } \n    \n    override fun toString() = \"Mein Name ist $name, ich bin $alter Jahre alt und habe die Matrikelnummer $matrikelnummer. $schlachtruf Oder vielleicht doch: ${super.schlachtruf}?\"\n}\n\nval p1 = Person (\"Max Mustermann\", 25)\nval s1 = Student (\"Erika Mustermann\", 21)\nprintln(\"p1: $p1\")\np1.hatGeburtstag() //Ruft hatGeburtstag() von der Klasse Person auf \nprintln(\"p1: $p1\")\nprintln(\"s1: $s1\")\ns1.hatGeburtstag() //Ruft hatGeburtstag() von der Klasse Student auf \nprintln(\"s1: $s1\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.41"
   },
   "artifact_name": "c.46",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "open class Punkt2D (val x: Int, val y: Int){\n    override fun toString() = \"x: $x, y: $y\"\n}\n\nclass Punkt3D : Punkt2D{\n    val z: Int\n    \n    //sekundre Konstruktoren\n    constructor (x: Int, y: Int, z: Int) : super (x, y) {\n        this.z = z\n    }\n    constructor () : super (0, 0) {\n        this.z = 0\n    }\n    \n    override fun toString() = \"${super.toString()}, z: $z\"\n}\n\nval p1 = Punkt3D (4, 2, 8)\nprintln(\"Punkt p1: $p1\")\nval p2 = Punkt3D()\nprintln(\"Punkt p2: $p2\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 21,
      "ch": 23
     }
    },
    {
     "start_checkpoint": 1622286553284,
     "parent": "n.0.121",
     "literal": "open class Punkt2D (val x: Int, val y: Int){\n    override fun toString() = \"x: $x, y: $y\"\n}\n\nclass Punkt3D : Punkt2D { //Aufruf des primren Konstruktors von Punkt2D fehlt hier\n    val z: Int\n    \n    //sekundre Konstruktoren rufen den primren Defaultkonstruktor von Punkt2D auf\n    constructor (x: Int, y: Int, z: Int) : super (x, y) {\n        this.z = z\n    }\n    constructor () : super (0, 0) {\n        this.z = 0\n    }\n    \n    override fun toString() = \"${super.toString()}, z: $z\"\n}\n\nval p1 = Punkt3D (4, 2, 8)\nprintln(\"Punkt p1: $p1\")\nval p2 = Punkt3D()\nprintln(\"Punkt p2: $p2\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.42"
   },
   "artifact_name": "c.47",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "abstract class Computer (val kerne: Int, val farbe: String){\n    var istAn = false\n    abstract fun einschalten()\n}\n\nclass Laptop (kerne: Int, farbe: String, val hatTouchscreen: Boolean) : Computer(kerne, farbe){\n    var istAufgeklappt = false\n    override fun einschalten() {\n        if (!istAufgeklappt) \n            istAufgeklappt = true\n        istAn = true\n        println(\"Laptop wurde eingeschalten.\")\n    }\n}\n\nclass Standcomputer (kerne: Int, farbe: String) : Computer(kerne, farbe){\n    override fun einschalten() {\n        istAn = true\n        println(\"Standcomputer wurde eingeschalten.\")\n    }\n}\n\n//val c1 = Computer (8, \"Schwarz\") -> Error: Cannot create an instance of an abstract class\nval l1 = Laptop(6, \"Rot\", false)\nl1.einschalten()\nval s1 = Standcomputer(12, \"Wei\")\ns1.einschalten()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 26,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.43"
   },
   "artifact_name": "c.48",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.24",
     "literal": "//Kotlin Fehelr??\n\nsealed class Fehler\ndata class Laufzeitfehler(val f: Int) : Fehler()\ndata class Kompilierfehler() : Fehler()\ndata class Referenzfehler() : Fehler()\n\nval f1 = Kompilierfehler()\n\nwhen (f1){\n    is Laufzeitfehler -> println(\"Es ist ein Laufzeitfehler aufgetreten.\")\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler aufgetreten.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 13,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.44"
   },
   "artifact_name": "c.49",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "interface Addition {\n    val dieZahl: Int\n    \n    fun add2(a: Int, b: Int): Int\n    fun add3(a: Int, b: Int, c: Int) = a + b + c\n}\n\nclass Rechner : Addition {\n    override val dieZahl = 42\n    override fun add2(a: Int, b: Int) = a + b\n}\n\nval rechner = Rechner()\nprintln(\"rechner.dieZahl: ${rechner.dieZahl}\")\nprintln(\"rechner.add2(5,3): ${rechner.add2(5,3)}\")\nprintln(\"rechner.add3(5,9,3): ${rechner.add3(5,9,3)}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 15,
      "ch": 53
     }
    },
    {
     "start_checkpoint": 1622289820200,
     "parent": "n.0.121",
     "literal": "interface Addition {\n    val dieZahl: Int //Feld, das in den Klassen berschrieben und gefllt werden muss\n    \n    fun add2(a: Int, b: Int): Int //Methode muss in den Klassen ausformuliert werden\n    fun add3(a: Int, b: Int, c: Int) = a + b + c //Bereits voll implementierte Methode, die bernommen wird\n}\n\nclass Rechner : Addition {\n    override val dieZahl = 42 //berschreibt das vorgegebene Feld dieZahl\n    override fun add2(a: Int, b: Int) = a + b //berschreibt die vorgegebene Methode add3\n}\n\nval rechner = Rechner()\nprintln(\"rechner.dieZahl: ${rechner.dieZahl}\")\nprintln(\"rechner.add2(5,3): ${rechner.add2(5,3)}\")\nprintln(\"rechner.add3(5,9,3): ${rechner.add3(5,9,3)}\")"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.45"
   },
   "artifact_name": "c.50",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.121",
     "literal": "data class Speicher<T> (var platz1: T, var platz2: T, var platz3: T)\n\nval s1 = Speicher(1,2,3)\nval s2 = Speicher(listOf(1,2,3),listOf(1,2,3),listOf(1,2,3))\nval s3 = Speicher(\"Kotlin\",\"Java\",\"C\")\nprintln(\"s1: $s1\")\nprintln(\"s2: $s2\")\nprintln(\"s3: $s3\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 17
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.46"
   },
   "artifact_name": "c.51",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.121",
     "literal": "class Gleichheitstest<T: Comparable<T>>{\n    fun istGleich(a: T, b: T) = if(a.compareTo(b) == 0) true else false\n}\nval gleichheitstestInt = Gleichheitstest<Int>()\nprintln(\"gleichheitstestInt.istGleich(3,3): ${gleichheitstestInt.istGleich(3,3)}\")\nprintln(\"gleichheitstestInt.istGleich(10,3): ${gleichheitstestInt.istGleich(10,3)}\")\nval gleichheitstestString = Gleichheitstest<String>()\nprintln(\"gleichheitstestString.istGleich('Kotlin','Kotlin'): ${gleichheitstestString.istGleich(\"Kotlin\",\"Kotlin\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 115
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.47"
   },
   "artifact_name": "c.52",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "fun <T: Comparable<T>> istGleich(a: T, b: T) = if(a.compareTo(b) == 0) true else false\nprintln(\"istGleich(3,3): ${istGleich(3,3)}\")\nprintln(\"istGleich('Kotlin','Kotlin'): ${istGleich(\"Kotlin\",\"Kotlin\")}\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 2,
      "ch": 71
     }
    },
    {
     "start_checkpoint": 1622290018952,
     "parent": "n.0.121",
     "literal": "fun <T: Comparable<T>> istGleich(a: T, b: T) = if(a.compareTo(b) == 0) true else false\nprintln(\"istGleich(3,3): ${istGleich(3,3)}\") //T ist Int\nprintln(\"istGleich('Kotlin','Kotlin'): ${istGleich(\"Kotlin\",\"Kotlin\")}\") //T ist String"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.48",
    "1": "o.78",
    "2": "o.79",
    "3": "o.80",
    "5": "o.81"
   },
   "artifact_name": "c.53",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste = mutableListOf(3,6,1,8,10)\nprintln(\"Entferntes Element: ${liste.entferneMinimum()}\")\nprintln(\"liste: $liste\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 13,
      "ch": 23
     }
    },
    {
     "start_checkpoint": 1622290123775,
     "parent": "n.0.82",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Int\nprintln(\"Entferntes Element: ${liste2.entferneMinimum()}\")\nprintln(\"listew: $liste2\")"
    },
    {
     "start_checkpoint": 1622290183581,
     "parent": "n.0.83",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Int\nprintln(\"Entferntes Element: ${liste2.entferneMinimum()}\")\nprintln(\"liste2: $liste2\")"
    },
    {
     "start_checkpoint": 1622290193733,
     "parent": "n.0.84",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element von liste1: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Int\nprintln(\"Entferntes Element von liste2: ${liste2.entferneMinimum()}\")\nprintln(\"liste2: $liste2\")"
    },
    {
     "start_checkpoint": 1622290201805,
     "parent": "n.0.85",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element von liste1: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Char\nprintln(\"Entferntes Element von liste2: ${liste2.entferneMinimum()}\")\nprintln(\"liste2: $liste2\")"
    },
    {
     "start_checkpoint": 1622290204256,
     "parent": "n.0.121",
     "literal": "fun <T: Comparable<T>> MutableList<T>.entferneMinimum(): T?{\n    val min = minOrNull()\n    return if (min != null){\n        remove(min)\n        min\n    }\n    else {\n        null\n    }\n}\n\nval liste1 = mutableListOf(3,6,1,8,10) //T ist Int\nprintln(\"Entferntes Element von liste1: ${liste1.entferneMinimum()}\")\nprintln(\"listeq: $liste\")\nval liste2 = mutableListOf('f', 'w', 'e', 't', 'q') //T ist Character\nprintln(\"Entferntes Element von liste2: ${liste2.entferneMinimum()}\")\nprintln(\"liste2: $liste2\")"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.54",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.22",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.55",
   "versions": [
    {
     "start_checkpoint": 1619530334504,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.56",
   "versions": [
    {
     "start_checkpoint": 1619530334504,
     "parent": "n.0.24",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.49"
   },
   "artifact_name": "c.57",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.121",
     "literal": "data class Punkt(val x: Int, val y: Int, val z: Int)\nval p1 = Punkt (0,0,0)\nprintln(\"Punkt p1: $p1\") //Verwendung der automatisch generierten toString()-Methode\nval p2 = Punkt (1,1,1)\nprintln(\"Punkt p2: $p2\")\nif (p1 == p2) //Verwendung der automatisch generierten equals()-Methode\n    println(\"p1 und p2 sind gleich.\")\nelse\n    println(\"p1 und p2 sind ungleich.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 38
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.50"
   },
   "artifact_name": "c.58",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.121",
     "literal": "//TODO\n\nval abstaende = mutableListOf<Abstand>() //Liste von Abstnden\n\n//Test\nval positionen1 = listOf(Position(2,7), Position(0,0), Position(5,2), Position(7,2))\nval positionen2 = listOf(Position(4,4), Position(10,2), Position(1,6), Position(3,4))\nfor(p1 in positionen1){\n    for(p2 in positionen2){\n        berechneAbstand(p1, p2)\n    }\n}\nabstaende.sortBy {it.wert}\nvar fehler = 0\nif(abstaende.toString() != \"[Abstand(wert=2), Abstand(wert=3), Abstand(wert=4), Abstand(wert=5), Abstand(wert=6), Abstand(wert=7), Abstand(wert=8), Abstand(wert=10), Abstand(wert=12), Abstand(wert=13)]\"){\n    println(\"Fehler! Es sollten folgende Abstnde in der Liste vorhanden sein:\\n\\t[Abstand(wert=2), Abstand(wert=3), Abstand(wert=4), Abstand(wert=5), Abstand(wert=6), Abstand(wert=7), Abstand(wert=8), Abstand(wert=10), Abstand(wert=12), Abstand(wert=13)]\\nIn der Liste ist aber aktuell:\\n\\t$abstaende\")\n    fehler++\n}\nval richtigeAnzahl = listOf(1,2,2,3,1,2,2,1,1,1)\nfor(i in 0 until abstaende.size){\n    if(abstaende[i].positionen.size != richtigeAnzahl[i]){\n        println(\"Fehler bei Element Nummer $i in abstaende!\\n\\tDer Abstand ${abstaende[i]} sollte eigentlich ${richtigeAnzahl[i]} Eintrge in der Liste positionen besitzen, es ist/sind aber ${abstaende[i].positionen.size} Eintrag/Eintrge.\")\n        fehler++\n    }\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 28,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.51"
   },
   "artifact_name": "c.59",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.121",
     "literal": "//Lsung\n\ndata class Position (val x: Int, val y: Int)\ndata class Abstand (val wert: Int){\n    val positionen = mutableListOf<Pair<Position, Position>>()\n}\n\nfun berechneAbstand(p1: Position, p2: Position) {\n    val abstand = Abstand((p1.x - p2.x).absoluteValue + (p1.y - p2.y).absoluteValue)\n    abstand.positionen.add(Pair(p1, p2))\n    if (abstand in abstaende)\n        abstaende.find { it == abstand }?.positionen?.add(Pair(p1, p2))\n    else\n        abstaende.add(abstand)\n}\n\nval abstaende = mutableListOf<Abstand>() //Liste von Abstnden\n\n//Test\nval positionen1 = listOf(Position(2,7), Position(0,0), Position(5,2), Position(7,2))\nval positionen2 = listOf(Position(4,4), Position(10,2), Position(1,6), Position(3,4))\nfor(p1 in positionen1){\n    for(p2 in positionen2){\n        berechneAbstand(p1, p2)\n    }\n}\nabstaende.sortBy {it.wert}\nvar fehler = 0\nif(abstaende.toString() != \"[Abstand(wert=2), Abstand(wert=3), Abstand(wert=4), Abstand(wert=5), Abstand(wert=6), Abstand(wert=7), Abstand(wert=8), Abstand(wert=10), Abstand(wert=12), Abstand(wert=13)]\"){\n    println(\"Fehler! Es sollten folgende Abstnde in der Liste vorhanden sein:\\n\\t[Abstand(wert=2), Abstand(wert=3), Abstand(wert=4), Abstand(wert=5), Abstand(wert=6), Abstand(wert=7), Abstand(wert=8), Abstand(wert=10), Abstand(wert=12), Abstand(wert=13)]\\nIn der Liste ist aber aktuell:\\n\\t$abstaende\")\n    fehler++\n}\nval richtigeAnzahl = listOf(1,2,2,3,1,2,2,1,1,1)\nfor(i in 0 until abstaende.size){\n    if(abstaende[i].positionen.size != richtigeAnzahl[i]){\n        println(\"Fehler bei Element Nummer $i in abstaende!\\n\\tDer Abstand ${abstaende[i]} sollte eigentlich ${richtigeAnzahl[i]} Eintrge in der Liste positionen besitzen, es ist/sind aber ${abstaende[i].positionen.size} Eintrag/Eintrge.\")\n        fehler++\n    }\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 42,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.60",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.52",
    "1": "o.75",
    "2": "o.76",
    "3": "o.77"
   },
   "artifact_name": "c.61",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "literal": "//Kotlin Fehelr??\n\nsealed class Fehler\ndata class Laufzeitfehler(val f: Int) : Fehler()\ndata class Kompilierfehler(val s: String) : Fehler()\ndata class Referenzfehler(val s: String) : Fehler()\n\nval zufall = (0..2).random()\nval f1 = if(zufall == 1)\n                Laufzeitfehler(2)\n            else if(zufall == 2)\n                Kompilierfehler(\"adf\")\n            else\n                Referenzfehler(\"wkf\")\n\nwhen (f1){\n    is Laufzeitfehler -> println(\"Es ist ein Laufzeitfehler aufgetreten.\")\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler aufgetreten.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 19,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1622286910420,
     "parent": "n.0.76",
     "literal": "sealed class Fehler\ndata class Laufzeitfehler(val f: Int) : Fehler()\ndata class Kompilierfehler(val s: String) : Fehler()\ndata class Referenzfehler(val s: String) : Fehler()\n\nval zufall = (0..2).random()\nval f1 = if(zufall == 1)\n                Laufzeitfehler(2)\n            else if(zufall == 2)\n                Kompilierfehler(\"adf\")\n            else\n                Referenzfehler(\"wkf\")\n\nwhen (f1){\n    is Laufzeitfehler -> println(\"Es ist ein Laufzeitfehler aufgetreten.\")\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler aufgetreten.\")\n}"
    },
    {
     "start_checkpoint": 1622286961921,
     "parent": "n.0.77",
     "literal": "sealed class Fehler\ndata class Laufzeitfehler(val f: Int) : Fehler()\ndata class Kompilierfehler(val s: String) : Fehler()\ndata class Referenzfehler(val s: String) : Fehler()\n\nval zufall = (0..2).random()\nval f1 = if(zufall == 1)\n                Laufzeitfehler(2)\n            else if(zufall == 2)\n                Kompilierfehler(\"sad\")\n            else\n                Referenzfehler(\"wkf\")\n\nwhen (f1){\n    is Laufzeitfehler -> println(f1)\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler aufgetreten.\")\n}"
    },
    {
     "start_checkpoint": 1622287051823,
     "parent": "n.0.121",
     "literal": "sealed class Fehler\ndata class Laufzeitfehler(val fehlercode: Int) : Fehler()\ndata class Kompilierfehler(val fehlercode: Int) : Fehler()\ndata class Referenzfehler(val fehlercode: Int) : Fehler()\n\nval zufall = (0..2).random()\nval f1 = if(zufall == 1)\n                Laufzeitfehler(123)\n            else if(zufall == 2)\n                Kompilierfehler(42)\n            else\n                Referenzfehler(200)\n\nwhen (f1){\n    is Laufzeitfehler -> println(\"Es ist ein Laufzeitfehler $f1 aufgetreten.\")\n    is Kompilierfehler -> println(\"Es ist ein Kompilierfehler $f1 aufgetreten.\")\n    is Referenzfehler -> println(\"Es ist ein Referenzfehler $f1 aufgetreten.\")\n}"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.67",
    "1": "o.82",
    "2": "o.83",
    "3": "o.84",
    "4": "o.85"
   },
   "artifact_name": "c.62",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "literal": "val parameter = (-100..200).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 6,
      "ch": 6
     }
    },
    {
     "start_checkpoint": 1622290304056,
     "parent": "n.0.89",
     "literal": "val parameter = (-100..100).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent //Fhren Sie die "
    },
    {
     "start_checkpoint": 1622290337397,
     "parent": "n.0.91",
     "literal": "val parameter = (-100..100).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent //Fhren Sie die Zelle mehrfach aus, um die verschiedenen Verhalten zu Betrachten"
    },
    {
     "start_checkpoint": 1622290370267,
     "parent": "n.0.92",
     "literal": "val parameter = (-100..100).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprintln(prozent::class.simpleName)\nprozent //Fhren Sie die Zelle mehrfach aus, um die verschiedenen Verhalten zu Betrachten"
    },
    {
     "start_checkpoint": 1622290408459,
     "parent": "n.0.121",
     "literal": "val parameter = (-100..100).random()\nval prozent = //In der Variable prozent wird entweder ein Wert zwischen 0 und 100 oder eine Exception gespeichert.\n    if (parameter in 0..100)\n        parameter\n    else\n        throw IllegalArgumentException(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent //Fhren Sie die Zelle mehrfach aus, um die verschiedenen Verhalten zu Betrachten"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.68",
    "1": "o.86",
    "3": "o.87",
    "4": "o.88",
    "5": "o.89",
    "7": "o.90"
   },
   "artifact_name": "c.63",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "literal": "val parameter = \"Kotlin\"\n//val parameter = \"231\"\nval prozent = \n    try{\n        Integer.parseInt(parameter)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $parameter kann nicht in eine ganze Zahl umgewandelt werden.\")\n    }\nprozent",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 9,
      "ch": 6
     }
    },
    {
     "start_checkpoint": 1622290479536,
     "parent": "n.0.94",
     "literal": "val parameter = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\n//val parameter = \"231\"\nval prozent = \n    try{\n        Integer.parseInt(parameter)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $parameter kann nicht in eine ganze Zahl umgewandelt werden.\")\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290547559,
     "parent": "n.0.96",
     "literal": "val parameter = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = \n    try{\n        Integer.parseInt(parameter)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $parameter kann nicht in eine ganze Zahl umgewandelt werden.\")\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290562913,
     "parent": "n.0.97",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = \n    try{\n        Integer.parseInt(zeichenkette)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\")\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290572241,
     "parent": "n.0.98",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = \n    try{\n        Integer.parseInt(zeichenkette)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\")\n        println(e)\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290587221,
     "parent": "n.0.99",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = \n    try{\n        Integer.parseInt(zeichenkette)\n    }\n    catch(e: Exception){\n        println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\\n$e\")\n    }\nprozent"
    },
    {
     "start_checkpoint": 1622290607436,
     "parent": "n.0.100",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval prozent = try{\n                    Integer.parseInt(zeichenkette)\n                }\n                catch(e: Exception){\n                    println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\\n$e\")\n                }\nprozent"
    },
    {
     "start_checkpoint": 1622290655058,
     "parent": "n.0.121",
     "literal": "val zeichenkette = if ((0..1).random() == 0)\n                    \"Kotlin\"\n                else\n                    \"231\"\nval zahl = try{\n                    Integer.parseInt(zeichenkette)\n                }\n                catch(e: Exception){\n                    println(\"Die Zeichenkette $zeichenkette kann nicht in eine ganze Zahl umgewandelt werden.\\n$e\")\n                }\nzahl"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.69"
   },
   "artifact_name": "c.64",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "literal": "class KeineProzentzahl(fehlermeldung: String) : Exception(fehlermeldung)\n\nval parameter = (-100..200).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw KeineProzentzahl(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.65",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.25",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.57"
   },
   "artifact_name": "c.66",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.121",
     "literal": "//Lsung\nclass Pizza (groee: Int, belaege: List<String>, geschnitten: Boolean){\n    val groee: Int\n    val belaege: MutableList<String>\n    val geschnitten: Boolean\n    \n    init {\n        this.groee = if (15 <= groee && groee <= 30) groee else -1\n        this.belaege = mutableListOf(\"Tomatensoe\", \"Mozzarella\")\n        this.belaege += belaege\n        this.geschnitten = geschnitten\n    }\n    \n    constructor (groee: Int) : this(groee, emptyList(), true) //Pizza Magaritha\n    constructor () : this(25, listOf(\"Thunfisch\", \"Zwiebeln\", \"Peperoni\"), true) //Pizza al Tonno\n}\n\n//Tests\nvar fehler = 0\nval test1 = Pizza(25, listOf(\"Schinken\"), false)\nif( test1.groee != 25 || test1.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test1.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 1! Richtig wre: Gre 25, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test1.groee}, Belge ${test1.belaege}, Geschnitten ${test1.geschnitten}\")\n}\nval test2 = Pizza(31, listOf(\"Schinken\"), false)\nif( test2.groee != -1 || test2.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test2.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 2! Richtig wre: Gre -1, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test2.groee}, Belge ${test2.belaege}, Geschnitten ${test2.geschnitten}\")\n}\nval test3 = Pizza(14, listOf(\"Schinken\"), false)\nif( test3.groee != -1 || test3.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test3.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 3! Richtig wre: Gre -1, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test3.groee}, Belge ${test3.belaege}, Geschnitten ${test3.geschnitten}\")\n}\nval test4 = Pizza(31, listOf(\"Schinken\"), false)\nif( test4.groee != -1 || test4.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Schinken\") || test4.geschnitten != false ){\n    fehler++\n    println(\"Fehler bei Test 4! Richtig wre: Gre -1, Belge [Tomatensoe, Mozzarella, Schinken], Geschnitten false \\n  Ist: Gre ${test4.groee}, Belge ${test4.belaege}, Geschnitten ${test4.geschnitten}\")\n}\nval test5 = Pizza(28, emptyList(), true)\nif( test5.groee != 28 || test5.belaege != listOf(\"Tomatensoe\", \"Mozzarella\") || test5.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 5! Richtig wre: Gre 28, Belge [Tomatensoe, Mozzarella], Geschnitten true \\n  Ist: Gre ${test5.groee}, Belge ${test5.belaege}, Geschnitten ${test5.geschnitten}\")\n}\nval test6 = Pizza(15)\nif( test6.groee != 15 || test6.belaege != listOf(\"Tomatensoe\", \"Mozzarella\") || test6.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 6! Richtig wre: Gre 15, Belge [Tomatensoe, Mozzarella], Geschnitten true \\n  Ist: Gre ${test6.groee}, Belge ${test6.belaege}, Geschnitten ${test6.geschnitten}\")\n}\nval test7 = Pizza()\nif( test7.groee != 25 || test7.belaege != listOf(\"Tomatensoe\", \"Mozzarella\", \"Thunfisch\", \"Zwiebeln\", \"Peperoni\") || test7.geschnitten != true ){\n    fehler++\n    println(\"Fehler bei Test 7! Richtig wre: Gre 25, Belge [Tomatensoe, Mozzarella, Thunfisch, Zwiebeln, Peperoni], Geschnitten false \\n  Ist: Gre ${test7.groee}, Belge ${test7.belaege}, Geschnitten ${test7.geschnitten}\")\n}\nif(fehler == 0)\n    println(\"Super! Alle Tests bestanden!\")\nelse\n    println(\"Bei $fehler Tests kamen Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 57,
      "ch": 49
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.67",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.47",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.68",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.47",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.69",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.121",
     "literal": "private val satz = object {\n    val subjekt = \"Kotlin\"\n    val praedikat = \"ist\"\n    val objekt = \"Programmiersprache\"\n    val vollstaendig = \"Kotlin ist eine Programmiersprache\"\n}\n\nprintln(\"Das Subjekt des Satzes ${satz.vollstaendig} ist ${satz.subjekt}.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 74
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.70",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.121",
     "literal": "class Student(val name: String, var alter: Int){\n    companion object { //Umsetzung in Java: public static int zaehler = 0\n        var zaehler = 0\n            get() = field++\n    }\n    \n    var matrikelnummer: Int\n    \n    init {\n        matrikelnummer = zaehler //Umsetzung in Java: matrikelnummer = zaehler++\n    }\n}\n\nval s1 = Student (\"Max\", 21)\nval s2 = Student (\"Anna\", 25)\nval s3 = Student (\"Simon\", 26)\nval s4 = Student (\"Sophie\", 19)\nprintln(\"Die Marikelnummer von ${s1.name} ist ${s1.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s2.name} ist ${s2.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s3.name} ist ${s3.matrikelnummer}.\")\nprintln(\"Die Marikelnummer von ${s4.name} ist ${s4.matrikelnummer}.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 20,
      "ch": 68
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.71",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.65",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.72",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.65",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "2": "o.91"
   },
   "artifact_name": "c.73",
   "versions": [
    {
     "start_checkpoint": 1622291027879,
     "parent": "n.0.108",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1622291059093,
     "parent": "n.0.109",
     "literal": "class Test(){\n    val t1: Int = 2\n}"
    },
    {
     "start_checkpoint": 1622291067351,
     "parent": "n.0.110",
     "literal": "class Test(){\n    val t1: Int = 2\n}\nval t = Test()\nt.t1"
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.92"
   },
   "artifact_name": "c.74",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "n.0.121",
     "literal": "abstract class Computer (val kerne: Int, val farbe: String){ //Abstrakte Klasse\n    var istAn = false\n    abstract fun einschalten() //Abstrakte Methode\n}\n\nclass Laptop (kerne: Int, farbe: String, val hatTouchscreen: Boolean) : Computer(kerne, farbe){\n    var istAufgeklappt = false\n    override fun einschalten() { //Vervollstndigt die abstrakte Methode einschalten(), die geerbt wurde\n        if (!istAufgeklappt) \n            istAufgeklappt = true\n        istAn = true\n        println(\"Laptop wurde eingeschalten.\")\n    }\n}\n\nclass Standcomputer (kerne: Int, farbe: String) : Computer(kerne, farbe){\n    override fun einschalten() {\n        istAn = true\n        println(\"Standcomputer wurde eingeschalten.\")\n    }\n}\n\n//val c1 = Computer (8, \"Schwarz\") -> Error: Cannot create an instance of an abstract class\nval l1 = Laptop(6, \"Rot\", false)\nl1.einschalten()\nval s1 = Standcomputer(12, \"Wei\")\ns1.einschalten()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 26,
      "ch": 15
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.93"
   },
   "artifact_name": "c.75",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "n.0.121",
     "literal": "class KeineProzentzahl(fehlermeldung: String) : Exception(fehlermeldung)\n\nval parameter = (-100..100).random()\nval prozent = \n    if (parameter in 0..100)\n        parameter\n    else\n        throw KeineProzentzahl(\"Der Parameter muss zwischen 0 und 100 sein, ist aber $parameter\")\nprozent",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.76",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "n.0.116",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.77",
   "versions": [
    {
     "start_checkpoint": 1622313230222,
     "parent": "n.0.120",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.94",
    "1": "o.95"
   },
   "artifact_name": "c.78",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "literal": "class Auto(val ps: Int, var farbe: String){\n    companion object {\n        val nummernschilder = mutableListOf<String>()\n        fun generiereNummernschild(): String {\n            var testschild = \"${('A'..'Z').random()}${('A'..'Z').random()}-${(1..9).random()}${(0..9).random()}\"\n            while (nummernschilder.find { it == testschild } != null){\n                testschild = \"${('A'..'Z').random()}${('A'..'Z').random()}-${(1..9).random()}${(0..9).random()}\"\n            }\n            nummernschilder.add(testschild)\n            return testschild\n        }\n    }\n    \n    val nummernschild = generiereNummernschild()\n}\n\n//Test\nvar duplikate = 0\nval autos = MutableList(100) { Auto ((60..300).random(), \"wei\") }\nfor (auto in autos){\n    for(testauto in autos){\n        if(auto.nummernschild == testauto.nummernschild && auto != testauto && auto.nummernschild != \"AA-00\"){\n            duplikate++\n            println(\"Nummernschild ${auto.nummernschild} wurde mehrfach gefunden.\")\n        }\n    }\n}\nif (duplikate == 0){\n    println(\"Super! Es konnten keine zwei Autos mit dem gleichen Nummernschild gefunden werden.\")\n}\nelse {\n    println(\"Falsch! Es wurden Nummernschilder mehrfach generiert.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": 0
     }
    },
    {
     "start_checkpoint": 1622445448043,
     "parent": "n.0.122",
     "literal": "class Auto(val ps: Int, var farbe: String){\n    companion object {\n        val nummernschilder = mutableListOf<String>()\n        fun generiereNummernschild(): String {\n            var testschild = \"${('A'..'Z').random()}${('A'..'Z').random()}-${(1..9).random()}${(0..9).random()}\"\n            while (nummernschilder.find { it == testschild } != null){\n                testschild = \"${('A'..'Z').random()}${('A'..'Z').random()}-${(1..9).random()}${(0..9).random()}\"\n            }\n            nummernschilder.add(testschild)\n            return testschild\n        }\n    }\n    \n    val nummernschild = generiereNummernschild()\n}\n\n//Test\nval autos = MutableList(100) { Auto ((60..300).random(), \"wei\") }\nval nummernschilder = mutableListOf<String>()\nfor (auto in autos){\n    nummernschilder.add(auto.nummernschild)\n}\nif (nummernschilder.size == nummernschilder.toSet().size){\n    println(\"Super! Alle Nummernschilder sind einzigartig.\")\n}\nelse {\n    println(\"Falsch! Es wurden Nummernschilder mehrfach vergeben.\")\n}"
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.79",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.80",
   "versions": [
    {
     "start_checkpoint": 1622445448043,
     "parent": "n.0.122",
     "start": {
      "line": 1,
      "ch": 0
     },
     "end": {
      "line": 1,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.96"
   },
   "artifact_name": "c.81",
   "versions": [
    {
     "start_checkpoint": 1622445629223,
     "literal": "//TODO\n\n//Test\nval autos = MutableList(100) { Auto ((60..300).random(), \"wei\") }\nval nummernschilder = mutableListOf<String>()\nfor (auto in autos){\n    nummernschilder.add(auto.nummernschild)\n}\nif (nummernschilder.size == nummernschilder.toSet().size){\n    println(\"Super! Alle Nummernschilder sind einzigartig.\")\n}\nelse {\n    println(\"Falsch! Es wurden Nummernschilder mehrfach vergeben.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 13,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.82",
   "versions": [
    {
     "start_checkpoint": 1622446154193,
     "literal": "//Lsung\nenum class Monat(val nummer: Int){\n    JANUAR(1), FEBRUAR(2), MAERZ(3), APRIL(4), MAI(5), JUNI(6), JULI(7), AUGUST(8), SEPTEMBER(9), OKTOBER(10), NOVEMBER(11), DEZEMBER(12)\n}\n\n//Test\ntry{\n    val januar = Monat.JANUAR\n    if(januar.nummer != 1){\n        println(\"Fehler! Der Januar ist der 1. Monat im Kalenderjahr.\")\n    }\n}\ncatch(e: Exception){\n    println(e)\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 14,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.83",
   "versions": [
    {
     "start_checkpoint": 1622446386059,
     "literal": "//Lsung\nenum class Monat(val nummer: Int){\n    JANUAR(1), FEBRUAR(2), MAERZ(3), APRIL(4), MAI(5), JUNI(6), JULI(7), AUGUST(8), SEPTEMBER(9), OKTOBER(10), NOVEMBER(11), DEZEMBER(12)\n}\n\n//Test\nvar fehler = 0\ntry{\n    val januar = Monat.JANUAR\n    if(januar.nummer != 1){\n        fehler++\n        println(\"Fehler! Der Januar ist der 1. Monat im Kalenderjahr.\")\n    }\n    val februar = Monat.FEBRUAR\n    if(februar.nummer != 2){\n        fehler++\n        println(\"Fehler! Der Februar ist der 2. Monat im Kalenderjahr.\")\n    }\n    val maerz = Monat.MAERZ\n    if(maerz.nummer != 3){\n        fehler++\n        println(\"Fehler! Der Mrz ist der 3. Monat im Kalenderjahr.\")\n    }\n    val april = Monat.APRIL\n    if(april.nummer != 4){\n        fehler++\n        println(\"Fehler! Der April ist der 4. Monat im Kalenderjahr.\")\n    }\n    val mai = Monat.MAI\n    if(mai.nummer != 5){\n        fehler++\n        println(\"Fehler! Der Mai ist der 5. Monat im Kalenderjahr.\")\n    }\n    val juni = Monat.JUNI\n    if(juni.nummer != 6){\n        fehler++\n        println(\"Fehler! Der Juni ist der 6. Monat im Kalenderjahr.\")\n    }\n    val juli = Monat.JULI\n    if(juli.nummer != 7){\n        fehler++\n        println(\"Fehler! Der Juli ist der 7. Monat im Kalenderjahr.\")\n    }\n    val august = Monat.AUGUST\n    if(august.nummer != 8){\n        fehler++\n        println(\"Fehler! Der August ist der 8. Monat im Kalenderjahr.\")\n    }\n    val september = Monat.SEPTEMBER\n    if(september.nummer != 9){\n        fehler++\n        println(\"Fehler! Der September ist der 9. Monat im Kalenderjahr.\")\n    }\n    val oktober = Monat.OKTOBER\n    if(oktober.nummer != 10){\n        fehler++\n        println(\"Fehler! Der Oktober ist der 10. Monat im Kalenderjahr.\")\n    }\n    val november = Monat.NOVEMBER\n    if(november.nummer != 11){\n        fehler++\n        println(\"Fehler! Der November ist der 11. Monat im Kalenderjahr.\")\n    }\n    val dezember = Monat.DEZEMBER\n    if(dezember.nummer != 12){\n        fehler++\n        println(\"Fehler! Der Dezember ist der 12. Monat im Kalenderjahr.\")\n    }\n}\ncatch(e: Exception){\n    println(e)\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 71,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.97"
   },
   "artifact_name": "c.84",
   "versions": [
    {
     "start_checkpoint": 1622446438359,
     "literal": "//Lsung\nenum class Monat(val nummer: Int){\n    JANUAR(1), FEBRUAR(2), MAERZ(3), APRIL(4), MAI(5), JUNI(6), JULI(7), AUGUST(8), SEPTEMBER(9), OKTOBER(10), NOVEMBER(11), DEZEMBER(12)\n}\n\n//Test\nvar fehler = 0\ntry{\n    val januar = Monat.JANUAR\n    if(januar.nummer != 1){\n        fehler++\n        println(\"Fehler! Der Januar ist der 1. Monat im Kalenderjahr.\")\n    }\n    val februar = Monat.FEBRUAR\n    if(februar.nummer != 2){\n        fehler++\n        println(\"Fehler! Der Februar ist der 2. Monat im Kalenderjahr.\")\n    }\n    val maerz = Monat.MAERZ\n    if(maerz.nummer != 3){\n        fehler++\n        println(\"Fehler! Der Mrz ist der 3. Monat im Kalenderjahr.\")\n    }\n    val april = Monat.APRIL\n    if(april.nummer != 4){\n        fehler++\n        println(\"Fehler! Der April ist der 4. Monat im Kalenderjahr.\")\n    }\n    val mai = Monat.MAI\n    if(mai.nummer != 5){\n        fehler++\n        println(\"Fehler! Der Mai ist der 5. Monat im Kalenderjahr.\")\n    }\n    val juni = Monat.JUNI\n    if(juni.nummer != 6){\n        fehler++\n        println(\"Fehler! Der Juni ist der 6. Monat im Kalenderjahr.\")\n    }\n    val juli = Monat.JULI\n    if(juli.nummer != 7){\n        fehler++\n        println(\"Fehler! Der Juli ist der 7. Monat im Kalenderjahr.\")\n    }\n    val august = Monat.AUGUST\n    if(august.nummer != 8){\n        fehler++\n        println(\"Fehler! Der August ist der 8. Monat im Kalenderjahr.\")\n    }\n    val september = Monat.SEPTEMBER\n    if(september.nummer != 9){\n        fehler++\n        println(\"Fehler! Der September ist der 9. Monat im Kalenderjahr.\")\n    }\n    val oktober = Monat.OKTOBER\n    if(oktober.nummer != 10){\n        fehler++\n        println(\"Fehler! Der Oktober ist der 10. Monat im Kalenderjahr.\")\n    }\n    val november = Monat.NOVEMBER\n    if(november.nummer != 11){\n        fehler++\n        println(\"Fehler! Der November ist der 11. Monat im Kalenderjahr.\")\n    }\n    val dezember = Monat.DEZEMBER\n    if(dezember.nummer != 12){\n        fehler++\n        println(\"Fehler! Der Dezember ist der 12. Monat im Kalenderjahr.\")\n    }\n}\ncatch(e: Exception){\n    println(e)\n}\n\nif(fehler != 0)\n    println(\"Falsch! Es traten $fehler Fehler auf.\")\nelse\n    println(\"Richtig! Es traten keine Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 76,
      "ch": 50
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.85",
   "versions": [
    {
     "start_checkpoint": 1622448432636,
     "literal": "abstract class Software(protected val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(private val dateiformate: List<String>, name: String): Software(name){\n    public fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override public fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.86",
   "versions": [
    {
     "start_checkpoint": 1622448474944,
     "literal": "abstract class Software(protected val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(private val dateiformate: List<String>, name: String): Software(name){\n    public fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override public fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(private val anzahlSpieler: Int, name: String): Software(name){\n    public fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override public fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 12,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.98"
   },
   "artifact_name": "c.87",
   "versions": [
    {
     "start_checkpoint": 1622448670796,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\nval text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\ntext.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 15,
      "ch": 8
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.99"
   },
   "artifact_name": "c.88",
   "versions": [
    {
     "start_checkpoint": 1622448728040,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 22,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.100"
   },
   "artifact_name": "c.89",
   "versions": [
    {
     "start_checkpoint": 1622448767131,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.101"
   },
   "artifact_name": "c.90",
   "versions": [
    {
     "start_checkpoint": 1622448836926,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 28,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.102"
   },
   "artifact_name": "c.91",
   "versions": [
    {
     "start_checkpoint": 1622448873498,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    \n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\nComputerspiel::class.supertypes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 30,
      "ch": 30
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.103"
   },
   "artifact_name": "c.92",
   "versions": [
    {
     "start_checkpoint": 1622448912229,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(Computerspiel::class.supertypes is Software)\n        println(\"Fehler\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.104"
   },
   "artifact_name": "c.93",
   "versions": [
    {
     "start_checkpoint": 1622448923282,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(Computerspiel::class.supertypes is Software)\n        println(\"Fehler\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.105"
   },
   "artifact_name": "c.94",
   "versions": [
    {
     "start_checkpoint": 1622448961246,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(Computerspiel::class.supertypes is Software)\n        println(\"Fehler\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.106"
   },
   "artifact_name": "c.95",
   "versions": [
    {
     "start_checkpoint": 1622448968685,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(Computerspiel::class.supertypes !is Software)\n        println(\"Fehler\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.107"
   },
   "artifact_name": "c.96",
   "versions": [
    {
     "start_checkpoint": 1622449325160,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel is Software){\n        println(\"Fehler\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.108"
   },
   "artifact_name": "c.97",
   "versions": [
    {
     "start_checkpoint": 1622449328804,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        println(\"Fehler\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.109"
   },
   "artifact_name": "c.98",
   "versions": [
    {
     "start_checkpoint": 1622449386830,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        println(\"Fehler\")\n    }\n    if(text !is Software){\n        println(\"Fehler\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.110"
   },
   "artifact_name": "c.99",
   "versions": [
    {
     "start_checkpoint": 1622449412581,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry{\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        println(\"Fehler! Klasse Computerspiel erbt nicht von Software\")\n    }\n    if(text !is Software){\n        println(\"Fehler! Klasse Textverarbeitungssoftware erbt nicht von Software\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.111"
   },
   "artifact_name": "c.100",
   "versions": [
    {
     "start_checkpoint": 1622449427152,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        println(\"Fehler! Klasse Computerspiel erbt nicht von Software\")\n    }\n    if(text !is Software){\n        println(\"Fehler! Klasse Textverarbeitungssoftware erbt nicht von Software\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.112"
   },
   "artifact_name": "c.101",
   "versions": [
    {
     "start_checkpoint": 1622449455419,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel !is Software){\n        throw Exception(\"Test\")\n    }\n    if(text !is Software){\n        println(\"Fehler! Klasse Textverarbeitungssoftware erbt nicht von Software\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.113"
   },
   "artifact_name": "c.102",
   "versions": [
    {
     "start_checkpoint": 1622449459194,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract){\n        println(\"Fehler! Klasse Software ist nicht abstrakt.\")\n    }\n    if(spiel is Software){\n        throw Exception(\"Test\")\n    }\n    if(text !is Software){\n        println(\"Fehler! Klasse Textverarbeitungssoftware erbt nicht von Software\")\n    }\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 35,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.114"
   },
   "artifact_name": "c.103",
   "versions": [
    {
     "start_checkpoint": 1622449563208,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract)\n        throw AssertionError(\"Klasse Software ist nicht abstrakt.\")\n    if(spiel !is Software)\n        throw AssertionError(\"Klasse Computerspiel erbt nicht von Software.\")\n    if(text !is Software)\n        throw AssertionError(\"Klasse Textverarbeitungssoftware erbt nicht von Software.\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.115"
   },
   "artifact_name": "c.104",
   "versions": [
    {
     "start_checkpoint": 1622449581627,
     "literal": "abstract class Software(val name: String){\n    abstract fun starte(): Unit\n}\n\nclass Textverarbeitungssoftware(val dateiformate: List<String>, name: String): Software(name){\n    fun schreiben() = println(\"Die Textverarbeitungssoftware $name schreibt...\")\n    override fun starte() = println(\"Die Textverarbeitungssoftware $name wird gestartet.\")\n}\n\nclass Computerspiel(val anzahlSpieler: Int, name: String): Software(name){\n    fun spielen() = println(\"Das Computerspiel $name wird gespielt...\")\n    override fun starte() = println(\"Das Computerspiel $name wird gestartet.\")\n}\n\ntry {\n    val text = Textverarbeitungssoftware(listOf(\"doc\",\"pages\",\"txt\"), \"Office\")\n    text.starte()\n    text.schreiben()\n    val spiel = Computerspiel(1, \"Cyberpunk 2077\")\n    spiel.starte()\n    spiel.spielen()\n    \n    if(!Software::class.isAbstract)\n        throw AssertionError(\"Klasse Software ist nicht abstrakt.\")\n    if(spiel !is Software)\n        throw AssertionError(\"Klasse Computerspiel erbt nicht von Software.\")\n    if(text !is Software)\n        throw AssertionError(\"Klasse Textverarbeitungssoftware erbt nicht von Software.\")\n    println(\"Super! Ihre Lsung ist richtig.\")\n}\ncatch(e: Exception){\n    println(\"Fehler! $e\")\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 33,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.116"
   },
   "artifact_name": "c.105",
   "versions": [
    {
     "start_checkpoint": 1622461253120,
     "literal": "interface Liste2 {\n    var erster: Int\n    \n    fun hinzufuegen(wert: Int): Boolean\n    fun entfernen(): Int\n}\n\nListe2::class.typeParameters",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 27
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.117"
   },
   "artifact_name": "c.106",
   "versions": [
    {
     "start_checkpoint": 1622461274695,
     "literal": "interface Liste2 {\n    var erster: Int\n    \n    fun hinzufuegen(wert: Int): Boolean\n    fun entfernen(): Int\n}\n\nListe2::class.supertypes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 23
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.107",
   "versions": [
    {
     "start_checkpoint": 1622461346825,
     "literal": "data class Element(val wert: Int, var naechster: Element? = null)\n\ninterface Liste {\n    var erster: Element \n    \n    fun hinzufuegen(wert: Int): Boolean\n    fun entfernen(): Int\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 7,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.108",
   "versions": [
    {
     "start_checkpoint": 1622461925182,
     "literal": "data class Element(val wert: Int, var naechster: Element? = null)\n\n//Lsung\ninterface Liste {\n    var erster: Element? //nullable, da das erste Element leer sein kann\n    \n    fun hinzufuegen(wert: Int): Boolean //Parameter: Wert des Elements, Rckgabe: Erfolg\n    fun entfernen(): Int //Rckgabe des Werts des entfernten Elements\n}",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 0
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.109",
   "versions": [
    {
     "start_checkpoint": 1622462322072,
     "literal": "class Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer]) {\n            parkplatz[nummer] = true\n        }\n        else {\n            throw ParkplatzVoll(nummer)\n        }\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Lsung\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    parkplatzverwaltung.einparken(2)\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 31,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.110",
   "versions": [
    {
     "start_checkpoint": 1622462349259,
     "literal": "class Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer]) {\n            parkplatz[nummer] = true\n        }\n        else {\n            println(\"Test\")\n            throw ParkplatzVoll(nummer)\n        }\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Lsung\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    parkplatzverwaltung.einparken(2)\n}\n",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 32,
      "ch": -1
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.118"
   },
   "artifact_name": "c.111",
   "versions": [
    {
     "start_checkpoint": 1622462409997,
     "literal": "class Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer])\n            parkplatz[nummer] = true\n        else\n            throw ParkplatzVoll(nummer)\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Lsung\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    try{\n        parkplatzverwaltung.einparken(2)\n    }\n    catch(e: ParkplatzVoll){\n        println(e)\n    }\n    \n}\n\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 36,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.119"
   },
   "artifact_name": "c.112",
   "versions": [
    {
     "start_checkpoint": 1622462466361,
     "literal": "class Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer])\n            parkplatz[nummer] = true\n        else\n            throw ParkplatzVoll(nummer)\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\n//Lsung\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    \n    try {\n        parkplatzverwaltung.einparken(2)\n    }\n    catch(e: ParkplatzVoll) {\n        println(e)\n    }\n}\n\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 36,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.120"
   },
   "artifact_name": "c.113",
   "versions": [
    {
     "start_checkpoint": 1622462480225,
     "literal": "//Lsung\nclass Parkplatzverwaltung(parkplatz: MutableList<Boolean>){\n    private val parkplatz: MutableList<Boolean> = parkplatz\n    \n    constructor() : this(MutableList<Boolean>(5) { false })\n    \n    fun einparken(nummer: Int): Unit {\n        if (!parkplatz[nummer])\n            parkplatz[nummer] = true\n        else\n            throw ParkplatzVoll(nummer)\n    } \n\n    override fun toString(): String {\n        var res = \"\"\n        parkplatz.forEach {\n            res += if (it) \"x\" else \"-\"\n        }\n        return res\n    }\n}\n\nclass ParkplatzVoll(nummer: Int) : Exception(\"Der Parkplatz $nummer ist belegt.\")\n\nfun main(){\n    val parkplatzverwaltung = Parkplatzverwaltung()\n    parkplatzverwaltung.einparken(2)\n    \n    try {\n        parkplatzverwaltung.einparken(2)\n    }\n    catch(e: ParkplatzVoll) {\n        println(e)\n    }\n}\n\nmain()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 36,
      "ch": 5
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.121"
   },
   "artifact_name": "c.114",
   "versions": [
    {
     "start_checkpoint": 1622554526806,
     "literal": "class Liste<T> (var erster: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erster == null)\n            erster = Element<T>(wert)\n        else {\n            val alterErster = erster\n            erster = Element<T>(wert, alterErster)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val ersterNeu = erster\n        erster = ersterNeu?.naechster\n        return ersterNeu?.wert\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 24,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.122"
   },
   "artifact_name": "c.115",
   "versions": [
    {
     "start_checkpoint": 1622554535077,
     "literal": "class Liste<T> (var erster: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erster == null)\n            erster = Element<T>(wert)\n        else {\n            val alterErster = erster\n            erster = Element<T>(wert, alterErster)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val ersterNeu = erster\n        erster = erster?.naechster\n        return ersterNeu?.wert\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 24,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.123"
   },
   "artifact_name": "c.116",
   "versions": [
    {
     "start_checkpoint": 1622554558291,
     "literal": "class Liste<T> (var erster: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erster == null)\n            erster = Element<T>(wert)\n        else {\n            val alterErster = erster\n            erster = Element<T>(wert, alterErster)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erster?.wert\n        erster = erster?.naechster\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 24,
      "ch": 19
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.124"
   },
   "artifact_name": "c.117",
   "versions": [
    {
     "start_checkpoint": 1622554574252,
     "literal": "class Liste<T> (var erster: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erster == null)\n            erster = Element<T>(wert)\n        else {\n            val alterErster = erster\n            erster = Element<T>(wert, alterErster)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erster?.wert\n        erster = erster?.naechster\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erster",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.125"
   },
   "artifact_name": "c.118",
   "versions": [
    {
     "start_checkpoint": 1622554722608,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechster: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        if (erstes == null)\n            erstes = Element<T>(wert)\n        else {\n            val altesErstes = erstes\n            erstes = Element<T>(wert, erstes)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechster\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.126"
   },
   "artifact_name": "c.119",
   "versions": [
    {
     "start_checkpoint": 1622554905062,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        if (erstes == null)\n            erstes = Element<T>(wert)\n        else {\n            erstes = Element<T>(wert, erstes)\n        }\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.120",
   "versions": [
    {
     "start_checkpoint": 1622554911490,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 20,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.121",
   "versions": [
    {
     "start_checkpoint": 1622554924020,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.hinzufuegen(3)\nlisteInt.entfernen()\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 20,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.127"
   },
   "artifact_name": "c.122",
   "versions": [
    {
     "start_checkpoint": 1622554928149,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 17,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.128"
   },
   "artifact_name": "c.123",
   "versions": [
    {
     "start_checkpoint": 1622554936285,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert) } ?: Element<T>(wert, erstes)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 18,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.129"
   },
   "artifact_name": "c.124",
   "versions": [
    {
     "start_checkpoint": 1622555013679,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nlisteInt.hinzufuegen(1)\nlisteInt.hinzufuegen(2)\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 18,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.130"
   },
   "artifact_name": "c.125",
   "versions": [
    {
     "start_checkpoint": 1622555057935,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nval listeInt = Liste<Int>()\nfor (i in 1..10){\n    listeInt.hinzufuegen(i)\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 19,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.131"
   },
   "artifact_name": "c.126",
   "versions": [
    {
     "start_checkpoint": 1622555146041,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..10){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 10){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 25,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.132"
   },
   "artifact_name": "c.127",
   "versions": [
    {
     "start_checkpoint": 1622555280381,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..10){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 10){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 9){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 29,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.133"
   },
   "artifact_name": "c.128",
   "versions": [
    {
     "start_checkpoint": 1622555291808,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 10){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 9){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 29,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.134"
   },
   "artifact_name": "c.129",
   "versions": [
    {
     "start_checkpoint": 1622555329392,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 33,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.135"
   },
   "artifact_name": "c.130",
   "versions": [
    {
     "start_checkpoint": 1622555376241,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    listeInt.hinzufuegen(i)\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 37,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.136"
   },
   "artifact_name": "c.131",
   "versions": [
    {
     "start_checkpoint": 1622555441324,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht hinzugefgt werden.\")\n    }\n    \n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 41,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.132",
   "versions": [
    {
     "start_checkpoint": 1622555523519,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefgt werden.\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() != i){\n        fehler++\n        println(\"Fehler! Ein Element konnte nicht enfernt werden.\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.133",
   "versions": [
    {
     "start_checkpoint": 1622555546003,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefgt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() != i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. $listeInt\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.137"
   },
   "artifact_name": "c.134",
   "versions": [
    {
     "start_checkpoint": 1622555549197,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefgt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() == i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. $listeInt\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.138"
   },
   "artifact_name": "c.135",
   "versions": [
    {
     "start_checkpoint": 1622555562967,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefgt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() == i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.toString()}\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.139"
   },
   "artifact_name": "c.136",
   "versions": [
    {
     "start_checkpoint": 1622555573766,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefgt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() == i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.erstes?.toString()}\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.140"
   },
   "artifact_name": "c.137",
   "versions": [
    {
     "start_checkpoint": 1622555585074,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefgt werden. $listeInt\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste.\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() == i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.erstes}\")\n    }\n}\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 46,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {},
   "artifact_name": "c.138",
   "versions": [
    {
     "start_checkpoint": 1622555682607,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefgt werden. ${listeInt.erstes}\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste. ${listeInt.erstes}\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() != i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.erstes}\")\n    }\n}\nif(listeInt.entfernen() != null){\n        fehler++\n        println(\"Fehler! Obwohl kein Element mehr entfernt werden knnen sollte, wurde ein Wert zurckgegeben. ${listeInt.erstes}\")\n    }\nlisteInt.erstes",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 50,
      "ch": 14
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.141"
   },
   "artifact_name": "c.139",
   "versions": [
    {
     "start_checkpoint": 1622555767250,
     "literal": "class Liste<T> (var erstes: Element<T>? = null){\n    data class Element<F>(val wert: F, var naechstes: Element<F>? = null)\n    \n    fun hinzufuegen(wert: T): Boolean {\n        erstes = erstes?.let { Element<T>(wert, erstes) } ?: Element<T>(wert)\n        return true\n    }\n    fun entfernen(): T? {\n        val res = erstes?.wert\n        erstes = erstes?.naechstes\n        return res\n    }\n}\n\n//Test\nvar fehler = 0\nval listeInt = Liste<Int>()\nfor (i in 1..5){\n    if(!listeInt.hinzufuegen(i)){\n        fehler++\n        println(\"Fehler! Ein Element mit dem Wert $i konnte nicht hinzugefgt werden. ${listeInt.erstes}\")\n    }\n}\n\nif (listeInt.erstes?.wert != 5){\n    fehler++\n    println(\"Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber ${listeInt.erstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.wert != 4){\n    fehler++\n    println(\"Fehler! Der Wert des zweiten Elements sollte 10 sein, ist aber ${listeInt.erstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert != 1){\n    fehler++\n    println(\"Fehler! Der Wert des letzten Elements sollte 1 sein, ist aber ${listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.wert}\")\n}\nif (listeInt.erstes?.naechstes?.naechstes?.naechstes?.naechstes?.naechstes != null){\n    fehler++\n    println(\"Fehler! Es ist eine falsche Anzahl an Elementen in der Liste. ${listeInt.erstes}\")\n}\nfor (i in 5 downTo 1){\n    if(listeInt.entfernen() != i){\n        fehler++\n        println(\"Fehler! Das Element mit dem Wert $i konnte nicht enfernt werden. ${listeInt.erstes}\")\n    }\n}\nif(listeInt.entfernen() != null){\n        fehler++\n        println(\"Fehler! Obwohl kein Element mehr entfernt werden knnen sollte, wurde ein Wert zurckgegeben. ${listeInt.erstes}\")\n}\n\nif(fehler == 0)\n    println(\"Super! Ihre Lsung hat alle Tests bestanden.\")\nelse\n    println(\"Falsch! Es traten bei $fehler Tests Fehler auf.\")",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 54,
      "ch": 61
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.142"
   },
   "artifact_name": "c.140",
   "versions": [
    {
     "start_checkpoint": 1622557161983,
     "literal": "class Person(public val name: String)\n\nval p1 = Person(\"test\")\np1.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.143"
   },
   "artifact_name": "c.141",
   "versions": [
    {
     "start_checkpoint": 1622557178954,
     "literal": "class Person(internal val name: String)\n\nval p1 = Person(\"test\")\np1.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 3,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.144"
   },
   "artifact_name": "c.142",
   "versions": [
    {
     "start_checkpoint": 1622557527039,
     "literal": "class LesbarePerson(name: String){\n    private val name = name\n    get() = field\n}\nval p1 = Person(\"test\")\np1.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 5,
      "ch": 6
     }
    }
   ]
  },
  {
   "output_histories": {
    "0": "o.145"
   },
   "artifact_name": "c.143",
   "versions": [
    {
     "start_checkpoint": 1622557707412,
     "literal": "class LesbarePerson(name: String){\n    var name = name\n    get() = field\n    private set(neuerWert){\n        field = neuerWert\n    }\n}\nval p1 = Person(\"test\")\np1.name",
     "start": {
      "line": 0,
      "ch": 0
     },
     "end": {
      "line": 8,
      "ch": 6
     }
    }
   ]
  }
 ],
 "markdownCells": [
  {
   "artifact_name": "m.0",
   "versions": [
    {
     "start_checkpoint": 1619004012983,
     "parent": "n.0.0",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes wird die objektorientierte Programmierung sein.\n\n## Lektion 1 - Einfhrung\nAufgrund der Kompatibilitt mit Java ist Kotlin eine objektorientierte Sprache. Dabei werden alle Daten als Objekte behandelt. Es sind alle bekannten objektorientierte Konzepte vorhanden, jedoch angepasst und teilweise auch vereinfacht. Dazu ein Beispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt, `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>\n\nEs ist zu erkennen, dass der Kotlincode deutlich krzer und auch bersichtlicher ist. Jedoch wird er Ihnen aktuell wenig aussagen. In den folgenden Lektionen wird das Beispiel Schritt fr Schritt erklrt.\n\n## Lektion 2 - Felder"
    }
   ]
  },
  {
   "artifact_name": "m.1",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.11",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes wird die objektorientierte Programmierung sein.\n\n## Lektion 1 - Klassen\nAufgrund der Kompatibilitt mit Java ist auch Kotlin eine objektorientierte Sprache. Deswegen werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind alle bekannten objektorientierte Konzepte vorhanden, jedoch angepasst und teilweise auch vereinfacht. Dazu ein Einfhrungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.2",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.24",
     "markdown": "Es ist zu erkennen, dass der Kotlincode deutlich krzer und bersichtlicher ist. Warum er so aussieht wird in den folgenden Lektionen genauer besprochen.\n\n### Felder\nFelder knnen Klassen einfach Hinzugefgt werden. Die erste Mglichkeit ist durch die bergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei ffentlicher Sichtbarkeit eine Variablenart (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heit es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, welches bei Objekterzeugung mit dem Wert des bergabeparameters gefllt wird. Auerdem wird immer ein unsichtbarer Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, wird zustzlich ein rudimentrer Setter der Klasse hinzugefgt."
    }
   ]
  },
  {
   "artifact_name": "m.3",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "Eine weitere Mglichkeit Felder zu definieren ist klassisch zu Beginn im Rumpf der Klasse. Diese werden jedoch nicht automatisch bei Objekterzeugung, sondern mit dem angegebenen Standardwert gefllt. Diesen wird auch je nach Typ im Hintergrund ein Getter und Setter bei Seite gestellt."
    },
    {
     "start_checkpoint": 1622204182191,
     "parent": "n.0.116",
     "markdown": "Eine weitere Mglichkeit Felder zu definieren ist klassisch im Rumpf der Klasse. Diese werden jedoch nicht automatisch bei Objekterzeugung, sondern mit den angegebenen Standardwerten befllt. Des Weiteren wird auch diesen Feldern je nach Typ im Hintergrund ein Getter und Setter bei Seite gestellt."
    }
   ]
  },
  {
   "artifact_name": "m.4",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder mit Werten bestckt werden. Aufgrund des Konstruktorwirrars in Java, unterscheidet Kotlin zwischen 2 verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n#### Primrer Konstruktor\nDer primre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204322287,
     "parent": "n.0.30",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder bei Objekterzeugung mit Werten bestckt werden. Aufgrund des Konstruktorwirrars in Java, unterscheidet Kotlin zwischen 2 verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n#### Primrer Konstruktor\nDer primre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204355567,
     "parent": "n.0.31",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder bei Objekterzeugung mit Werten bestckt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n#### Primrer Konstruktor\nDer primre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204374734,
     "parent": "n.0.32",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder bei Objekterzeugung mit Werten bestckt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n#### Primrer Konstruktor\nDer primre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204384000,
     "parent": "n.0.33",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder bei Objekterzeugung mit Werten bestckt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n#### Primrer Konstruktor\nDer primre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204391516,
     "parent": "n.0.34",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder bei Objekterzeugung mit Werten bestckt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\n#### Primrer Konstruktor\nDer primre Konstruktor besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204421079,
     "parent": "n.0.35",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder bei Objekterzeugung mit Werten bestckt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\n#### Primrer Konstruktor\nDer primre Konstruktor ist fr die eigentliche Erzeugung der Objekte zustndig und besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204433050,
     "parent": "n.0.36",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder bei Objekterzeugung mit Werten bestckt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\n#### Primrer Konstruktor\nDer primre Konstruktor ist fr die eigentliche Erzeugung der Objekte zustndig und besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm Folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDen Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204441673,
     "parent": "n.0.37",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder bei Objekterzeugung mit Werten bestckt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\n#### Primrer Konstruktor\nDer primre Konstruktor ist fr die eigentliche Erzeugung der Objekte zustndig und besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm Folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDer Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, die einem Variablentyp zugewiesen sind, generiert.  "
    },
    {
     "start_checkpoint": 1622204457914,
     "parent": "n.0.121",
     "markdown": "### Konstruktor\nMit dem Konstruktor knnen die Felder bei Objekterzeugung mit Werten bestckt werden. Aufgrund des *Konstruktorwirrars* in Java, unterscheidet Kotlin zwischen zwei verschiedenenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\n#### Primrer Konstruktor\nDer primre Konstruktor ist fr die eigentliche Erzeugung der Objekte zustndig und besitzt drei verschiedene Erscheinungsformen:\n<ul>\n    <li>Defaultkonstruktor</li>\n    <li>Konstruktor mit <code>init</code>-Block</li>\n    <li>Konstruktor durch direkte Zuweisung</li>\n</ul>\n\nIm Folgenden wird auf alle Arten Bezug genommen und im Anschluss ein Vergleich angestellt.\n##### Defaultkonstruktor\nDer Defaultkonstruktor wurde bereits bei den [Feldern](#Felder) kennengelernt. Dieser wird vom Compiler fr alle Parameter, denen ein Variablentyp zugewiesen wurde, generiert.  "
    }
   ]
  },
  {
   "artifact_name": "m.5",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "##### Konstruktor mit `init`-Block\nNatrlich kann der Konstruktor auch selbst, wie in Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlsselwort `init` gefolgt von einem Methodenrumpf. Anders als von Java gewhnt werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter knnen im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204457914,
     "parent": "n.0.38",
     "markdown": "##### Konstruktor mit init-Block\nNatrlich kann der Konstruktor auch selbst, wie in Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlsselwort `init` gefolgt von einem Methodenrumpf. Anders als von Java gewhnt werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter knnen im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204477080,
     "parent": "n.0.39",
     "markdown": "##### Konstruktor mit init-Block\nNatrlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlsselwort `init` gefolgt von einem Methodenrumpf. Anders als von Java gewhnt werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter knnen im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204494036,
     "parent": "n.0.40",
     "markdown": "##### Konstruktor mit init-Block\nNatrlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlsselwort `init`, gefolgt von einem Methodenrumpf. Anders als von Java gewhnt werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter knnen im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204513712,
     "parent": "n.0.41",
     "markdown": "##### Konstruktor mit init-Block\nNatrlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlsselwort `init`, gefolgt von einem Methodenrumpf. Im Vergleich zu Java werden dessen Parameter nicht direkt im Kopf des Konstruktors angegeben, sondern im Kopf der Klasse. Die dort definierten Parameter knnen im Konstruktor benutzt werden. Bei Namenskonflikten findet wieder das Schlsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    },
    {
     "start_checkpoint": 1622204534951,
     "parent": "n.0.116",
     "markdown": "##### Konstruktor mit init-Block\nNatrlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlsselwort `init`, gefolgt von einem Methodenrumpf. Im Vergleich zu Java werden dessen Parameter nicht direkt im Kopf des Konstruktors, sondern im Kopf der Klasse angegeben. Die dort definierten Parameter knnen im Konstruktor benutzt werden. Bei Namenskonflikten findet das Schlsselwort `this` Anwendung, das das aktuelle Objekt referenziert."
    }
   ]
  },
  {
   "artifact_name": "m.6",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "##### Konstruktor durch direkte Initialisierung\nEine weitere Mglichkeit der Initialisierung ist die Felder direkt bei der Deklaration den Parametern oder festgelegten Werten zuzuweisen."
    },
    {
     "start_checkpoint": 1622204534951,
     "parent": "n.0.121",
     "markdown": "##### Konstruktor durch direkte Initialisierung\nEine weitere Mglichkeit der Initialisierung ist, die Felder direkt bei der Deklaration Parameter oder festgelegte Werte zuzuweisen."
    }
   ]
  },
  {
   "artifact_name": "m.7",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "##### Vergleich\nJede Erscheinungsform des Konstruktors hat seine Vorteile und Anwendungsbereiche. Whrend der Defaultkonstruktor bei einfachen Klassen, bei denen nicht mit den bergabedaten vor der Zuweisung gearbeitet werden, zu bevorzugen ist, bieten die expliziten Konstruktoren genau das. Auf dem ersten Blick scheint es so, als bentige man den Konstruktor mit einem `init`-Block nicht, da die Parameter scheinbar mit dem gleichen Ergebnis direkt zugewiesen werden knnen. Jedoch ist dieser bei komplexeren Klassen zu bevorzugen, da dort alle Daten erst auf Richtigkeit geprft werden und so beispielweise auch mit `try` und `catch` gearbeitet werden kann (nheres dazu in [Lektion X](Lektion-X---Fehlerbehandlung)).\n\n##### Kombination\nDie verschiedenen Konstruktoren knnen auch beliebig miteinander kombiniert werden. "
    }
   ]
  },
  {
   "artifact_name": "m.8",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.25",
     "markdown": "##### Mehrere primre Konstruktoren\nEine wichtige Eigenschaft einer Klasse fehlt aber noch: Die Erzeugung eines Objekts mit unterschiedlichen Parameterprofilen. Dazu knnen in der Klasse mehrere primre Konstruktoren implementiert werden. Diesen wird das Schlsselwort `constructor` vorangestellt. Auerdem bekommt jeder Konstruktor sein eigenes Parameterprofil, mit dem dieser dann in dessen Rumpf arbeiten kann. Die Konstruktoren hnelm dabei dem `init`-Verfahren, da sie alle ihren eigenen Rumpf besitzen. Die Parameterklammern der Klasse werden weggelassen."
    }
   ]
  },
  {
   "artifact_name": "m.9",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.1",
     "markdown": "#### Sekundrer Konstruktor"
    },
    {
     "start_checkpoint": 1619167525913,
     "parent": "n.0.25",
     "markdown": "#### Sekundrer Konstruktor\nMit Hilfe eines sekundren Konstruktors ist es einfach mglich alternative Objekterzeugungen zu implementierten. Dazu wird ein primrer Konstruktor mit `this()` mit zu bestimmenden Parametern aufgerufen. Auch kann ein anderer sekndrer Konstruktor aufgerufen, jedoch muss am Ende ein Primrer benutzt werden, da nur dieser das Objekt erzeugen kann. Die Implementierung eines sekundren Konstruktors hnelt der bei Benutzung mehrerer primrer Konstruktoren. Jedoch ist nur eine Anweisung erlaubt, die von den Parametern mit `:` getrennt wird. Diese muss einen Konstruktor aufrufen (`this()` oder `super()`)."
    },
    {
     "start_checkpoint": 1622205474347,
     "parent": "n.0.116",
     "markdown": "#### Sekundrer Konstruktor\nMit Hilfe eines sekundren Konstruktors ist es einfach mglich alternative Wege Objekte zu erzeugen bereitzustellen. Dazu wird ein primrer Konstruktor mit `this()` und zu bestimmenden Parametern aufgerufen. Auch kann ein anderer sekndrer Konstruktor aufgerufen, jedoch muss am Ende immer ein Primrer benutzt werden, da nur dieser das Objekt erzeugen kann. Die Implementierung eines sekundren Konstruktors hnelt der bei Benutzung mehrerer primrer Konstruktoren. Jedoch ist nur eine Anweisung erlaubt, die von den Parametern mit `:` getrennt wird und einen primren Konstruktor aufruft."
    }
   ]
  },
  {
   "artifact_name": "m.10",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "n.0.8",
     "markdown": "## Lektion X - Fehlerbehandlung"
    }
   ]
  },
  {
   "artifact_name": "m.11",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.24",
     "markdown": "### Aufgabe\nImplementieren Sie eine Klasse `Pizza`. Jede Pizza soll eine Gre `groee` (zwischen 15 und 30 [cm], ansonsten -1) und eine Liste aus Belgen `belaege` (Standardmig bereits mit Tomatensoe und Kse befllt) enthalten. Auerdem soll gespeichert werden, ob sie geschnitten `geschnitten` werden soll. Whlen Sie einen passenden primren Konstruktor, der fr jedes Feld einen bergabeparameter besitzt. Fgen Sie auerdem weitere (sekundre) Konstruktoren hinzu, die eine Pizza Magaritha (Tomatensoe, Mozzarella) und eine 25cm Pizza al Tonno (Tomatensoe, Mozzarella, Thunfisch, Zwiebeln, Peperoni) initialisieren. Beide Pizzas sollen geschnitten werden."
    }
   ]
  },
  {
   "artifact_name": "m.12",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.25",
     "markdown": "### Getter und Setter\nEs knnen aber auch eigene Getter und Setter fr jedes Feld definiert werden, falls der Variablentyp dies zulsst. Sie mssen direkt nach den Feld definiert werden. Auf der aktuelle Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter bergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert reprsentiert. Ein Wert wird dem Feld mit einer Zuweisung an `field` gendert. Es sind immer die Datentypen der Felder zu beachten."
    },
    {
     "start_checkpoint": 1622205474347,
     "parent": "n.0.44",
     "markdown": "### Getter und Setter\nEs knnen aber auch eigene Getter und Setter fr jedes Feld definiert werden, falls der Variablentyp dies zulsst und diese erst im Rumpf der Klasse definiert werden. Sie mssen direkt nach den Feld definiert werden. Auf der aktuelle Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter bergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert reprsentiert. Ein Wert wird dem Feld mit einer Zuweisung an `field` gendert. Es sind immer die Datentypen der Felder zu beachten."
    },
    {
     "start_checkpoint": 1622205682750,
     "parent": "n.0.45",
     "markdown": "### Getter und Setter\nEs knnen aber auch eigene Getter und Setter fr jedes Feld definiert werden, falls der Variablentyp dies zulsst und diese erst im Rumpf der Klasse definiert werden. Beide mssen direkt nach den Feld definiert werden. Auf der aktuelle Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter bergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert reprsentiert. Ein Wert wird dem Feld mit einer Zuweisung an `field` gendert. Es sind immer die Datentypen der Felder zu beachten."
    },
    {
     "start_checkpoint": 1622205747266,
     "parent": "n.0.116",
     "markdown": "### Getter und Setter\nEs knnen aber auch eigene Getter und Setter fr jedes Feld definiert werden, falls der Variablentyp dies zulsst und diese erst im Rumpf der Klasse definiert werden. Beide mssen direkt nach den Feld definiert werden. Auf den aktuellen Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter bergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert reprsentiert. Der Wert des Feldes wird mit einer Zuweisung an `field` gendert. Es sind immer die Datentypen der Felder zu beachten."
    }
   ]
  },
  {
   "artifact_name": "m.13",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "#### Computed Properties\nDurch die Definition eigener Getter knnen Felder auch kleine Methoden darstellen ohne einen eigenen Wert zu speichern. So knnen beispielsweise berechnete Wahrheitswerte zurckgegeben werden. Diese Handhabung kann rudimentre Methoden ersetzen. Als Beispiel wird die bereits kennengelernte Klasse `Person` mit einem berechnetem Feld `istVolljaerig` ergnzt."
    },
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.121",
     "markdown": "#### Computed Properties\nDurch die Definition eigener Getter knnen Felder auch *kleine Methoden* darstellen ohne einen eigenen Wert zu speichern. So knnen beispielsweise berechnete Wahrheitswerte zurckgegeben werden. Dadurch knnen rudimentre Methoden ersetzt werden. Als Beispiel wird die bereits kennengelernte Klasse `Person` mit einem berechneten Feld `istVolljaerig` ergnzt."
    }
   ]
  },
  {
   "artifact_name": "m.14",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlsselwort `by lazy` trge gemacht werden. Das heit, dass der Wert erst bei Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck ntig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Wert jedoch nicht noch einmal berechnet, sondern der gespeicherte Wert wird verwendet.\n\nQuiz: Wie oft wird \"Wird berechnet...\" ausgegeben?"
    },
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.47",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlsselwort `by lazy` *trge* gemacht werden. Das heit, dass der Wert erst bei Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck ntig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Wert jedoch nicht noch einmal berechnet, sondern der gespeicherte Wert wird verwendet.\n\nQuiz: Wie oft wird \"Wird berechnet...\" ausgegeben?"
    },
    {
     "start_checkpoint": 1622209186075,
     "parent": "n.0.48",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlsselwort `by lazy` *trge* gemacht werden. Das heit, dass der Wert erst bei der ersten Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck ntig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Wert jedoch nicht noch einmal berechnet, sondern der gespeicherte Wert wird verwendet.\n\nQuiz: Wie oft wird \"Wird berechnet...\" ausgegeben?"
    },
    {
     "start_checkpoint": 1622209235576,
     "parent": "n.0.116",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlsselwort `by lazy` *trge* gemacht werden. Das heit, dass der Wert erst bei der ersten Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck ntig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Inhalt nicht noch einmal berechnet, sondern der gespeicherte Wert wird verwendet."
    }
   ]
  },
  {
   "artifact_name": "m.15",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "#### `lateinit`\nEin weiteres hnliches Konstrukt ist `lateinit`. Dies findet Anwendung, wenn ein Feld erst nach der Objekterzeugung einen Wert zurgewiesen bekommt. Dieses Feld kann dann im Konstruktor ignoriert werden.<br />\nVorraussetzungen:\n* Das Feld ist vom Typ `var`\n* Der Datentyp des Feldes ist nonnullable\n* Der Datentyp des Feldes ist nicht primitiv"
    },
    {
     "start_checkpoint": 1622209235576,
     "parent": "n.0.121",
     "markdown": "#### `lateinit`\nEin weiteres, hnliches Konstrukt ist `lateinit`. Dies findet Anwendung, wenn ein Feld erst nach der Objekterzeugung einen Wert zugewiesen bekommt. Dieses Feld kann im Konstruktor ignoriert werden.  \nVorraussetzungen:\n* Das Feld ist vom Typ `var`\n* Der Datentyp des Feldes ist *non-nullable*\n* Der Datentyp des Feldes ist nicht primitiv"
    }
   ]
  },
  {
   "artifact_name": "m.16",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Einem `lateinit` Feld ist zustzlich gespeichert, ob es bereits initialisiert wurde. Diese Information kann mit `this::name.isInitialized` abgerufen werden."
    },
    {
     "start_checkpoint": 1622209235576,
     "parent": "n.0.49",
     "markdown": "In einem `lateinit` Feld ist zustzlich gespeichert, ob es bereits initialisiert wurde. Diese Information kann mit `this::name.isInitialized` abgerufen werden."
    },
    {
     "start_checkpoint": 1622209406266,
     "parent": "n.0.121",
     "markdown": "In einem `lateinit` Feld ist zustzlich gespeichert, ob es bereits fr das Objekt initialisiert wurde. Diese Information kann mit `this::name.isInitialized` abgerufen werden."
    }
   ]
  },
  {
   "artifact_name": "m.17",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "### Sichtbarkeiten\nBis jetzt wurden alle Variablen, Felder und Klassen ffentlich implementiert. Jedoch gibt es in Kotlin wie auch in Java Sichtbarkeiten, mit denen der Zugriff eingeschrnkt werden kann.\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden."
    },
    {
     "start_checkpoint": 1622209406266,
     "parent": "n.0.50",
     "markdown": "### Sichtbarkeiten\nBis jetzt wurden alle Variablen, Felder und Klassen ffentlich implementiert. Jedoch gibt es in Kotlin, wie auch in Java, Sichtbarkeiten, mit denen der Zugriff eingeschrnkt werden kann.\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden."
    },
    {
     "start_checkpoint": 1622209516136,
     "parent": "n.0.121",
     "markdown": "### Sichtbarkeiten\nBis jetzt wurden alle Variablen, Felder und Klassen ffentlich implementiert. Jedoch gibt es in Kotlin, wie auch in Java, Sichtbarkeiten, mit denen der Zugriff eingeschrnkt werden kann.\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen Sie sich als grere Pakete vorgestellen.\n* `public`: Das Element kann berall benutzt werden."
    }
   ]
  },
  {
   "artifact_name": "m.18",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "### Methoden\nObjektmethoden sind mit normalen statischen Methoden zu vergleichen. Es kann die Kurzschreibweise angewendet und eine Sichtbarkeit zugewiesen werden. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits generierte Methode, zum Beispiel `toString()`, berschrieben werden, muss der Methode das Schlsselwort `override` vorangestellt werden."
    },
    {
     "start_checkpoint": 1622209516136,
     "parent": "n.0.51",
     "markdown": "### Methoden\nDer Aufbau von Objektmethoden kann mit dem von Funktionen verglichen werden. Es kann die Kurzschreibweise angewendet und eine Sichtbarkeit zugewiesen werden. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits implementierte Methode, zum Beispiel `toString()`, berschrieben werden, muss der Methode das Schlsselwort `override` vorangestellt werden."
    },
    {
     "start_checkpoint": 1622209678258,
     "parent": "n.0.52",
     "markdown": "### Methoden\nDer Aufbau von Objektmethoden kann mit dem von Funktionen verglichen werden, werden jedoch im Rumpf einer Klasse definiert. Es kann die Kurzschreibweise angewendet und eine Sichtbarkeit zugewiesen werden. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits implementierte Methode, zum Beispiel `toString()`, berschrieben werden, muss der Methode das Schlsselwort `override` vorangestellt werden."
    },
    {
     "start_checkpoint": 1622209719335,
     "parent": "n.0.116",
     "markdown": "### Methoden\nDer Aufbau von Objektmethoden kann mit dem von Funktionen verglichen werden, werden jedoch im Rumpf einer Klasse definiert. Es kann die Kurzschreibweise angewendet und eine Sichtbarkeit zugewiesen werden. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits implementierte Methode, zum Beispiel `toString()`, berschrieben werden, ist das Voranstellen des Schlsselworts `override` ntig."
    }
   ]
  },
  {
   "artifact_name": "m.19",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.8",
     "markdown": "### Aufgabe ??"
    }
   ]
  },
  {
   "artifact_name": "m.20",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "## Lektion 2 - Datenklassen\nZustzlich zu normalen Klassen bietet Kotlin auch die Mglichkeit Klassen zu erstellen, die nur die Aufgabe der Speicherung von Daten haben. Auf den ersten Blick knnte dies auch mit normalen Klassen bewerkstelligt werden. Jedoch mssen dann alle Methoden per Hand implementiert werden. Beispielsweise `toString()`oder auch `equals()`. Um dem aus dem Weg zu gehen, gibt es Datenklassen. Fr diese generiert der Kotlin-Compiler im Hintergrund folgende Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Gekennzeichnet werden Datenklassen mit dem Schlsselwort `data class`."
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.57",
     "markdown": "## Lektion 2 - Datenklassen\nZustzlich zu normalen Klassen bietet Kotlin auch die Mglichkeit Klassen zu erstellen, die nur die Aufgabe der Speicherung von Daten haben. Auf den ersten Blick knnte dies auch mit normalen Klassen bewerkstelligt werden. Jedoch mssen dann alle Methoden, die eine Datenklasse in der Regel bentigt, per Hand implementiert werden. Beispiele dafr sind `toString()` oder `equals()`. Um dem aus dem Weg zu gehen, gibt es Datenklassen. Fr diese generiert der Kotlin-Compiler im Hintergrund folgende Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Gekennzeichnet werden Datenklassen mit dem Schlsselwort `data class`."
    },
    {
     "start_checkpoint": 1622210381391,
     "parent": "n.0.116",
     "markdown": "## Lektion 2 - Datenklassen\nZustzlich zu normalen Klassen bietet Kotlin auch die Mglichkeit Klassen zu erstellen, die nur die Aufgabe der Speicherung von Daten haben. Auf den ersten Blick knnte dies auch mit normalen Klassen bewerkstelligt werden. Jedoch mssen dann alle Methoden, die eine Datenklasse in der Regel bentigt, per Hand implementiert werden. Beispiele dafr sind `toString()` oder `equals()`. Um dem aus dem Weg zu gehen, gibt es Datenklassen. Fr diese generiert der Kotlin-Compiler im Hintergrund folgende Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Gekennzeichnet werden Datenklassen mit dem Schlsselwort `data class`. Alle Felder, die bei den generierten Methoden bercksichtigt werden sollen, mssen in dem Kopf der Datenklasse angegeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.21",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Durch die Verwendung der `componentN()`-Methode kann auf mehrere Felder der Datenklasse zugeggriffen werden. Dabei bekommt jedes Feld eine eigene Nummer, beispielsweise x die Nummer 1, zugewisen. Wird `N` durch die Nummer ersetzt und auf dem Objekt aufgerufen, wird das Feld zurckgegeben. Auch knnen dadurch mehrere Felder abgerufen werden, indem eine Folge als Rckgabe erwartet wird."
    },
    {
     "start_checkpoint": 1622209870934,
     "parent": "n.0.116",
     "markdown": "Durch die Verwendung der `componentN()`-Methode kann auf die Felder der Datenklasse zugeggriffen werden. Dabei bekommt jedes Feld eine eigene Nummer, beispielsweise in der Klasse 'Punkt' 'x' die Nummer 1, zugewisen. Wird `N` durch die Nummer ersetzt und auf einem Objekt aufgerufen, wird das Feld zugehrige zurckgegeben. Auch knnen dadurch mehrere Felder abgerufen werden, indem eine Folge als Rckgabe erwartet wird."
    }
   ]
  },
  {
   "artifact_name": "m.22",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Mit Hilfe von `copy()` kann ein neues Objekt mit den gleichen Daten erzeugt werden. Sollen bestimmte Felder aber einen anderen Wert bekommen, kann dies der Methode mit Namen des Feldes und dem gewnschten Wert bergeben werden."
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.116",
     "markdown": "Mit Hilfe von `copy()` kann ein neues Objekt mit den gleichen Daten erzeugt werden. Soll aber bestimmten Feldern einen anderer Wert zugewiesen werden, kann dies der Methode mit Namen des Feldes und dem gewnschten Wert bergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.23",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Zustzlich knnen auch weitere Felder in der Datenklasse hinzugefgt werden. Diese werden jedoch nicht bei den automatisch generierten Methoden bercksichtigt. Auerdem darf der primre Konstruktor keine Parameter besitzen. Somit knnen die eigens erstellten Felder in der Klasse nur berechnet und nicht mit einem Parameter gefllt werden."
    },
    {
     "start_checkpoint": 1622210205883,
     "parent": "n.0.57",
     "markdown": "Zustzlich knnen auch weitere Felder in den Rumpf einer Datenklasse hinzugefgt werden. Diese werden jedoch nicht bei den automatisch generierten Methoden bercksichtigt. Auerdem darf der primre Konstruktor keine Parameter besitzen. Somit knnen die eigens erstellten Felder in der Klasse nur berechnet und nicht mit einem Parameter gefllt werden."
    },
    {
     "start_checkpoint": 1622210381391,
     "parent": "n.0.121",
     "markdown": "Zustzlich knnen auch weitere Felder in den Rumpf einer Datenklasse definiert werden. Diese werden jedoch nicht bei den automatisch generierten Methoden bercksichtigt. Auerdem darf der primre Konstruktor einer Datenklasse keine *freien* Parameter besitzen. Es wird nur der Defaultkonstruktor untersttzt. Somit knnen die eigens erstellten Felder im Rumpf der Klasse nur berechnet und nicht mit einem Parameter gefllt werden."
    }
   ]
  },
  {
   "artifact_name": "m.24",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.24",
     "markdown": "### Aufgabe - TODO"
    }
   ]
  },
  {
   "artifact_name": "m.25",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "## Lektion 3 - Objekte\nEine Besonderheit von Kotlin ist, dass nicht jedes Objekt eine Klasse bentigt. Dadurch kann beispielsweise ein statisches Feld simuliert werden oder unkompliziert mehrere Daten an einem Ort zusammengefasst werden.\n### Ad-hoc Objekte\nMit sogeannten Ad-hoc Objekten knnen Daten hnlich einer Map komprimiert werden. Es kann ein Objekt erzeugt werden ohne vorher eine Klasse angelegt zu haben. Dies ist mit dem Schlsselwort `object` einzuleiten. Wie auch einer Klasse knnen dem Ad-hoch Objekt Felder zugewiesen werden."
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.116",
     "markdown": "## Lektion 3 - Objekte\nEine Besonderheit von Kotlin ist, dass nicht jedes Objekt eine Klasse bentigt. Dadurch kann beispielsweise ein statisches Feld simuliert oder unkompliziert mehrere Daten an einem Ort zusammengefasst werden.\n### Ad-hoc Objekte\nMit sogeannten Ad-hoc Objekten knnen Daten hnlich einer Map komprimiert werden. Es kann ein Objekt erzeugt werden ohne vorher eine Klasse angelegt zu haben. Dies ist mit dem Schlsselwort `object` einzuleiten. Wie auch einer Klasse knnen dem Ad-hoch Objekt Felder zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.26",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "### Singletons\nSingletons sind Objekte, die nur ein Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Ein solches Objekt wird mit dem Schlsselwort `object` gekennzeichnet und kann nicht einer Variable zugewiesen werden, da es erst bei der ersten Benutzung erzeugt wird. Deswegen kann es auch nicht erzeugt werden. Dies wird automatisch beim ersten Aufruf, der in der Punktnotation mit dem Namen des Singletons erfolgt. Ein Singleton kann aus Feldern und Methoden bestehen. Ein Konstruktor kann jedoch nicht angewendet werden, da die Erzeugung ohne bergabeparameter stattfindet."
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.116",
     "markdown": "### Singletons\nSingletons sind Objekte, die nur ein Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Ein solches Objekt wird mit dem Schlsselwort `object` gekennzeichnet und kann nicht einer Variable zugewiesen werden, da es erst bei der ersten Benutzung erzeugt wird. Deswegen kann es auch nicht erzeugt werden. Die Erzeugung erfolgt automatisch beim ersten Aufruf, der in der Punktnotation mit dem Namen des Singletons erfolgt. Ein Singleton kann aus Feldern und Methoden bestehen. Ein Konstruktor kann jedoch nicht angewendet werden, da die Erzeugung ohne bergabeparameter stattfindet."
    }
   ]
  },
  {
   "artifact_name": "m.27",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.8",
     "markdown": "### Companion Objekte\nEiner Klasse knnen sogenannte Companion Objekte angehngt werden. Diese sind fr alle Objekte der Klasse gleich und hneln somit statischen Variablen oder Methoden. Sie knnen nur in einer Klasse implementiert werden und besitzen das Schlsselwort `companion object`. Im Hintergrund ist ein solches Konstrukt nichts weiter als ein Singleton einer Klasse das alle Objekte verwenden knnen. In dem Objekt knnen Felder und Methoden implementiert werden."
    }
   ]
  },
  {
   "artifact_name": "m.28",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "n.0.47",
     "markdown": "Falls in einer Klasse mehrere Companion Objekte gewnscht sind, ist ab dem Zweiten das Schlsselwort `companion` wegzulassen und auerdem ein Name anzugeben. Auerhalb der Klasse kann auf das Objekt nur durch die Klasse und nicht einem Objekt der Klasse zugegriffen werden."
    },
    {
     "start_checkpoint": 1622211105740,
     "parent": "n.0.116",
     "markdown": "Falls in einer Klasse mehrere Companion Objekte gewnscht werden, ist ab dem Zweiten das Schlsselwort `companion` wegzulassen und auerdem ein Name anzugeben. Auerhalb der Klasse kann auf das Objekt nur durch die Klasse und nicht einem Objekt der Klasse zugegriffen werden."
    }
   ]
  },
  {
   "artifact_name": "m.29",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.24",
     "markdown": "### Aufgabe\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz reprsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Lnge 5 verwirklicht werden. Ist ein Parkplatz belegt, so soll an diesem Eintrag `true` stehen. Benutzen Sie passende Sichtbarkeiten. Standardmig wird bei Erzeugung eine passendes Liste bergeben. Falls kein Parameter bergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zustzlich eine Methode `einparken()` die die Nummer des Parkplatzes bergeben bekommt und diesen belegt falls mglich. Bei Erfolg soll `true` zurckgegebn werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter bergeben werden. berschreiben Sie zustzlich die Methode `toString()`, die den Parkplatz bersichtlich nach folgendem Muster ausgegeben soll: <br />\n<p>--x-- (Parkplatz Nummer 2 ist belegt)</p>"
    }
   ]
  },
  {
   "artifact_name": "m.30",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.47",
     "markdown": "### Companion Objekte\nEiner Klasse knnen sogenannte Companion Objekte angehngt werden. Diese sind fr alle Objekte der Klasse gleich und hneln somit statischen Variablen oder Methoden. Sie knnen nur in einer Klasse implementiert werden und besitzen das Schlsselwort `companion object`. Im Hintergrund ist ein solches Konstrukt nichts weiter als ein Singleton einer Klasse das alle Objekte verwenden knnen. In dem Objekt knnen Felder und Methoden implementiert werden.<br />\nAnstelle eines Companion Objects knnte auch eine Top-Level-Variable verwendet werden. Jedoch lge dort kein Zusammenhang zwischen den Klassen vor und die Variable knnte auch von anderen Objekten verndert werden."
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.63",
     "markdown": "### Companion Objekte\nEiner Klasse knnen sogenannte Companion Objekte angehngt werden. Diese sind fr alle Objekte der Klasse gleich und hneln somit statischen Variablen oder Methoden. Sie knnen nur in einer Klasse implementiert werden und besitzen das Schlsselwort `companion object`. Im Hintergrund ist ein solches Konstrukt nichts weiter als ein Singleton einer Klasse, das alle Objekte verwenden knnen. In dem Objekt knnen Felder und Methoden implementiert werden.<br />\nAnstelle eines Companion Objects knnte auch eine Top-Level-Variable verwendet werden. Jedoch lge dort kein Zusammenhang zwischen den Klassen vor und die Variable knnte auch von anderen Objekten verndert werden."
    },
    {
     "start_checkpoint": 1622211105740,
     "parent": "n.0.121",
     "markdown": "### Companion Objekte\nEiner Klasse knnen sogenannte Companion Objekte angehngt werden. Diese sind fr alle Objekte der Klasse gleich und hneln somit statischen Variablen oder Methoden. Sie knnen nur in einer Klasse implementiert werden und besitzen das Schlsselwort `companion object`. Im Hintergrund ist ein solches Konstrukt nichts weiter als ein Singleton einer Klasse, das alle Objekte verwenden knnen. In dem Objekt knnen Felder und Methoden implementiert werden.  \nAnstelle eines Companion Objects knnte auch eine Top-Level-Variable verwendet werden. Jedoch lge dort kein Zusammenhang zwischen den Klassen vor und die Variable knnte auch von anderen Objekten verndert werden."
    }
   ]
  },
  {
   "artifact_name": "m.31",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.65",
     "markdown": "## Lektion 4 - Enumeration\nMit Hilfe einer Enumeration kann ein eigener limitierter Datentyp erstellt werden, der nur gewisse Werte annehmen kann. Der Klasse wird dann das Schlsselwort `enum` vorrangestellt. Soll ein Wert des Enums verwendet werden, muss der Name der Enumeration zustzlich angegeben werden."
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.116",
     "markdown": "## Lektion 4 - Enumeration\nMit Hilfe einer Enumeration kann ein eigener, limitierter Datentyp erstellt werden, der nur vordefinierte Werte annehmen kann. Der Klasse wird dafr das Schlsselwort `enum` vorrangestellt. Soll ein Wert des Enums verwendet werden, muss zustzlich der Name der Enumeration angegeben werden."
    },
    {
     "start_checkpoint": 1622312494538,
     "parent": "n.0.116",
     "markdown": "## Lektion 4 - Aufzhlung\nMit Hilfe einer Enumeration kann ein eigener, limitierter Datentyp erstellt werden, der nur vordefinierte Werte annehmen kann. Der Klasse wird dafr das Schlsselwort `enum` vorrangestellt. Soll ein Wert des Enums verwendet werden, muss zustzlich der Name der Enumeration angegeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.32",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.65",
     "markdown": "Auf alle mglichen Werte eines Enums kann mit `values()` zugegriffen werden. Zurckgegeben wird ein Array. Soll auf das Enum-Objekt eines Strings zugegriffen werden, kann dies mit `valueOf()` mit dem String als Parameter, bewerkstelligt werden. Wird kein passendes Element gefunden, wird eine `IllegalArgumentException` geworfen."
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "n.0.65",
     "markdown": "Auf alle mglichen Werte eines Enums kann mit `values()` zugegriffen werden. Zurckgegeben wird ein Array. Soll auf das Enum-Objekt eines Strings zugegriffen werden, kann dies mit `valueOf()` und dem String als Parameter, bewerkstelligt werden. Wird kein passendes Element gefunden, wird eine `IllegalArgumentException` geworfen."
    },
    {
     "start_checkpoint": 1622285770045,
     "parent": "n.0.66",
     "markdown": "Auf alle mglichen Werte eines Enums kann mit `values()` zugegriffen werden. Zurckgegeben wird ein Array. Soll auf das Enum-Objekt eines Strings zugegriffen werden, ist dies mit `valueOf()` und dem String als Parameter mglich. Wird kein passendes Element gefunden, wird eine `IllegalArgumentException` geworfen."
    },
    {
     "start_checkpoint": 1622285787057,
     "parent": "n.0.121",
     "markdown": "Auf alle mglichen Werte eines Enums kann mit `values()` zugegriffen werden. Zurckgegeben wird ein Array. Soll auf das Enum-Objekt eines Strings zugegriffen werden, ist dies mit `valueOf()` und dem String als Parameter mglich. Wird kein passendes Element gefunden, ist das Ergebnis eine `IllegalArgumentException`."
    }
   ]
  },
  {
   "artifact_name": "m.33",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.65",
     "markdown": "Da Enums als vollstndige Klassen angesehen werden, knnen ihnen Felder und sogar Methoden hinzugefgt werden. Sollen Felder mit einem bestimmten Wert der von dem Wert des Enums anhngt gefllt werden, kann hinter dem Wert des Enums die Werte fr den Konstruktor bergeben werden."
    },
    {
     "start_checkpoint": 1622285787057,
     "parent": "n.0.116",
     "markdown": "Da Enums als vollstndige Klassen angesehen werden, knnen ihnen Felder und sogar Methoden hinzugefgt werden. Sollen Felder mit einem bestimmten Wert, der von dem Wert des Enums abhngt, gefllt werden, kann hinter dem Wert des Enums die Parameter des Konstruktors bergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.34",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "markdown": "## Lektion 5 - Vererbung"
    },
    {
     "start_checkpoint": 1619345085096,
     "parent": "n.0.65",
     "markdown": "## Lektion 5 - Vererbung\nIn Kotlin kann nicht von einer beliebigen Klasse geerbt werden. Diese muss als Vorraussetzung den Vorsatz `open` besitzen. Dies signaliesiert, dass eine Vererbung stattfinden darf. Der Namen der Klasse, von der geerbt werden soll, ist mit einem `:` getrennt hinter den Parameterklammern der erbenden Klasse zu schreiben. Dem Konstruktor der super-Klasse werden die Parameter direkt im Kopf der Klasse bergeben. "
    },
    {
     "start_checkpoint": 1622286007574,
     "parent": "n.0.116",
     "markdown": "## Lektion 5 - Vererbung\nIn Kotlin kann nicht von einer beliebigen Klasse geerbt werden. Diese muss als Voraussetzung den Vorsatz `open` besitzen. Dadurch wird signalisiert, dass eine Vererbung stattfinden darf. Der Namen der Klasse, von der geerbt werden soll, ist mit einem `:` getrennt hinter den Parameterklammern der erbenden Klasse zu schreiben. Dem Konstruktor der Super-Klasse werden die Parameter direkt im Kopf der Klasse bergeben. "
    }
   ]
  },
  {
   "artifact_name": "m.35",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "markdown": "## Lektion 6 - Schnittstellen"
    }
   ]
  },
  {
   "artifact_name": "m.36",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.11",
     "markdown": "## Lektion 7 - Generizitt"
    }
   ]
  },
  {
   "artifact_name": "m.37",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "n.0.24",
     "markdown": "## Lektion 8 - Fehlerbehandlung"
    }
   ]
  },
  {
   "artifact_name": "m.38",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.22",
     "markdown": "sealed class Expr\ndata class Const(val number: Double) : Expr()\ndata class Sum(val e1: Expr, val e2: Expr) : Expr()\nobject NotANumber : Expr()# Abschnitt 3\nThema dieses Abschnittes wird die objektorientierte Programmierung sein.\n\n## Lektion 1 - Klassen\nAufgrund der Kompatibilitt mit Java ist auch Kotlin eine objektorientierte Sprache. Deswegen werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind alle bekannten objektorientierte Konzepte vorhanden, jedoch angepasst und teilweise auch vereinfacht. Dazu ein Einfhrungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1619427699980,
     "parent": "n.0.25",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes wird die objektorientierte Programmierung sein.\n\n## Lektion 1 - Klassen\nAufgrund der Kompatibilitt mit Java ist auch Kotlin eine objektorientierte Sprache. Deswegen werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind alle bekannten objektorientierte Konzepte vorhanden, jedoch angepasst und teilweise auch vereinfacht. Dazu ein Einfhrungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622203932351,
     "parent": "n.0.26",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilitt mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einfhrungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Kotlin</th>\n    <th>Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td><code>class Person (val name: String, var alter: Int)</code></td>\n    <td><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622203944610,
     "parent": "n.0.116",
     "markdown": "# Abschnitt 3\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilitt mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einfhrungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622312964703,
     "parent": "n.0.118",
     "markdown": "<img src=\"images/Abschnitt3.png\" style=\"margin-left: auto; margin-right: auto; display: block; margin-bottom: 20px\"/>\n<h1 style=\"display:none\">Abschnitt 2 - Funktionale Programmierung</h1>\n\n<img src=\"images/Einfhrung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h2 style=\"display:none\">Einfhrung</h2>\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilitt mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einfhrungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622313227273,
     "parent": "n.0.119",
     "markdown": "<img src=\"asimages/Abschnitt3.png\" style=\"margin-left: auto; margin-right: auto; display: block; margin-bottom: 20px\"/>\n<h1 style=\"display:none\">Abschnitt 2 - Funktionale Programmierung</h1>\n\n<img src=\"images/Einfhrung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h2 style=\"display:none\">Einfhrung</h2>\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilitt mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einfhrungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622313230222,
     "parent": "n.0.120",
     "markdown": "<img src=\"images/Abschnitt3.png\" style=\"margin-left: auto; margin-right: auto; display: block; margin-bottom: 20px\"/>\n<h1 style=\"display:none\">Abschnitt 2 - Funktionale Programmierung</h1>\n\n<img src=\"images/Einfhrung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h2 style=\"display:none\">Einfhrung</h2>\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n## Lektion 1 - Klassen\nAufgrund der Interoperabilitt mit Java ist auch Kotlin eine objektorientierte Sprache. Als Folge werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierte Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einfhrungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.39",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Felder und Methoden berschreiben\nSollen Felder oder Methoden der super-Klasse in der sub-Klasse berschrieben werden, mssen diese auch mit `open` gekennzeichnet werden. Erst dann ist es mglich das gleiche Feld oder die gleiche Methode in der sub-Klasse mit dem Zusatz `override` zu definieren. Soll auf das Feld oder die Methode der Oberklasse zugegriffen werden, findet das Schlsselwort `super` Anwendung. Bei Mehrfachvererbung wird die nchst hhere Klasse angesprochen."
    },
    {
     "start_checkpoint": 1622286066819,
     "parent": "n.0.69",
     "markdown": "### Felder und Methoden berschreiben\nSollen Felder oder Methoden der Super-Klasse in der Sub-Klasse berschrieben werden, mssen diese auch mit `open` gekennzeichnet werden. Erst dann ist es mglich das gleiche Feld oder die gleiche Methode in der sub-Klasse mit dem Zusatz `override` zu definieren. Soll auf das Feld oder die Methode der Oberklasse zugegriffen werden, findet das Schlsselwort `super` Anwendung. Bei Mehrfachvererbung wird die nchst hhere Klasse angesprochen."
    },
    {
     "start_checkpoint": 1622286097813,
     "parent": "n.0.116",
     "markdown": "### Felder und Methoden berschreiben\nSollen Felder oder Methoden der Super-Klasse in der Sub-Klasse berschrieben werden, mssen diese ebenfalls mit `open` gekennzeichnet werden. Erst dann ist es mglich das gleiche Feld oder die gleiche Methode in der sub-Klasse mit dem Zusatz `override` zu definieren. Soll auf das Feld oder die Methode der Oberklasse zugegriffen werden, findet das Schlsselwort `super` Anwendung. Bei Mehrfachvererbung wird die nchst hhere Klasse angesprochen."
    }
   ]
  },
  {
   "artifact_name": "m.40",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Sekundre Konstruktoren\nWir sind bis jetzt von dem einfachen Fall ausgegangen, dass die Unterklasse einen primren Konstruktor besitzt. Jedoch gibt es auch die Mglichkeit diese nut mit sekunren Konstruktoren auszustatten. Diese mssen jedoch immer den primren Konstruktor der Oberklasse aufrufen."
    },
    {
     "start_checkpoint": 1622286553284,
     "parent": "n.0.121",
     "markdown": "### Sekundre Konstruktoren\nWir sind bis jetzt von dem einfachen Fall ausgegangen, dass die Unterklasse einen primren Konstruktor besitzt. Jedoch gibt es auch die Mglichkeit diese nur mit sekundren Konstruktoren auszustatten. Diese mssen immer den primren Konstruktor der Oberklasse aufrufen."
    }
   ]
  },
  {
   "artifact_name": "m.41",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abtrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Mglichkeit unintiierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlsselwort `abstract` vorangestellt und knnen ohne Probleme geerbt werden. Die Subklassen mssen jedoch die Methoden vervollstndigen."
    },
    {
     "start_checkpoint": 1622286553284,
     "parent": "n.0.72",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Mglichkeit unintiierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlsselwort `abstract` vorangestellt und knnen ohne Probleme geerbt werden. Die Subklassen mssen jedoch die Methoden vervollstndigen."
    },
    {
     "start_checkpoint": 1622286762980,
     "parent": "n.0.73",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Mglichkeit uninitierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlsselwort `abstract` vorangestellt und knnen ohne Probleme geerbt werden. Die Subklassen mssen jedoch die Methoden vervollstndigen."
    },
    {
     "start_checkpoint": 1622286789527,
     "parent": "n.0.74",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Mglichkeit uninitierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlsselwort `abstract` vorangestellt knnen ohne Probleme vererbt werden. Die Subklassen mssen jedoch die Methoden vervollstndigen."
    },
    {
     "start_checkpoint": 1622286800210,
     "parent": "n.0.116",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Mglichkeit uninitierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlsselwort `abstract` vorangestellt knnen ohne Probleme vererbt werden. Die Sub-Klassen mssen jedoch die Methoden vervollstndigen."
    }
   ]
  },
  {
   "artifact_name": "m.42",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.24",
     "markdown": "### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlsselwort `sealed` vorangestellt und sie besitzt einen privaten Konstruktor. Auerdem darf von der Klasse nur in der Datei geerbt werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweifung der default-Fall weggelassen werden."
    }
   ]
  },
  {
   "artifact_name": "m.43",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "## Lektion 6 - Schnittstellen\nEin wichtiges objektorientiertes Konzept ist das der Schnittstelle. Ein bekanntes Beispiel ist hier das `Comparable`-Interface, das eine `compareTo()`-Methode vorschreibt. Aber anstelle des Vorschreibens von Methoden knnen auch Zugriffe definiert werden. Eine Schnittstelle hat das Schlsselwort `interface` und wird bei der implementierenden Klasse hnlich zur Vererbung angegeben. In einem Interface knnen sowohl Methoden voll implementiert oder nur deren Kopf angegeben werden, sodass diese von jeder Klasse selbst vervollstndigt werden muss. Auerdem knnen sie auch Felder beinhalten.\nKotlin bietet bereits einige vorimplementierte Schnittstellen an:\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>"
    },
    {
     "start_checkpoint": 1622289820200,
     "parent": "n.0.116",
     "markdown": "## Lektion 6 - Schnittstellen\nEin wichtiges objektorientiertes Konzept ist das der Schnittstelle. Ein bekanntes Beispiel das `Comparable`-Interface, das eine `compareTo()`-Methode voraussetzt. Aber anstelle des Vorschreibens von Methoden knnen auch Zugriffe definiert werden. Eine Schnittstelle besitzt das Schlsselwort `interface` und wird bei der implementierenden Klasse hnlich zum Erben angegeben. In einem Interface knnen sowohl Methoden voll implementiert oder nur deren Kopf angegeben werden, sodass diese von jeder Klasse selbst vervollstndigt werden mssen. Auerdem knnen sie auch Felder beinhalten.\nKotlin bietet bereits einige vorgefertigte Schnittstellen an:\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.44",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "## Lektion 7 - Generizitt\n### Generische Klassen\nBei manchen Softwareprojekten kommt man um generische Klassen nicht vorbei, falls mehrfache Arbeit vermieden werden soll. An sich unterscheiden sich die Unterschiede von solchen Klassen in Kotlin und Java nicht. Der generische Datentyp wird nach dem Klassennamen in `<>` angegeben und kann in der Klasse anstelle normalen Datentypen eingesetzt werden."
    },
    {
     "start_checkpoint": 1622289820200,
     "parent": "n.0.80",
     "markdown": "## Lektion 7 - Generizitt\n### Generische Klassen\nBei manchen Softwareprojekten kommt man an generischen Klassen nicht vorbei, falls mehrfache Arbeit vermieden werden soll. An sich unterscheiden sich die Unterschiede von solchen Klassen in Kotlin und Java nicht. Der generische Datentyp wird nach dem Klassennamen in `<>` angegeben und kann in der Klasse anstelle normalen Datentypen eingesetzt werden."
    },
    {
     "start_checkpoint": 1622290018952,
     "parent": "n.0.116",
     "markdown": "## Lektion 7 - Generizitt\n### Generische Klassen\nBei manchen Softwareprojekten kommt man an generischen Klassen nicht vorbei, falls mehrfache Arbeit vermieden werden soll. Das Konzept an sich unterscheidet sich in Kotlin und Java nicht. Der generische Datentyp wird nach dem Klassennamen in `<>` angegeben und kann in der Klasse anstelle normalen Datentypen eingesetzt werden."
    }
   ]
  },
  {
   "artifact_name": "m.45",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.116",
     "markdown": "Soll der generische Datentyp eingeschrnkt werden, kann dies durch ein Interface passieren. Dieses gibt vor welche Methoden der Datentyp implementieren muss."
    }
   ]
  },
  {
   "artifact_name": "m.46",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Generische Funktionen\nGenerizitt findet aber nicht nur bei Klassen, sondern auch bei Funktionen Anwendung. Jedoch wird hier der generische Typ vor dem Namen der Funktion angegeben. Bei Aufruf der Methode muss der Typ nicht angegeben werden, sondern wird vom Kompiler erkannt."
    },
    {
     "start_checkpoint": 1622290018952,
     "parent": "n.0.121",
     "markdown": "### Generische Funktionen\nGenerizitt findet aber nicht nur bei Klassen, sondern auch bei Funktionen Anwendung. Jedoch wird hier der generische Typ vor dem Namen der Funktion angegeben. Bei Aufruf der Methode muss der Typ nicht angegeben werden, sondern wird vom Compiler erkannt."
    }
   ]
  },
  {
   "artifact_name": "m.47",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "n.0.65",
     "markdown": "### Generische Erweiterungsfunktionen\nErweiterungsfunktionen einer bestimmten Klasse wurden bereits in Abschnitt 1 kennengelernt. Dieses Konzept kann aber auch auf generische Klassen bertragen werden. So knnen beispielsweise einer generischen Liste neue Methoden hinzugefgt werden."
    },
    {
     "start_checkpoint": 1622290018952,
     "parent": "n.0.81",
     "markdown": "### Generische Erweiterungsmethoden\nErweiterungsmethoden einer bestimmten Klasse wurden bereits in Abschnitt 1 kennengelernt. Dieses Konzept kann aber auch auf generische Klassen bertragen werden. So knnen beispielsweise einer generischen Liste neue Methoden hinzugefgt werden."
    },
    {
     "start_checkpoint": 1622290123775,
     "parent": "n.0.116",
     "markdown": "### Generische Erweiterungsmethoden\nDas Konzept und die Implementierung von Erweiterungsmethoden wurden bereits in Abschnitt 1 kennengelernt. Es kann aber auch auf generische Klassen bertragen werden. So knnen beispielsweise einer generischen Liste neue Methoden hinzugefgt werden."
    }
   ]
  },
  {
   "artifact_name": "m.48",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.25",
     "markdown": "Es ist zu erkennen, dass der Kotlincode deutlich krzer und bersichtlicher ist. <br />\nDer Kopf einer Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von dem Namen. Die Parameter werden nach diesem in runden Klammern angegeben. Erzeugt werden kann die Klasse wie aus Java gewohnt mit der Nennung der Name der Klasse sowie dem Aufruf eines Konstruktors. In den runden Klammern sind die erforderlichen Argumente fr die Objekterzeugung zu finden.\n\n### Felder\nFelder knnen Klassen einfach Hinzugefgt werden. Die erste Mglichkeit ist durch die bergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei ffentlicher Sichtbarkeit eine Variablenart (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heit es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, welches bei Objekterzeugung mit dem Wert des bergabeparameters gefllt wird. Auerdem wird immer ein unsichtbarer Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, wird zustzlich ein rudimentrer Setter der Klasse hinzugefgt."
    },
    {
     "start_checkpoint": 1622204008193,
     "parent": "n.0.28",
     "markdown": "Es ist zu erkennen, dass der Code in Kotlin deutlich krzer und bersichtlicher ist.  \nDer Kopf einer Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von dem Namen. Die Parameter werden nach diesem in runden Klammern angegeben. Erzeugt werden kann die Klasse, wie aus Java gewohnt, mit der Nennung des Namens der Klasse sowie dem Aufruf eines Konstruktors. In den runden Klammern sind die erforderlichen Argumente fr die Objekterzeugung zu finden.\n\n### Felder\nFelder knnen Klassen auf verschiedene Weise hinzugefgt werden. Die erste Mglichkeit ist durch die bergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei ffentlicher Sichtbarkeit eine Variablenart (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heit es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, welches bei Objekterzeugung mit dem Wert des bergabeparameters gefllt wird. Auerdem wird immer ein unsichtbarer Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, wird zustzlich ein rudimentrer Setter der Klasse hinzugefgt."
    },
    {
     "start_checkpoint": 1622204182191,
     "parent": "n.0.116",
     "markdown": "Es ist zu erkennen, dass der Code in Kotlin deutlich krzer und bersichtlicher ist.  \nDer Kopf einer Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von dem Namen. Die Parameter werden nach diesem in runden Klammern angegeben. Erzeugt werden kann die Klasse, wie aus Java gewohnt, mit der Nennung des Namens der Klasse sowie dem Aufruf eines Konstruktors. In den runden Klammern sind die erforderlichen Argumente fr die Objekterzeugung zu finden.\n\n### Felder\nFelder knnen Klassen auf verschiedene Weise hinzugefgt werden. Die erste Mglichkeit ist durch die bergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei ffentlicher Sichtbarkeit ein Variablentyp (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heit, es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, das bei Objekterzeugung mit dem Wert des bergabeparameters gefllt wird. Auerdem wird immer ein *unsichtbarer* Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, fgt der Compiler zustzlich einen rudimentren Setter hinzu."
    }
   ]
  },
  {
   "artifact_name": "m.49",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.25",
     "markdown": "### Aufgabe - Pizza-Klasse\nImplementieren Sie eine Klasse `Pizza`. Jede Pizza soll eine Gre `groee` (zwischen 15 und 30 [cm], ansonsten -1) und eine Liste aus Belgen `belaege` (Standardmig bereits mit Tomatensoe und Kse befllt) enthalten. Auerdem soll gespeichert werden, ob sie geschnitten `geschnitten` werden soll. Whlen Sie einen passenden primren Konstruktor, der fr jedes Feld einen bergabeparameter besitzt. Fgen Sie auerdem weitere (sekundre) Konstruktoren hinzu, die eine Pizza Magaritha (Tomatensoe, Mozzarella) und eine 25cm Pizza al Tonno (Tomatensoe, Mozzarella, Thunfisch, Zwiebeln, Peperoni) initialisieren. Beide Pizzas sollen geschnitten werden."
    },
    {
     "start_checkpoint": 1622205474347,
     "parent": "n.0.121",
     "markdown": "### Aufgabe - Pizza-Klasse\nImplementieren Sie eine Klasse `Pizza`. Jede Pizza soll eine Gre `groee` (zwischen 15 und 30 [cm], ansonsten -1) und eine Liste aus Belgen `belaege` (Standardmig bereits mit Tomatensoe und Kse befllt) enthalten. Auerdem soll gespeichert werden, ob sie geschnitten `geschnitten` werden soll. Whlen Sie einen passenden primren Konstruktor, der fr jedes Feld einen bergabeparameter besitzt. Fgen Sie auerdem weitere (sekundre) Konstruktoren hinzu, die eine Pizza Magaritha (Tomatensoe, Mozzarella) und eine 25cm Pizza al Tonno (Tomatensoe, Mozzarella, Thunfisch, Zwiebeln, Peperoni) initialisieren. Beide Pizzen sollen geschnitten werden."
    }
   ]
  },
  {
   "artifact_name": "m.50",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.47",
     "markdown": "### Aufgabe - Parkplatzverwaltung\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz reprsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Lnge 5 verwirklicht werden. Ist ein Parkplatz belegt, so soll an diesem Eintrag `true` stehen. Benutzen Sie passende Sichtbarkeiten. Standardmig wird bei Erzeugung eine passendes Liste bergeben. Falls kein Parameter bergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zustzlich eine Methode `einparken()` die die Nummer des Parkplatzes bergeben bekommt und diesen belegt falls mglich. Bei Erfolg soll `true` zurckgegebn werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter bergeben werden. berschreiben Sie zustzlich die Methode `toString()`, die den Parkplatz bersichtlich nach folgendem Muster ausgegeben soll: <br />\n<p>--x-- (Parkplatz Nummer 2 ist belegt)</p>"
    },
    {
     "start_checkpoint": 1622209719335,
     "parent": "n.0.53",
     "markdown": "### Aufgabe - Parkplatzverwaltung\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz reprsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Lnge 5 verwirklicht werden, der als Feld reprsentiert wird. Ist ein Parkplatz belegt, so soll an diesem Eintrag `true` stehen. Benutzen Sie passende Sichtbarkeiten. Standardmig wird bei Erzeugung eine passendes Liste bergeben. Falls kein Parameter bergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zustzlich eine Methode `einparken()` die die Nummer des Parkplatzes bergeben bekommt und diesen belegt falls mglich. Bei Erfolg soll `true` zurckgegebn werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter bergeben werden. berschreiben Sie zustzlich die Methode `toString()`, die den Parkplatz bersichtlich nach folgendem Muster ausgegeben soll: <br />\n<p>--x-- (Parkplatz Nummer 2 ist belegt)</p>"
    },
    {
     "start_checkpoint": 1622209870934,
     "parent": "n.0.116",
     "markdown": "### Aufgabe - Parkplatzverwaltung\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz reprsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Lnge 5 verwirklicht werden, der als Feld reprsentiert wird. Ist ein Parkplatz belegt, so soll dieser Eintrag `true` sein. Verwenden Sie passende Sichtbarkeiten.  \nStandardmig wird bei Erzeugung eine passende Liste bergeben. Falls kein Parameter bergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zustzlich eine Methode `einparken()` der die Nummer des Parkplatzes bergeben wird und diesen falls mglich belegt. Bei Erfolg soll `true` zurckgegeben werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter bergeben werden. berschreiben Sie zustzlich die Methode `toString()`, die den Parkplatz bersichtlich nach folgendem Muster ausgegeben soll:  \n--x-- (Parkplatz Nummer 2 ist belegt)"
    }
   ]
  },
  {
   "artifact_name": "m.51",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.47",
     "markdown": "### Aufgabe - Abstnde\nIn dieser Aufgabe soll mit Hilfe von Datenklassen eine Verwaltung von Abstnden ermglicht werden. Dazu werden folgende Komponenten bentigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speicher\n* Eine Datenklasse `Abstand`, die primr den Wert des Abstands zweier Positionen speichert. Auerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.\n* Eine Funktion `berechneAbstand()` der zwei Positionen bergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefgt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefgt werden.  "
    },
    {
     "start_checkpoint": 1622210381391,
     "parent": "n.0.58",
     "markdown": "### Aufgabe - Abstnde\nIn dieser Aufgabe soll mit Hilfe von Datenklassen eine Verwaltung von Abstnden ermglicht werden. Dazu werden folgende Komponenten bentigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primr den Wert des Abstands zweier Positionen speichert. Auerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.\n* Eine Funktion `berechneAbstand()` der zwei Positionen bergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefgt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefgt werden.  "
    },
    {
     "start_checkpoint": 1622210510241,
     "parent": "n.0.59",
     "markdown": "### Aufgabe - Abstnde\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abstnden implementieren. Dazu werden folgende Komponenten bentigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primr den Wert des Abstands zweier Positionen speichert. Auerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.\n* Eine Funktion `berechneAbstand()` der zwei Positionen bergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefgt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefgt werden.  "
    },
    {
     "start_checkpoint": 1622210675867,
     "parent": "n.0.60",
     "markdown": "### Aufgabe - Abstnde\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abstnden implementieren. Dazu werden folgende Komponenten bentigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primr den Wert eines Abstands. Auerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.  \nBeispiel: Wert des Abstandes: 3, positionen: [(Position(0,0), Position(2,1)), (Position(0,3), Position(3,3)), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen bergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefgt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefgt werden. "
    },
    {
     "start_checkpoint": 1622210700458,
     "parent": "n.0.61",
     "markdown": "### Aufgabe - Abstnde\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abstnden implementieren. Dazu werden folgende Komponenten bentigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primr den Wert eines Abstands. Auerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.  \nBeispiel: `wert` des Abstandes: 3, Inhalt von `positionen`: [(Position(0,0), Position(2,1)), (Position(0,3), Position(3,3)), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen bergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefgt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefgt werden. "
    },
    {
     "start_checkpoint": 1622210723976,
     "parent": "n.0.62",
     "markdown": "### Aufgabe - Abstnde\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abstnden implementieren. Dazu werden folgende Komponenten bentigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primr den Wert eines Abstands. Auerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.  \nBeispiel: `wert` des Abstandes: 3, Inhalt von `positionen`: [( Position(0,0), Position(2,1) ), ( Position(0,3), Position(3,3) ), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen bergeben werden. Dort soll ihre [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) berechnet und der Abstand zur globale Liste `abstaende` hinzugefgt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch soll dem bereits vorhandenen Abstand die beiden Positionen in die Liste `positionen` hinzugefgt werden. "
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "n.0.116",
     "markdown": "### Aufgabe - Abstnde\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abstnden implementieren. Dazu werden folgende Komponenten bentigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primr den Wert eines Abstands. Auerdem soll in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die den Abstand besitzen.  \nBeispiel: `wert` des Abstandes: 3, Inhalt von `positionen`: [( Position(0,0), Position(2,1) ), ( Position(0,3), Position(3,3) ), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen bergeben werden. In ihrem Rumpf soll die [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) der beiden Punkte berechnet und der Abstand zur globale Liste `abstaende` hinzugefgt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch sollen die beiden Positionen dem bereits vorhandenen Abstand in die Liste `positionen` hinzugefgt werden. "
    }
   ]
  },
  {
   "artifact_name": "m.52",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "<div class=\"alert alert-block alert-danger\">\n<b>TODO</b> Sealed class und interface in kotlin 1.5.0 anschauen\n</div>\n\n### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlsselwort `sealed` vorangestellt und sie besitzt einen privaten Konstruktor. Von dieser darf nur in dem selben Paket oder der selben Kompiliereinheit geerbet werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweifung der default-Fall weggelassen werden."
    },
    {
     "start_checkpoint": 1622286800210,
     "parent": "n.0.75",
     "markdown": "<div class=\"alert alert-block alert-danger\">\n<b>TODO</b> Sealed class und interface in kotlin 1.5.0 anschauen\n</div>\n\n### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlsselwort `sealed` vorangestellt. Sie besitzt einen privaten Konstruktor. Von dieser darf nur in dem selben Paket oder der selben Kompiliereinheit geerbet werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweifung der default-Fall weggelassen werden."
    },
    {
     "start_checkpoint": 1622286910420,
     "parent": "n.0.116",
     "markdown": "<div class=\"alert alert-block alert-danger\">\n<b>TODO</b> Sealed class und interface in kotlin 1.5.0 anschauen\n</div>\n\n### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlsselwort `sealed` vorangestellt. Sie besitzt einen privaten Konstruktor. Von dieser darf nur in dem selben Paket oder der selben Kompiliereinheit geerbet werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweifung der *default*-Fall weggelassen werden."
    }
   ]
  },
  {
   "artifact_name": "m.53",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "## Lektion 8 - Fehlerbehandlung\nWhrend in Java zwischen Checked (die Mglichkeit eines Fehlers muss behandelt werden) und Unchecked Exceptions (mssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Exception diese vorbeugend zu behandeln.<br />\nMit `throw` knnen Exceptions selbst ausgelst werden. Auerdem kann ein solcher Ausdruck auch einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622290204256,
     "parent": "n.0.86",
     "markdown": "## Lektion 8 - Fehlerbehandlung\nWhrend in Java zwischen *checked* (die Mglichkeit eines Fehlers muss behandelt werden) und *unchecked Exceptions* (Fehler mssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Exception diese vorbeugend zu behandeln.<br />\nMit `throw` knnen Exceptions selbst ausgelst werden. Auerdem kann ein solcher Ausdruck auch einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622290261257,
     "parent": "n.0.87",
     "markdown": "## Lektion 8 - Fehlerbehandlung\nWhrend in Java zwischen *checked* (die Mglichkeit eines Fehlers muss behandelt werden) und *unchecked Exceptions* (Fehler mssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` knnen Exceptions selbst ausgelst werden. Auerdem kann ein solcher Ausdruck auch einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622290272824,
     "parent": "n.0.116",
     "markdown": "## Lektion 8 - Fehlerbehandlung\nWhrend in Java zwischen *checked* (die Mglichkeit eines Fehlers muss behandelt werden) und *unchecked Exceptions* (Fehler mssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` knnen Exceptions selbst ausgelst werden. Auerdem kann ein solcher Ausdruck einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622312896740,
     "parent": "n.0.117",
     "markdown": "## Lektion 8 - Ausnahmebehandlung\nWhrend in Java zwischen *checked* (die Mglichkeit eines Fehlers muss behandelt werden) und *unchecked Exceptions* (Fehler mssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` knnen Exceptions selbst ausgelst werden. Auerdem kann ein solcher Ausdruck einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622312964703,
     "parent": "n.0.118",
     "markdown": "## Lektion 8 - Ausnahmebehandlung\nWhrend in Java zwischen *checked* (die Mglichkeit einer Ausnahme muss behandelt werden) und *unchecked Exceptions* (Ausnahmen mssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` knnen Exceptions selbst ausgelst werden. Auerdem kann ein solcher Ausdruck einer Variable zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.54",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "Der `try and catch`-Block ist natrlich auch in Kotlin vorhanden. Aber auch hier kann das Ergebnis dieses Ausdrucks einer Variable zugewiesen werden. Der Syntax hnelt den der Lambda-Ausdcke."
    },
    {
     "start_checkpoint": 1622290408459,
     "parent": "n.0.93",
     "markdown": "Der `try and catch`-Block darf in Kotlin natrlich nicht fehlen. Wie bei einer Exception selbst kann auch hier das Ergebnis dieses Ausdrucks einer Variable zugewiesen werden. Der Syntax hnelt den der Lambda-Ausdcke."
    },
    {
     "start_checkpoint": 1622290479536,
     "parent": "n.0.94",
     "markdown": "Der `try and catch`-Block darf in Kotlin natrlich nicht fehlen. Wie bei einer Exception selbst kann auch hier das Ergebnis dieses Ausdrucks einer Variable zugewiesen werden."
    },
    {
     "start_checkpoint": 1622290607436,
     "parent": "n.0.121",
     "markdown": "Der `try & catch`-Block darf in Kotlin natrlich nicht fehlen. Wie bei einer Exception selbst kann auch hier das Ergebnis dieses Ausdrucks einer Variable zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.55",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "Soll nach der Ausfhrung einer der beiden Blcke Code ausgefrt werden, kann zustzlich ein `finaly`-Block verwendet werden. Der darin befindende Code wird immer am Ende ausgefhrt und eignet sich deshalb besonders fr Aufrumarbeiten. Falls ein solcher Block vorhanden ist, kann `catch` auch weggelassen werden.<br />\nEigene Exceptions knnen auch implemenitert werden. Dabei ist erforderlich, dass die Klasse von `Exception` erbt und die Fehlermeldung als String bergeben und an die Superklasse weitergibt."
    },
    {
     "start_checkpoint": 1622290655058,
     "parent": "n.0.101",
     "markdown": "Soll nach der Ausfhrung einer der beiden Blcke Code ausgefrt werden, kann zustzlich ein `finally`-Block verwendet werden. Der darin befindende Code wird immer am Ende ausgefhrt und eignet sich deshalb besonders fr Aufrumarbeiten. Falls ein solcher Block vorhanden ist, kann `catch` auch weggelassen werden.<br />\nEigene Exceptions knnen auch implemenitert werden. Dabei ist erforderlich, dass die Klasse von `Exception` erbt und die Fehlermeldung als String bergeben und an die Superklasse weitergibt."
    },
    {
     "start_checkpoint": 1622290741126,
     "parent": "n.0.116",
     "markdown": "Soll nach der Ausfhrung einer der beiden Blcke Code ausgefrt werden, kann zustzlich ein `finally`-Block verwendet werden. Der darin befindende Code wird immer am Ende ausgefhrt und eignet sich deshalb besonders fr Aufrumarbeiten. Falls ein solcher Block vorhanden ist, kann `catch` auch weggelassen werden.  \nEs knnen auch eigene Exceptions definiert werden. Dabei ist erforderlich, dass die Klasse von `Exception` erbt, die Fehlermeldung als String bergeben bekommt und an die Super-Klasse weitergibt."
    },
    {
     "start_checkpoint": 1622312964703,
     "parent": "n.0.121",
     "markdown": "Soll nach der Ausfhrung einer der beiden Blcke Code ausgefrt werden, kann zustzlich ein `finally`-Block verwendet werden. Der darin befindende Code wird immer am Ende ausgefhrt und eignet sich deshalb besonders fr Aufrumarbeiten. Falls ein solcher Block vorhanden ist, kann `catch` auch weggelassen werden.  \nEs knnen auch eigene Exceptions definiert werden. Dabei ist erforderlich, dass die Klasse von `Exception` erbt, die Beschreibung als String bergeben bekommt und an die Super-Klasse weitergibt."
    }
   ]
  },
  {
   "artifact_name": "m.56",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "n.0.65",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurden die objektorientierte Programmierung in Kotlin besprochen.<br />\nEine Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Kompiler fr uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren. <br />\nDie Objekterzeugung erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.<br /><br />\nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine \"klassische\", aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.<br /><br />\nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.<br />\nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert werden und auch zustzicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.<br />\nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.<br />\nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zustzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Auerdem knnen die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fgt diese dann im Hintergrund zu einem zusammenhngendem Konstruktor zusammen.<br />\nEiner Klasse knnen mehrere primre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.<br /><br />\n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.<br /><br />\n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.<br />\nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.<br />\nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.<br /><br />\n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.<br />\nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.<br />\nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.<br /><br />\n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n<br />\n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.<br /><br />\n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.<br />\nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.<br />\n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n<br /><br />\n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.<br />\nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler bernommen.<br />\nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.<br /><br />\nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.<br /><br />\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.<br />\nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.<br />\nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.<br />\nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.<br />\nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.<br /><br />\nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details> \n<br />\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.<br />\nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.<br /><br />\nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen. <br />\nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.<br />\nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.<br />\nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622290741126,
     "parent": "n.0.102",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Kompiler fr uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine \"klassische\", aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert werden und auch zustzicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zustzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Auerdem knnen die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fgt diese dann im Hintergrund zu einem zusammenhngendem Konstruktor zusammen.  \nEiner Klasse knnen mehrere primre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details> \n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622290867816,
     "parent": "n.0.103",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Kompiler fr uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine \"klassische\", aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert werden und auch zustzicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zustzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Auerdem knnen die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fgt diese dann im Hintergrund zu einem zusammenhngendem Konstruktor zusammen.  \nEiner Klasse knnen mehrere primre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details> \n  \n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622290882283,
     "parent": "n.0.104",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Kompiler fr uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine \"klassische\", aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert werden und auch zustzicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zustzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Auerdem knnen die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fgt diese dann im Hintergrund zu einem zusammenhngendem Konstruktor zusammen.  \nEiner Klasse knnen mehrere primre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details> \n<br />\n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622290897345,
     "parent": "n.0.105",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Kompiler fr uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine \"klassische\", aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert werden und auch zustzicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zustzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Auerdem knnen die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fgt diese dann im Hintergrund zu einem zusammenhngendem Konstruktor zusammen.  \nEiner Klasse knnen mehrere primre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n\n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622290907792,
     "parent": "n.0.106",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Kompiler fr uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine \"klassische\", aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert werden und auch zustzicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zustzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Auerdem knnen die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fgt diese dann im Hintergrund zu einem zusammenhngendem Konstruktor zusammen.  \nEiner Klasse knnen mehrere primre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n  \nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622290917172,
     "parent": "n.0.107",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Kompiler fr uns die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Kompiler diesen in ein Feld mit Konstruktor und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine \"klassische\", aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert werden und auch zustzicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zustzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Auerdem knnen die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fgt diese dann im Hintergrund zu einem zusammenhngendem Konstruktor zusammen.  \nEiner Klasse knnen mehrere primre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622291027879,
     "parent": "n.0.108",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie Objekterzeugung erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege Felder einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine *klassische*, aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Kompiler generiert in diesem Fall nur Getter und Setter.    \nDer Konstruktor wurde bereits angesprochen. Kotlin unterscheidet zwischen 2 verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wird, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf den primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen 3 Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Kompiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert werden und auch zustzicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zustzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Auerdem knnen die verschiedenen Formen auch miteinander Kombiniert werden. der Kompiler fgt diese dann im Hintergrund zu einem zusammenhngendem Konstruktor zusammen.  \nEiner Klasse knnen mehrere primre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Kompiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622291072276,
     "parent": "n.0.111",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine *klassische*, aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Paramater im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert werden und auch zustzicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen die zustzlichen Code oder auch Fehlerbehandlung bei der Erzeugung besitzen zu empfehlen. Auerdem knnen die verschiedenen Formen auch miteinander Kombiniert werden. der Compiler fgt diese dann im Hintergrund zu einem zusammenhngendem Konstruktor zusammen.  \nEiner Klasse knnen mehrere primre Konstruktoren mit unterschiedlichem Parameterprofil implementiert werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `contructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld \"gespeichert\" werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.    \n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Compiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Compiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Compiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Compiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622291555802,
     "parent": "n.0.112",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine *klassische*, aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert und auch zustzlicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zustzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen knnen auch miteinander kombiniert werden. Der Kompiler fgt diese im Hintergrund zu einem zusammenhngenden Konstruktor zusammen.  \nEiner Klasse knnen **mehrere primre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefgt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art eines Feldes sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich der gespeicherte Wert zurckgegen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, sind nonnullable und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das der Fall war, kann mit `this::name.isInitialized` nachgeprft werden.    \n\n\nIn Kotlin besitzt - wie in Java - jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeite**. Folgende Sichtbarkeiten sind vorhanden:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen sich als grere Pakete vorgestellt werden.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Compiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Compiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Compiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Compiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622291748840,
     "parent": "n.0.113",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine *klassische*, aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert und auch zustzlicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zustzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen knnen auch miteinander kombiniert werden. Der Kompiler fgt diese im Hintergrund zu einem zusammenhngenden Konstruktor zusammen.  \nEiner Klasse knnen **mehrere primre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefgt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurckgegeriffen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden untersttzt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen Sie sich als grere Pakete vorgestellen.\n* `public`: Das Element kann berall benutzt werden.\n\n  \n\nZustzlich zu Feldern und Konstruktoren ist ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Standardaufbau wie Funktionen. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder angegeben werden. Fr diese generiert der Compiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei der Generierung nicht bercksichtig.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur zugewiesen.  \n`copy()` hingegen gibt es identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur durch Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.<br/>\n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Der Singleton muss nicht per Konstruktoraufruf erzeugt werden, sondern dies wird vom Compiler bernommen.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf knnen Felder und Methoden definiert werden. Soll eine Klasse mehrere `companion objects` besitzen , wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen Name vergeben. Um ein solches Objekt aufzurufen muss folgender Aufruf ausgefhrt werden: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist sich seinen eigenen Datentyp mit vordefinierten Werten zu bauen. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um den Compiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Mglichkeiten. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum zu bergeben, wie bei einer normalen Klasse, ist nicht mglich.    \nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der erbenden Klasse berschrieben werden, mssen diese in der Oberklasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden, kann dies mit dem Schlsselwort `super` bewerkstelligt werden.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da beispielsweise nur weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet und nur deklariert werden, mssen erbende Klasse diese implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen  der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Subtypen bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin auch einige vordefinierte Schnittstellen. </summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Compiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622292522022,
     "parent": "n.0.114",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine *klassische*, aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert und auch zustzlicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zustzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen knnen auch miteinander kombiniert werden. Der Kompiler fgt diese im Hintergrund zu einem zusammenhngenden Konstruktor zusammen.  \nEiner Klasse knnen **mehrere primre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefgt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurckgegeriffen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden untersttzt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen Sie sich als grere Pakete vorgestellen.\n* `public`: Das Element kann berall benutzt werden.\n\n\n\nZustzlich zu Feldern und Konstruktoren ist sind ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Kopf wie Funktionen, werden jedoch in einer Klasse implementiert. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder und keine Parameter angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei den Methoden nicht bercksichtigt.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur aufsteigend zugewiesen.  \n`copy()` hingegen gibt ein identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur mit Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.  \n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Eines explizite Erzeugung des Singletons ist nicht mglich. Bei der ersten Verwendung  bernimmt dies der Kompiler.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen Aspekte einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von Allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf ist eine Definition von Feldern und Methoden mglich. Soll eine Klasse mehrere `companion objects` besitzen, wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen ein Name vergeben. Der Aufruf auf ein solches Objekt sieht folgendermaen aus: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist, der Bau eines eigenen Datentyp mit vordefinierten Werten. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um dem Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Funktionsweise erheblich. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum, wie bei einer normalen Klasse, zu bergeben, ist nicht mglich.  \n\n\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der Unterklasse berschrieben werden, mssen diese in der Super-Klasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden sollen, kann dies mit dem Schlsselwort `super` geschehen.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet werden und nur deren Kopf angegeben wird, mssen erbende Sub-Klassen diese *fertig* implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Sub-Klassen bei Kompilierzeit bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert, als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin einige vordefinierte Schnittstellen.</summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Funktionalitten mitbringt, knnen diesem generische Schnittstellen vorgeschrieben werden. Diese werden nach dem Namen mit `:` getrennt angegeben.  \nDes weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Compiler den Typ automatisch erkennt.    \nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen Checked und Unchecked Exceptions unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Fehler abzufangen.   \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann auch ein solcher Ausdruck einer Variable zugewiesen werden. Genaueres dazu wurde in Lektion 3 des 1. Abschnitts bereits ausgefhrt.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try and catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch \"aufgerumt\" werden, kann ein `finally`-Block angehngt werden. Auerdem knnte bei dem Vorhandensein von `finally` auch der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Typs `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622292705723,
     "parent": "n.0.116",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine *klassische*, aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert und auch zustzlicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zustzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen knnen auch miteinander kombiniert werden. Der Kompiler fgt diese im Hintergrund zu einem zusammenhngenden Konstruktor zusammen.  \nEiner Klasse knnen **mehrere primre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefgt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurckgegeriffen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden untersttzt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen Sie sich als grere Pakete vorgestellen.\n* `public`: Das Element kann berall benutzt werden.\n\n\n\nZustzlich zu Feldern und Konstruktoren ist sind ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Kopf wie Funktionen, werden jedoch in einer Klasse implementiert. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder und keine Parameter angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei den Methoden nicht bercksichtigt.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur aufsteigend zugewiesen.  \n`copy()` hingegen gibt ein identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur mit Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.  \n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Eines explizite Erzeugung des Singletons ist nicht mglich. Bei der ersten Verwendung  bernimmt dies der Kompiler.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen Aspekte einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von Allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf ist eine Definition von Feldern und Methoden mglich. Soll eine Klasse mehrere `companion objects` besitzen, wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen ein Name vergeben. Der Aufruf auf ein solches Objekt sieht folgendermaen aus: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist, der Bau eines eigenen Datentyp mit vordefinierten Werten. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um dem Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Funktionsweise erheblich. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum, wie bei einer normalen Klasse, zu bergeben, ist nicht mglich.  \n\n\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der Unterklasse berschrieben werden, mssen diese in der Super-Klasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden sollen, kann dies mit dem Schlsselwort `super` geschehen.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet werden und nur deren Kopf angegeben wird, mssen erbende Sub-Klassen diese *fertig* implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Sub-Klassen bei Kompilierzeit bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert, als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin einige vordefinierte Schnittstellen.</summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Eigenschaften aufweist, knnen diesem generische Schnittstellen vorgeschrieben werden. Sie werden nach dem Namen mit `:` getrennt angegeben.  \nDes Weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.\n\n\nDie **Fehlerbehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen *checked* und *unchecked Exceptions* unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Ausnahmen zu behandeln.  \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann ein solcher Ausdruck einer Variable zugewiesen werden.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try & catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch *aufgerumt* werden, kann ein `finally`-Block angehngt werden. Auerdem kann bei dem Vorhandensein von `finally` der `catch`-Block weggelassen werden.  \nEigene Fehler knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Fehlermeldung als Parameter des Datentyps `String` bergeben werden."
    },
    {
     "start_checkpoint": 1622312964703,
     "parent": "n.0.118",
     "markdown": "## Zusammenfassung\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Compiler die Erzeugung eines Standardkonstruktors sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, hnlich zu Java, mit dem Namen der Klasse sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine *klassische*, aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert und auch zustzlicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Wert verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zustzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen knnen auch miteinander kombiniert werden. Der Kompiler fgt diese im Hintergrund zu einem zusammenhngenden Konstruktor zusammen.  \nEiner Klasse knnen **mehrere primre Konstruktoren** mit unterschiedlichem Parameterprofil hinzugefgt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und den Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf ein primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `constructor` gefolt von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurckgegeriffen und keine abermalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden untersttzt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen Sie sich als grere Pakete vorgestellen.\n* `public`: Das Element kann berall benutzt werden.\n\n\n\nZustzlich zu Feldern und Konstruktoren ist sind ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Kopf wie Funktionen, werden jedoch in einer Klasse implementiert. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder und keine Parameter angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei den Methoden nicht bercksichtigt.  \nDie Methode `componentN()` gibt den Wert des Feld mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur aufsteigend zugewiesen.  \n`copy()` hingegen gibt ein identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare von Name des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objekt den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur mit Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variable gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object` gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.  \n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse. Jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Felder mssen somit selbst berechnet oder vordefinierte Werte zugewiesen werden. Eines explizite Erzeugung des Singletons ist nicht mglich. Bei der ersten Verwendung  bernimmt dies der Kompiler.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen Aspekte einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von Allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und werden mit `companion object` eingeleitet. In dessen Rumpf ist eine Definition von Feldern und Methoden mglich. Soll eine Klasse mehrere `companion objects` besitzen, wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen ein Name vergeben. Der Aufruf auf ein solches Objekt sieht folgendermaen aus: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist, der Bau eines eigenen Datentyp mit vordefinierten Werten. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um dem Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist dank der Verarbeitung als Klasse mglich und erweitert die Funktionsweise erheblich. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum, wie bei einer normalen Klasse, zu bergeben, ist nicht mglich.  \n\n\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der Unterklasse berschrieben werden, mssen diese in der Super-Klasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden sollen, kann dies mit dem Schlsselwort `super` geschehen.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet werden und nur deren Kopf angegeben wird, mssen erbende Sub-Klassen diese *fertig* implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Sub-Klassen bei Kompilierzeit bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert, als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt bietet Kotlin einige vordefinierte Schnittstellen.</summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Eigenschaften aufweist, knnen diesem generische Schnittstellen vorgeschrieben werden. Sie werden nach dem Namen mit `:` getrennt angegeben.  \nDes Weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.\n\n\nDie **Ausnahmebehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen *checked* und *unchecked Exceptions* unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Ausnahmen zu behandeln.  \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann ein solcher Ausdruck einer Variable zugewiesen werden.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try & catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch *aufgerumt* werden, kann ein `finally`-Block angehngt werden. Auerdem kann bei dem Vorhandensein von `finally` der `catch`-Block weggelassen werden.  \nEigene Ausnahmen knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Beschreibung als Parameter des Datentyps `String` bergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.57",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.116",
     "markdown": "##### Vergleich\nJede Erscheinungsform des Konstruktors hat seine Vorteile und Anwendungsbereiche. Whrend der Defaultkonstruktor bei einfachen Klassen, bei denen die Parameter unverndert zugewiesen werden, zu bevorzugen ist, bieten die expliziten Konstruktoren genau die Mglichkeit der vorherigen Bearbeitung. Auf dem ersten Blick scheint es so, als sei der Konstruktor mit einem `init`-Block 1:1 zu ersetzen durch einen Konstruktor mit direkter Initialisierung, da die Parameter scheinbar mit dem gleichen Ergebnis direkt zugewiesen werden knnen. Jedoch ist der zuletzt genannte bei komplexeren Klassen zu bevorzugen, da dort alle Daten erst auf Richtigkeit, beispielweise mit `try` und `catch`, geprft werden knnen (nheres dazu in [Lektion 8](Lektion-8---Fehlerbehandlung)).\n\n##### Kombination\nDie verschiedenen Konstruktoren knnen auch beliebig miteinander kombiniert werden. "
    }
   ]
  },
  {
   "artifact_name": "m.58",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "n.0.121",
     "markdown": "##### Mehrere primre Konstruktoren\nEine wichtige Eigenschaft einer Klasse fehlt aber noch: Die Erzeugung eines Objekts mit unterschiedlichen Parameterprofilen. Um das zu erreichen knnen in der Klasse mehrere primre Konstruktoren implementiert werden. Diesen wird das Schlsselwort `constructor` vorangestellt. Auerdem bekommt jeder Konstruktor sein eigenes Parameterprofil, mit dem dieser in dessen Rumpf arbeiten kann. Die Konstruktoren hneln dabei dem `init`-Verfahren, da sie alle ihren eigenen Rumpf besitzen. Die Parameterklammern der Klasse werden weggelassen."
    }
   ]
  },
  {
   "artifact_name": "m.59",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Abschnitt3.png\" style=\"margin-left: auto; margin-right: auto; display: block; margin-bottom: 20px\"/>\n<h1 style=\"display:none\">Abschnitt 2 - Funktionale Programmierung</h1>\n\n<img src=\"images/Einfhrung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h2 style=\"display:none\">Einfhrung</h2>\nThema dieses Abschnittes ist die objektorientierte Programmierung.\n\n<img src=\"images/Gliederung.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h3 style=\"display:none\">Gliederung</h3>\nDieser Abschnitt folgt folgender Struktur:\n<ol>\n    <li>Klassen</li>\n    <li>Datenklassen</li>\n    <li>Objekte</li>\n    <li>Aufzhlungen</li>\n    <li>Vererbung</li>\n    <li>Schnittstellen</li>\n    <li>Generizitt</li>\n    <li>Ausnahmebehandlung</li>\n</ol>\n\n<img src=\"images/Lernziele.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h3 style=\"display:none\">Lernziele</h3>\nNach diesem Abschnitt sollen Sie in der Lage sein:\n<ul>\n    <li>die Unterschiede zwischen einer nullable und nonnullable Variable aufzuzeigen.</li>\n    <li>nullable Datentypen in deinem Code zu verwenden.</li>\n    <li>das Konzept der Lambda-Ausdrcke zu nennen.</li>\n    <li>korrekte Lambda-Ausdrcke zu formulieren und diese an einen gegebenen Anwendungsfall anzupassen.</li>\n    <li>Operationen auf Datenstrukturen mit mehreren passenden Lambda-Ausdrcken auszufhren.</li>\n    <li>Funktionen hherer Ordnung zu erkennen und diese zu analysieren.</li>\n</ul>  \n<img src=\"images/Literatur.png\" style=\"margin: 20px auto 10px 0px\"/>\n<h3 style=\"display:none\">Literatur</h3>\n<p>Folgende Literatur kann in diesem Abschnitt zur Vertiefung herangezogen werden:<p>\n<ul>\n    <li>M. Kofler, Kotlin: das umfassende Handbuch. 2021.</li>\n    <li>D. Griffiths und D. Griffiths, Kotlin von Kopf bis Fu. 2019.</li>\n    <li>D. Jemerov und S. Isakova, Kotlin in action. 2017.</li>\n    <li>C. Kohls, A. Dobrynin, und F. Leonhard, Programmieren lernen mit Kotlin Grundlagen, Objektorientierung und fortgeschrittene Konzepte. 2020.</li>\n</ul>"
    }
   ]
  },
  {
   "artifact_name": "m.60",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion1.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 1 - Klassen</h2>\n\nAufgrund der Interoperabilitt mit Java ist auch Kotlin eine objektorientierte Sprache. Infolgedessen werden im Hintergrund alle Daten als Objekte behandelt. In Kotlin sind die bekannten objektorientierten Konzepte vorhanden, jedoch wurden diese angepasst und teilweise auch vereinfacht. Dazu ein Einfhrungsbeispiel. Es soll eine Klasse `Person` implementiert werden, die zwei Felder besitzt: `name` vom Typ `String`, das nur bei Objekterzeugung gesetzt wird, und `alter` vom Typ `Int`, das immer verndert werden kann.\n\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th style=\"font-size:16px\">Kotlin</th>\n    <th style=\"font-size:16px\">Java</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td style=\"font-size:16px\"><code>class Person (val name: String, var alter: Int)</code></td>\n    <td style=\"font-size:16px\"><code>public class Person{<br>&nbsp;&nbsp;&nbsp;&nbsp;private String name;<br>&nbsp;&nbsp;&nbsp;&nbsp;private int alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;public Person(String name, int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibName(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String gibAlter(){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;public String setzeAlter(int alter){<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.alter = alter;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br></code></td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.61",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Es ist zu erkennen, dass der Code in Kotlin deutlich krzer und bersichtlicher ist.  \nDer Kopf einer Klasse wird mit dem Schlsselwort `class` eingeleitet, gefolgt von dem Namen. Die Parameter werden nach diesem in runden Klammern angegeben. Erzeugt werden kann die Klasse, wie aus Java gewohnt, mit der Nennung des Namens der Klasse, sowie dem Aufruf eines Konstruktors. In den runden Klammern sind die erforderlichen Argumente fr die Objekterzeugung zu finden.\n\n### Felder\nFelder knnen Klassen auf verschiedene Weisen hinzugefgt werden. Die erste Mglichkeit ist durch die bergabeparameter der Klasse. Diese entsprechen den Parametern des Konstruktors und sind im Kopf der Klasse angesiedelt. Wird diesen bei ffentlicher Sichtbarkeit ein Variablentyp (`val` oder `var`) zugewiesen, werden die Parameter zu Feldern umgewandelt. Das heit, es wird im Hintergrund ein Feld mit dem Namen des Parameters angelegt, das bei Objekterzeugung mit dem Wert des bergabeparameters gefllt wird. Auerdem wird immer ein *unsichtbarer* Standard-Getter erzeugt. Wird dem Parameter `var` zugeordnet, fgt der Compiler zustzlich einen rudimentren Setter hinzu."
    }
   ]
  },
  {
   "artifact_name": "m.62",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Eine weitere Mglichkeit Felder zu definieren ist klassisch im Rumpf der Klasse. Diese werden jedoch nicht automatisch bei Objekterzeugung, sondern mit den angegebenen Standardwerten befllt. Des Weiteren wird auch diesen Feldern, je nach Typ, im Hintergrund ein Getter und Setter bei Seite gestellt."
    }
   ]
  },
  {
   "artifact_name": "m.63",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "##### Konstruktor mit init-Block\nNatrlich kann der Konstruktor auch selbst, wie aus Java gewohnt, definiert werden. Dieser ist zwischen der Deklaration der Felder und den Objektmethoden anzusiedeln. Eingeleitet wird er mit dem Schlsselwort `init`, gefolgt von einem Methodenrumpf. Im Vergleich zu Java werden dessen Parameter nicht direkt im Kopf des Konstruktors, sondern im Kopf der Klasse angegeben. Die dort definierten Parameter knnen im Konstruktor benutzt werden. Bei Namenskonflikten findet das Schlsselwort `this` Anwendung, dass das aktuelle Objekt referenziert."
    }
   ]
  },
  {
   "artifact_name": "m.64",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "##### Vergleich\nJede Erscheinungsform des Konstruktors hat seine Vorteile und Anwendungsbereiche. Whrend der Defaultkonstruktor bei einfachen Klassen, bei denen die Parameter unverndert zugewiesen werden zu bevorzugen ist, bieten die expliziten Konstruktoren genau die Mglichkeit der vorherigen Bearbeitung. Auf dem ersten Blick scheint es so, als sei der Konstruktor mit einem `init`-Block 1:1 zu ersetzen durch einen Konstruktor mit direkter Initialisierung, da die Parameter scheinbar mit dem gleichen Ergebnis direkt zugewiesen werden knnen. Jedoch ist der zuletzt Genannte bei komplexeren Klassen zu bevorzugen, da dort alle Daten erst auf Richtigkeit, beispielweise mit `try` und `catch`, geprft werden knnen (Nheres dazu in [Lektion 8](Lektion-8---Fehlerbehandlung)).\n\n##### Kombination\nDie verschiedenen Konstruktoren knnen auch beliebig miteinander kombiniert werden. "
    }
   ]
  },
  {
   "artifact_name": "m.65",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "#### Sekundrer Konstruktor\nMit Hilfe eines sekundren Konstruktors ist es einfach mglich alternative Wege Objekte zu erzeugen. Dazu wird ein primrer Konstruktor mit `this()` und zu bestimmenden Parametern aufgerufen. Auch kann ein anderer sekundrer Konstruktor aufgerufen, jedoch muss am Ende immer ein Primrer benutzt werden, da nur dieser das Objekt erzeugen kann. Die Implementierung eines sekundren Konstruktors hnelt der bei Benutzung mehrerer primrer Konstruktoren. Jedoch ist nur eine Anweisung erlaubt, die von den Parametern mit `:` getrennt wird und einen primren Konstruktor aufruft."
    }
   ]
  },
  {
   "artifact_name": "m.66",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Getter und Setter\nEs knnen aber auch eigene Getter und Setter fr jedes Feld definiert werden, falls der Variablentyp dies zulsst und diese erst im Rumpf der Klasse definiert werden. Beide mssen direkt nach dem Feld definiert werden. Auf den aktuellen Wert des Feldes kann mit `field` zugegriffen werden. Der Setter bekommt den neuen Wert als Parameter bergeben. Der Datentyp des Parameters muss nicht angegeben werden, da dieser durch das Feld gegeben ist, jedoch muss ihm ein Name zugewiesen werden, der im Rumpf den neuen Wert reprsentiert. Der Wert des Feldes wird mit einer Zuweisung an `field` gendert. Es sind immer die Datentypen der Felder zu beachten."
    }
   ]
  },
  {
   "artifact_name": "m.67",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "#### Lazy Properties\nEine Variable oder ein Feld des Typs `val` kann mit dem Schlsselwort `by lazy` *trge* gemacht werden. Das heit, dass der Wert erst bei der ersten Verwendung berechnet wird. Dazu ist ein Lambda-Ausdruck ntig, dessen Ergebnis der Wert des Feldes oder der Variable ist. Wird die Variable danach noch einmal verwendet, wird der Inhalt nicht noch einmal berechnet, sondern auf den gespeicherten Wert zurckgegriffen."
    }
   ]
  },
  {
   "artifact_name": "m.68",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Methoden\nDer Aufbau von Objektmethoden kann mit dem von Funktionen verglichen werden, werden jedoch im Rumpf einer Klasse definiert. Es ist mglich die Kurzschreibweise anzuwenden und eine Sichtbarkeit zuzuweisen. Auf Objektmethoden kann, wie in Java, mit der Punktnotation zugegriffen werden. Soll eine bereits implementierte Methode, zum Beispiel `toString()`, berschrieben werden, ist das Voranstellen des Schlsselworts `override` ntig."
    }
   ]
  },
  {
   "artifact_name": "m.69",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Aufgabe - Parkplatzverwaltung\nImplementieren Sie eine Klasse `Parkplatzverwaltung`, die einen Parkplatz reprsentieren soll. Der Grundriss und die Belegung soll mit Hilfe einer Liste der Lnge 5 verwirklicht werden, der als Feld reprsentiert wird. Ist ein Parkplatz belegt, so soll dieser Eintrag `true` sein. Verwenden Sie passende Sichtbarkeiten.  \nStandardmig wird bei Erzeugung eine passende Liste bergeben. Falls kein Parameter bergeben wird, soll ein leerer Parkplatz erstellt werden. Implementieren Sie zustzlich eine Methode `einparken()` der die Nummer des Parkplatzes bergeben wird und diesen falls mglich belegt. Bei Erfolg soll `true` zurckgegeben werden, ansonsten `false`. Gehen Sie davon aus, dass nur korrekte Parameter bergeben werden. berschreiben Sie zustzlich die Methode `toString()`, die den Parkplatz bersichtlich nach folgendem Muster ausgeben soll:  \n--x-- (Parkplatz Nummer 2 ist belegt)"
    }
   ]
  },
  {
   "artifact_name": "m.70",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion2.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 2 - Datenklassen</h2>\n\n\nZustzlich zu normalen Klassen bietet Kotlin auch die Mglichkeit Klassen zu erstellen, die nur die Aufgabe der Speicherung von Daten haben. Auf den ersten Blick knnte dies auch mit normalen Klassen bewerkstelligt werden. Jedoch mssen dann alle Methoden, die eine Datenklasse in der Regel bentigt, per Hand implementiert werden. Beispiele dafr sind `toString()` oder `equals()`. Um das zu Verhindern, gibt es Datenklassen. Fr diese generiert der Kotlin-Compiler im Hintergrund folgende Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Gekennzeichnet werden Datenklassen mit dem Schlsselwort `data class`. Alle Felder, die bei den generierten Methoden bercksichtigt werden sollen, mssen in dem Kopf der Datenklasse angegeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.71",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Durch die Verwendung der `componentN()`-Methode kann auf die Felder der Datenklasse zugegriffen werden. Dabei bekommt jedes Feld eine eigene Nummer, beispielsweise in der Klasse 'Punkt' 'x' die Nummer 1, zugewiesen. Wird `N` durch die Nummer ersetzt und auf einem Objekt aufgerufen, wird das dazugehrige Feld zurckgegeben. Auch knnen dadurch mehrere Felder abgerufen werden, indem eine Folge als Rckgabe erwartet wird."
    }
   ]
  },
  {
   "artifact_name": "m.72",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Die Erzeugung eines neuen, identischen Objekts erfolgt mit Hilfe von `copy()`. Soll aber bestimmten Feldern ein anderer Wert zugewiesen werden, kann dies der Methode mit Namen des Feldes und dem gewnschten Wert bergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.73",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Aufgabe - Abstnde\nIn dieser Aufgabe sollen Sie mit Hilfe von Datenklassen eine Verwaltung von Abstnden implementieren. Dazu werden folgende Komponenten bentigt:\n* Eine Datenklasse `Position`, die eine x- und y-Koordinate speichert\n* Eine Datenklasse `Abstand`, die primr den Wert eines Abstands speichert. Auerdem sollen in der Datenklasse in einer Liste `positionen` Paare von Positionen abgespeichert werden, die diesen Abstand besitzen.  \nBeispiel: `wert` des Abstandes: 3, Inhalt von `positionen`: [( Position(0,0), Position(2,1) ), ( Position(0,3), Position(3,3) ), ... ] \n* Eine Funktion `berechneAbstand()` der zwei Positionen bergeben werden. In ihrem Rumpf soll die [Manhatten-Distanz](https://de.wikipedia.org/wiki/Manhattan-Metrik) der beiden Punkte berechnet und der Abstand zur globale Liste `abstaende` hinzugefgt werden, sollte der Abstand noch nicht in der Liste gespeichert sein. Falls doch, sollen die beiden Positionen dem bereits vorhandenen Abstand in die Liste `positionen` hinzugefgt werden. "
    }
   ]
  },
  {
   "artifact_name": "m.74",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion3.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 3 - Objekte</h2>\n\n\nEine Besonderheit von Kotlin ist, dass nicht jedes Objekt eine Klasse bentigt. Dadurch kann beispielsweise ein statisches Feld simuliert oder unkompliziert mehrere Daten an einem Ort zusammengefasst werden.\n### Ad-hoc Objekte\nMit sogeannten Ad-hoc Objekten knnen Daten hnlich einer Map komprimiert werden. Es kann ein Objekt erzeugt werden, ohne vorher eine Klasse angelegt zu haben. Dies ist mit dem Schlsselwort `object` einzuleiten. Wie auch einer Klasse knnen dem Ad-hoch Objekt Felder zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.75",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Singletons\nSingletons sind Objekte, die nur ein Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Ein solches Objekt wird mit dem Schlsselwort `object` gekennzeichnet und kann nicht einer Variable zugewiesen werden, da es erst bei der ersten Benutzung erzeugt wird. Deshalb kann es auch nicht erzeugt werden. Die Erzeugung erfolgt automatisch beim ersten Aufruf, der in der Punktnotation mit dem Namen des Singletons erfolgt. Ein Singleton kann aus Feldern und Methoden bestehen. Ein Konstruktor kann jedoch nicht angewendet werden, da die Erzeugung ohne bergabeparameter stattfindet."
    }
   ]
  },
  {
   "artifact_name": "m.76",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Falls in einer Klasse mehrere Companion Objekte gewnscht werden, ist ab dem Zweiten das Schlsselwort `companion` wegzulassen und auerdem ein Name anzugeben. Auerhalb der Klasse kann auf das Objekt nur durch die Klasse und nicht mit einem Objekt der Klasse zugegriffen werden."
    }
   ]
  },
  {
   "artifact_name": "m.77",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "#### Aufgabe - Nummernschilder\nImplementieren Sie eine Klasse `Auto`, die drei Felder besitzt: die `ps` (`Int`), eine `farbe` (`String`) und ein `nummernschild` (`String`). Die Nummernschilder sollen der Einfachheit nach dem Format *(A-Z)(A-Z)-(1-9)(0-9)* vergeben werden. Jedes ist einzigartig. Verwenden Sie fr die Umsetzung ein `companion object`, das ein Feld, in dem alle vergebenen Nummernschilder gespeichert werden, besitzt. Fgen Sie dem Objekt zustzlich eine Funktion hinzu, die ein noch nicht vergebenes Schild generiert. Das Suchen nach einem passenden Nummernschild kann per Brute-Force erfolgen. Auf die Laufzeit muss nicht geachtet werden."
    }
   ]
  },
  {
   "artifact_name": "m.78",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion4.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 4 - Aufzhlung</h2>\n\n\nMit Hilfe einer Enumeration kann ein eigener, limitierter Datentyp erstellt werden, der nur vordefinierte Werte annehmen kann. Der Klasse wird dafr das Schlsselwort `enum` vorangestellt. Soll ein Wert des Enums verwendet werden, muss zustzlich der Name der Enumeration angegeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.79",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Da Enums als vollstndige Klassen angesehen werden, knnen ihnen Felder und sogar Methoden hinzugefgt werden. Sollen Felder mit einem bestimmten Wert, der von dem Wert des Enums abhngt, gefllt werden, erfolgt die bergabe der Parameter hinter dem Wert des Enums."
    }
   ]
  },
  {
   "artifact_name": "m.80",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion5.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 5 - Vererbung</h2>\n\n\nIn Kotlin kann nicht von einer beliebigen Klasse geerbt werden. Diese muss als Voraussetzung den Vorsatz `open` besitzen. Dadurch wird signalisiert, dass eine Vererbung stattfinden darf. Der Namen der Klasse, von der geerbt werden soll, ist mit einem `:` getrennt hinter den Parameterklammern der erbenden Klasse zu schreiben. Dem Konstruktor der Super-Klasse werden die Parameter direkt im Kopf der Klasse bergeben. "
    }
   ]
  },
  {
   "artifact_name": "m.81",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Felder und Methoden berschreiben\nSollen Felder oder Methoden der Super-Klasse in der Sub-Klasse berschrieben werden, mssen diese ebenfalls mit `open` gekennzeichnet werden. Erst dann ist es mglich das gleiche Feld oder die gleiche Methode in der Sub-Klasse mit dem Zusatz `override` zu definieren. Soll auf das Feld oder die Methode der Oberklasse zugegriffen werden, findet das Schlsselwort `super` Anwendung. Bei Mehrfachvererbung wird die nchst hhere Klasse angesprochen."
    }
   ]
  },
  {
   "artifact_name": "m.82",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Abstrakte Klassen\nDas Konzept der abstrakten Klasse sollte bereits aus Java bekannt sein. Auch in Kotlin gibt es die Mglichkeit uninitierbare Klassen mit abstrakten Methoden zu implementieren. Diesen wird das Schlsselwort `abstract` vorangestellt und knnen ohne Probleme vererbt werden. Die Sub-Klassen mssen jedoch die Methoden vervollstndigen."
    }
   ]
  },
  {
   "artifact_name": "m.83",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<div class=\"alert alert-block alert-danger\">\n<b>TODO</b> Sealed class und interface in kotlin 1.5.0 anschauen\n</div>\n\n### Geschlossene Klassen\nEine geschlossene Klasse ist eine besondere abstrakte Klasse. Ihr wird das Schlsselwort `sealed` vorangestellt. Sie besitzt einen privaten Konstruktor. Von dieser darf nur in dem selben Paket oder der selben Kompiliereinheit geerbet werden. Dieses Konstrukt ist somit eine Alternative zu einer Enumeration. Da alle Subtypen bekannt sind, kann bei Verwendung einer `when`-Verzweigung der *default*-Fall weggelassen werden."
    }
   ]
  },
  {
   "artifact_name": "m.84",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion6.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 6 - Schnittstellen</h2>\n\n\nEin wichtiges objektorientiertes Konzept ist das der Schnittstelle. Ein bekanntes Beispiel das `Comparable`-Interface, das eine `compareTo()`-Methode voraussetzt. Aber anstelle des Vorschreibens von Methoden knnen auch Zugriffe definiert werden. Eine Schnittstelle besitzt das Schlsselwort `interface` und wird bei der implementierenden Klasse, hnlich zum Erben, angegeben. In einem Interface knnen sowohl Methoden voll implementiert oder nur deren Kopf angegeben werden, sodass diese von jeder Klasse selbst vervollstndigt werden mssen. Auerdem knnen sie auch Felder beinhalten.\nKotlin bietet bereits einige vorgefertigte Schnittstellen an:\n\n<table style=\"font-size:16px\">\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>"
    }
   ]
  },
  {
   "artifact_name": "m.85",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion7.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 7 - Generizitt</h2>\n\n\n### Generische Klassen\nBei manchen Softwareprojekten kommt man an generischen Klassen nicht vorbei, falls mehrfache Arbeit vermieden werden soll. Das Konzept an sich unterscheidet sich in Kotlin und Java nicht. Der generische Datentyp wird nach dem Klassennamen in `<>` angegeben und kann in der Klasse anstelle normalen Datentypen eingesetzt werden."
    }
   ]
  },
  {
   "artifact_name": "m.86",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "Soll der generische Datentyp eingeschrnkt werden, kann dies durch ein Interface passieren. Dieses gibt vor, welche Methoden der Datentyp implementieren muss."
    }
   ]
  },
  {
   "artifact_name": "m.87",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "### Generische Erweiterungsmethoden\nDas Konzept und die Implementierung von Erweiterungsmethoden wurde bereits in Abschnitt 1 kennengelernt. Es kann aber auch auf generische Klassen bertragen werden. So knnen beispielsweise einer generischen Liste neue Methoden hinzugefgt werden."
    }
   ]
  },
  {
   "artifact_name": "m.88",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Lektion8.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Lektion 8 - Ausnahmebehandlung</h2>\n\n\nWhrend in Java zwischen *checked* (die Mglichkeit einer Ausnahme muss behandelt werden) und *unchecked Exceptions* (Ausnahmen mssen nicht behandelt werden) unterschieden wird, ist dies in Kotlin nicht der Fall. Es besteht keine Pflicht bei einer bestimmten Ausnahme diese vorbeugend zu behandeln.  \nMit `throw` knnen Exceptions selbst ausgelst werden. Auerdem kann ein solcher Ausdruck einer Variablen zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.89",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Zusammenfassung.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h2 style=\"display:none\">Zusammenfassung</h2>\n"
    }
   ]
  },
  {
   "artifact_name": "m.90",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "n.0.121",
     "markdown": "<img src=\"images/Zusammenfassung.png\" style=\"margin: 20px 0px 20px 0px\"/>\n<h1 style=\"display:none\">Zusammenfassung</h1>\n\nIn diesem Abschnitt wurde die objektorientierte Programmierung in Kotlin vorgestellt.  \nEine **Klasse** wird mit dem Schlsselwort `class` eingeleitet, gefolgt von ihrem Namen. Neu ist, dass hinter diesem direkt die Parameter des Konstruktors angegeben werden. Wird ihnen `val` oder `var` vorangestellt, bernimmt der Compiler die Erzeugung eines Standardkonstruktors, sowie die Implementierung von Gettern (`val` und `var`) und Settern (`var`) fr diese Felder. Dadurch lassen sich rudimentre Klassen einfach implementieren.   \nDie **Objekterzeugung** erfolgt, hnlich zu Java, mit dem Namen der Klasse, sowie den fr den Konstruktor bentigten Parameter. Jedoch wird das Schlsselwort `new` weggelassen.    \nIn Kotlin gibt es verschiedene Wege **Felder** einer Klasse hinzuzufgen. Die einfachste Mglichkeit wurde bereits genannt. Wird dem Parameter im Kopf der Klasse ein Variablentyp zugewiesen, wandelt der Compiler diesen in ein Feld mit *Konstruktor* und Getter, bei Bedarf auch einen Setter, um. Natrlich ist auch eine *klassische*, aus Java bekannte, Implementierung mglich. Werden die Felder zu Beginn der Klasse definiert, muss ihnen jedoch hndisch ein Konstruktor hinzugefgt werden. Der Compiler generiert in diesem Fall nur Getter und Setter.    \nDer **Konstruktor** wurde bereits angesprochen. Kotlin unterscheidet zwischen zwei verschiedenen Arten:\n* primrer Konstruktor: Dieser Konstruktor muss mindestens ein Mal in jeder Klasse enthalten sein. Falls er nicht explizit definiert wurde, wird ein automatisch generierter Konstruktor implizit hinzugefgt.\n* sekundrer Konstruktor: Eine Anweisung, die auf einen primren Konstruktor verweist und eine alternative Handhabung des primren Konstruktors ermglicht.\n\nZunchst soll der **primre Konstruktor** betrachtet werden. Dieser ist fr die eigentliche Objekterzeugung verantwortlich und muss in jeder Klasse vorhanden sein.\nHier wird wiederum zwischen drei Typen unterschiedenen:\n* Defaultkonstruktor\n* Konstruktor mit `init`-Block\n* Konstruktor durch direkte Zuweisung\n\nDer **Defaultkonstruktor** wurde bereits kennengelernt. Er wird vom Compiler fr alle Felder generiert, die im Kopf der Klasse angegeben sind. Dabei wird der bergebene Wert dem Feld zugewiesen. Es ist nicht mglich diesen Vorgang zu verndern.  \nWerden die Felder in der Klasse deklariert, muss selbst ein Konstruktor implementiert werden. Eine Mglichkeit ist der **Konstruktor mit `init`-Block**. Dieser hnelt dem aus Java bekannten Konstruktor am Meisten. Eingeleitet wird er mit dem Schlsselwort `init` und ist zwischen der Deklarierung der Felder und Implementierung der Methoden anzusiedeln. Dem Konstruktor werden die Parameter der Klasse (alle Parameter im Kopf der Klasse ohne Variablentyp) bergeben. Die Parameterklammern zwischen `init` und dem Rumpf des Konstruktors fallen somit weg. In dem Rumpf knnen alle Felder initialisert und auch zustzlicher Code, der bei Erzeugung der Klasse ausgefhrt werden soll, hinzugefgt werden. Liegt ein Namenskonflikt vor (Parameter und Feld besitzen den gleichen Namen) kann das Feld, wie in Java, mit dem Vorsatz `this` angesprochen werden.  \nEine variablenhnliche Initialisierung ist mit dem **Konstruktor durch direkte Inititalisierung** mglich. Die Parameter werden wieder im Kopf der Klasse definiert. Jedoch werden diese den Feldern direkt bei der Deklarierung zugewiesen. Abgesehen von den Parametern knnen aber auch vordefinierte Werte verwendet werden.  \nDie Wahl der richtigen Form des primren Konstruktors fr einen speziellen Fall spart Zeit und Codezeilen. Whrend bei einer rudimentren Klasse der Defaultkonstruktor angewendet werden sollte, ist der Konstruktor mit `init`-Block besonders bei Klassen, die zustzlichen Code oder bei der Erzeugung Fehler behandeln, zu empfehlen.  \nDie verschiedenen Formen knnen auch miteinander kombiniert werden. Der Kompiler fgt diese im Hintergrund zu einem zusammenhngenden Konstruktor zusammen.  \nEiner Klasse knnen **mehrere primre Konstruktoren**, die unterschiedliche Parameterprofile besitzen, hinzugefgt werden. In diesem Fall werden die Parameter nicht im Kopf der Klasse, sondern im Kopf des Konstruktors angegeben. Diese hneln einem Konstruktor mit `init`-Block. Jedoch wird statt `init` das Schlsselwort `constructor` gefolgt von den Parametern und dem Rumpf verwendet.    \n**Sekundre Konstruktoren** knnen benutzt werden, um ein Objekt der Klasse mit bestimmten vorgefertigten Parametern aufzurufen. Dafr muss auf einen primrer Konstruktor der Klasse verwiesen werden. Eingeleitet wird er mit dem Schlsselwort `constructor`, gefolgt  von den Parametern. Einen Rumpf besitzen sie nicht. Stattdessen folgt nach den Parameter ein `:` und der Aufruf eines primren Kosntruktors, der mit `this` gekennzeichnet wird.    \n\nBis jetzt wurden alle **Getter und Setter** der Felder automatisch generiert. Dies kann jedoch auch von Hand geschehen. Dazu werden nach der Deklarierung des Feldes die beiden Methoden angegeben.  \nDer **Getter** besitzt folgenden Syntax:  \n\n>Getter -> \"get() =\" Rckgabe\n\nDie Rckgabe muss den Datentyp des Feldes besitzen. Auf den aktuellen Wert kann mit dem Schlsselwort `field` zugegriffen werden.  \nHingegen der Syntax des **Setters**:  \n\n>Setter -> \"set (\" Parametername \"){\" Rumpf \"}\"\n\nDer Setter bekommt den neuen Wert als Parameter bergeben. Um ihn im Rumpf verwenden zu knnen, muss ihm ein Name zugewiesen werden. Der Datentyp wird weggelassen, da dieser durch das Feld klar definiert ist. Im Rumpf findet dann die eigentliche Zuweisung statt. Der Variable `field` muss im Laufe der Ausfhrung des Rumpfes ein (neuer) Wert zugewiesen werden.    \n\n\nDurch die Mglichkeit eigene Getter zu definieren, knnen kleine Methoden in einem Feld *gespeichert* werden. Das Feld besitzt dabei den Typ `val` und weder einen Datentyp, noch eine Initialisierung. Durch die Definition eines methonenhnlichen Getters kann bei Zugriff auf das Feld das Ergebnis dieses verwendet werden. Ein solches Feld wird auch **Computed Property** genannt.  \nEine weitere besondere Art von Feldern sind **Lazy Properties**. Einem Feld des Typs `val` kann nach der Angabe des Datentyps der Zusatz `by lazy` angehngt werden. In dem folgenden Lambda-Ausdruck wird erst bei dem ersten Zugriff der Wert des Feldes berechnet. Wird es nochmal verwendet, wird lediglich auf den gespeicherten Wert zurckgegriffen und keine nochmalige Berechnung durchgefhrt.  \nEin hnliches Konstrukt sind `lateinit`-Felder. Diese sind von Typ `var`, *non-nullable* und besitzen einen primitiven Datentyp. Auerdem wird ihnen das Schlsselwort `lateinit` vorangestellt. Wie der Name schon vermuten lsst, wird dieses Feld nicht im Konstruktor initalisiert, sondern erst nach der Objekterzeugung. Wichtig ist, dass vor der ersten Verwendung der Wert berechnet wurde, da sonst eine `UninitializedPropertyAccessException` geworfen wird. Ob das Feld bereits initialisiert wurde, kann mit `this::name.isInitialized` nachgeprft werden.    \n\n\nIn Kotlin besitzt, wie in Java, jede Variable, jedes Feld, jede Klasse eine **Sichtbarkeit**. Folgende Sichtbarkeiten werden untersttzt:\n* `private`: Das Element kann nur in der Klasse verwendet werden. \n* `protected`: Erweitertung von `private`. Zustzlich knnen auf die Elemente auch in Unterklassen zugegriffen werden.\n* `internal`: Erweiterung von `protected`. Das Element kann im ganzen Modul verwendet werden. Module knnen Sie sich als grere Pakete vorstellen.\n* `public`: Das Element kann berall benutzt werden.\n\n\n\nZustzlich zu Feldern und Konstruktoren sind ein wichtiger Bestandteil einer Klasse ihre **Methoden**. Diese besitzen den gleichen Kopf wie Funktionen, werden jedoch in einer Klasse implementiert. Es kann sowohl die Kurzschreibeweise, als auch eine Sichtbarkeit angewendet werden. Soll eine bereits implementierte Methode berschrieben werden, wird der berschreibenden Methode das Schlsselwort `override` vorangestellt.    \n\nAnstelle eine normale Klasse zu implementieren bietet Kotlin zudem die Mglichkeit eine **Datenklasse** zu erstellen. Diese ist vor Allem fr die Speicherung von Daten geeignet und besitzt das Schlsselwort `data class`. Im Kopf der Klasse knnen nur Felder und keine Parameter angegeben werden. Fr diese generiert der Kompiler im Hintergrund einige hilfreiche Methoden: `componentN()`, `copy()`, `equals()`, `hashCode()`, `toString()`. Werden zustzlich Felder im Rumpf der Datenklasse angegeben, werden diese bei den Methoden nicht bercksichtigt.  \nDie Methode `componentN()` gibt den Wert des Feldes mit der Nummer `N` zurck. Die Nummer wird den Feldern nach ihrem Auftreten in der Parametersignatur aufsteigend zugewiesen.  \n`copy()` hingegen gibt ein identisches Objekt zu dem zurck, auf das sie aufgerufen wird. Falls zustzlich als Parameter Paare vom Namen des Feldes und dessen Wert (beispielsweise `x=4` fr Feld `x`) angegeben werden, hat das Feld des neuen Objektes den bergebenen Wert.\n    \n\nWhrend in Java Objekte nur mit Klassen erzeugt werden knnen, sind in Kotlin diese beiden Konzepte auch getrennt mglich.  \nIn **Ad-hoc Objekten** knnen Daten hnlich einer Map zusammengefasst werden. Ein solches Objekt kann ohne eine Klasse erstellt und dann beispielsweise in einer Variablen gespeichert werden. Das hier zu verwendende Schlsselwort lautet `object`, gefolgt von einem Rumpf, in dem Feldern ein Wert zugewiesen wird. Auf diese kann dann ganz gewhnlich mit `nameObjekt.nameFeld` zugegriffen werden.  \n**Singletons** sind, wie der Name es auch schon vermuten lsst, Objekte die nur ein einziges Mal erzeugt werden knnen und bis zum Ende der Ausfhrung bestehen. Die Implementierung erinnert an eine Klasse, jedoch wird anstelle von `class` das Schlsselwort `object` angegeben. Auerdem knnen einem Singleton keine Parameter bergeben werden. Den Feldern mssen somit selbst berechnete oder vordefinierte Werte zugewiesen werden. Eine explizite Erzeugung des Singletons ist nicht mglich. Bei der ersten Verwendung  bernimmt dies der Kompiler.  \nMit einem **Companion Object** knnen die aus Java bekannten statischen Aspekte einer Klasse simuliert werden. Ein solches Objekt ist fr alle Objekte der Klasse gleich und kann von Allen gleichermaen verwendet werden. Diese werden nur in Klassen vorgefunden und mit `companion object` eingeleitet. In dessen Rumpf ist eine Definition von Feldern und Methoden mglich. Soll eine Klasse mehrere `companion objects` besitzen, wird ab dem Zweiten das Schlsselwort `companion` weggelassen und stattdessen ein Name vergeben. Der Aufruf auf ein solches Objekt sieht folgendermaen aus: `nameKlasse.nameObjekt.nameFeldOderMethode`.    \nEine der Hauptaufgaben von **Enumerationen** ist, der Bau eines eigenen Datentyps mit vordefinierten Werten. Kotlin sieht eine Aufzhlung als eine Klasse an, weswegen der Kopf mit den Schlsselwrtern `enum class` einzuleiten ist. In dem Rumpf knnen die mglichen Werte mit Komma getrennt angegeben werden. Um dem Kompiler zu signalisieren, dass der letzte mgliche Wert erreicht wurde, ist ein Semikolon anzufgen. Dies muss vor Allem beachtet werden, wenn die Enumeration eigene Felder oder Methoden besitzt. Dies ist aufgrund der Verarbeitung als Klasse mglich und erweitert die Funktionsweise erheblich. Sollen dem Konstruktor Parameter bergeben werden, sind diese nach jedem Wert anzugeben. Bei der Erzeugung Parameter an das Enum, wie bei einer normalen Klasse, zu bergeben, ist nicht mglich.  \n\n\nEine Klassenhierarchie kann mit Hilfe von **Vererbung** erstellt werden. Wichtig ist, dass in Kotlin nicht von alle Klassen geerbt werden kann. Solche Klassen mssen den Vorsatz `open` besitzen. Bei der erbenden Klasse werden (alle) geerbten Klassen mit einem `:` nach den Parametern angeben. Auch findet dort der geforderte Aufruf des Konstruktors der Oberklasse statt.  \nSollen Felder oder Methoden der Oberklasse in der Unterklasse berschrieben werden, mssen diese in der Super-Klasse ebenfalls mit `open` gekennzeichnet sein. In der Unterklasse knnen diese dann mit `override` berschrieben werden. Falls trotzdem das Feld oder die Methode der Oberklasse verwendet werden sollen, kann dies mit dem Schlsselwort `super` geschehen.  \nBentigt die Unterklasse keinen eigenen primren Konstruktor, da weitere Felder hinzugefgt werden, besteht die Mglichkeit dies nur durch sekundre Konstruktoren zu implementieren. Diese mssen auf den primren Konstruktor der Oberklasse verweisen.  \nHufig wird Vererbung in Verbindung mit **abstrakten Klassen** eingesetzt. Solchen Klassen wird das Schlsselwort `abstract` vorangestellt. Eine Kennzeichnung mit `open` ist nicht ntig. Falls Felder oder Methoden mit `abstract` gekennzeichnet werden und nur deren Kopf angegeben wird, mssen erbende Sub-Klassen diese *fertig* implementieren.  \nEine besondere abstrakte Klasse ist die `sealed class`, auch **geschlossene Klasse** genannt. Sie besitzen einen privaten Konstruktor und knnen nur von Klassen der gleichen Datei geerbt werden. Sie stellen eine Alternative zur Enumeration dar, da eine einfachere Verwendung der `when`-Verzweigung mglich ist. Der `else`-Block kann weggelassen werden, weil alle Sub-Klassen bei Kompilierzeit bekannt sind.    \nEin weiteres wichtiges objektorientiertes Konzept sind **Schnittstellen**. Ihr Kopf besteht aus dem Schlsselwort `interface` und dem Namen. In dem Rumpf einer Schnittstelle knnen Felder und Methoden sowohl fertig implementiert, als auch nur als die Definition des Feldes oder den Kopf der Methode vorgefunden werden. Alle Klassen, die die Schnittstelle implementieren, wie auch bei der Vererbung erkennbar im Kopf der Klasse, mssen die vordefinierten Felder und Methoden vervollstndigen. \n\n <details>\n  <summary>Wie aus Java bekannt, bietet Kotlin einige vordefinierte Schnittstellen.</summary>\n  <table>\n<thead>\n  <tr>\n    <th>Name</th>\n    <th>Funktion</th>\n  </tr>\n</thead>\n<tbody>\n  <tr>\n    <td>Appendable</td>\n    <td>append()</td>\n  </tr>\n  <tr>\n    <td>Closeable</td>\n    <td>close()</td>\n  </tr>\n  <tr>\n    <td>Compareable</td>\n    <td>compare()</td>\n  </tr>\n  <tr>\n    <td>Iterable</td>\n    <td>Verarbeitung der Elemente in einer Schleife</td>\n  </tr>\n  <tr>\n    <td>Collection</td>\n    <td>allgemeine Aufzhlung</td>\n  </tr>\n  <tr>\n    <td>List</td>\n    <td>Liste</td>\n  </tr>\n  <tr>\n    <td>Map</td>\n    <td>Dictionary</td>\n  </tr>\n  <tr>\n    <td>Set</td>\n    <td>Menge</td>\n  </tr>\n</tbody>\n</table>\n</details>\n<br />\n\n\nSollen Klassen mit variablen Datentypen implementiert werden, hilft das Konzept der **Generizitt**. Wie in Java wird der Name des generischen Datentyps nach dem Namen der Klasse in `<>` angegeben. In dem Rumpf kann dieser mit dem vorher definierten Namen verwendet werden. Soll der Datentyp eingeschrnkt werden, sodass sichergestellt werden kann, dass dieser bestimmte Eigenschaften aufweist, knnen diesem generische Schnittstellen vorgeschrieben werden. Sie werden nach dem Namen mit `:` getrennt angegeben.  \nDes Weiteren knnen auch Funktionen generisch implementiert werden. Bei diesen wird der generische Datentyp zwischen `fun` und dem Namen der Funktion angegeben. Bei Aufruf der Methode verndert sich nichts, da der Kompiler den Typ automatisch erkennt.\n\n\nDie **Ausnahmebehandlung** wurde in Kotlin vereinfacht. Whrend bei Java noch zwischen *checked* und *unchecked Exceptions* unterschieden wird, besteht in Kotlin keine Pflicht bestimmte Ausnahmen zu behandeln.  \nMit `throw` knnen selbst Fehler ausgelst werden. Auerdem kann ein solcher Ausdruck einer Variable zugewiesen werden.  \nAbgefangen werden knnen Exceptions, wie in Java, mit einem `try & catch`-Block. Soll nach der Ausfhrung einer der beiden Blcke noch *aufgerumt* werden, hilft der Anhang eines `finally`-Blocks. Auerdem kann bei dem Vorhandensein von `finally` der `catch`-Block weggelassen werden.  \nEigene Ausnahmen knnen durch eine Klasse erstellt werden, die von `Exception` erbt. Der Oberklasse muss die Beschreibung als Parameter des Datentyps `String` bergeben werden."
    }
   ]
  },
  {
   "artifact_name": "m.91",
   "versions": [
    {
     "start_checkpoint": 1622445465202,
     "origin": "c.80.0"
    }
   ]
  },
  {
   "artifact_name": "m.92",
   "versions": [
    {
     "start_checkpoint": 1622448059191,
     "markdown": "### Aufgabe - Software\n<img src=\"/images/Aufgabenstellung-Vererbung\" style=\"float:right\" />"
    }
   ]
  },
  {
   "artifact_name": "m.93",
   "versions": [
    {
     "start_checkpoint": 1622448064602,
     "markdown": "### Aufgabe - Software\n<img src=\"/images/Aufgabenstellung-Vererbung.png\" style=\"float:right\" />"
    }
   ]
  },
  {
   "artifact_name": "m.94",
   "versions": [
    {
     "start_checkpoint": 1622448078339,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right\" />"
    }
   ]
  },
  {
   "artifact_name": "m.95",
   "versions": [
    {
     "start_checkpoint": 1622448092913,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />"
    }
   ]
  },
  {
   "artifact_name": "m.96",
   "versions": [
    {
     "start_checkpoint": 1622449657117,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />\nWandeln Sie das vereinfachte Klassendiagramm in Code um."
    }
   ]
  },
  {
   "artifact_name": "m.97",
   "versions": [
    {
     "start_checkpoint": 1622449754014,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />\nWandeln Sie das vereinfachte Klassendiagramm in Code um. Die Methoden `starte()`, `schreiben()` und `spielen()` sollen lediglich eine Ausgabe auslsen. Sie knnen sich an folgendes Beispiel halten:  \nDie Textverarbeitungssoftware Office wird gestartet.  \nDie Textverarbeitungssoftware Office schreibt...  \nDas Computerspiel Cyberpunk 2077 wird gestartet.  \nDas Computerspiel Cyberpunk 2077 wird gespielt...  \n"
    }
   ]
  },
  {
   "artifact_name": "m.98",
   "versions": [
    {
     "start_checkpoint": 1622449760455,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />\n\n\nWandeln Sie das vereinfachte Klassendiagramm in Code um. Die Methoden `starte()`, `schreiben()` und `spielen()` sollen lediglich eine Ausgabe auslsen. Sie knnen sich an folgendes Beispiel halten:  \nDie Textverarbeitungssoftware Office wird gestartet.  \nDie Textverarbeitungssoftware Office schreibt...  \nDas Computerspiel Cyberpunk 2077 wird gestartet.  \nDas Computerspiel Cyberpunk 2077 wird gespielt...  \n"
    }
   ]
  },
  {
   "artifact_name": "m.99",
   "versions": [
    {
     "start_checkpoint": 1622449937766,
     "markdown": "### Aufgabe - Software\n<img src=\"images/Aufgabenstellung-Vererbung.png\" style=\"float:right; height: 300px\" />\n\n\nWandeln Sie das vereinfachte Klassendiagramm in Code um. Die Methoden `starte()`, `schreiben()` und `spielen()` sollen lediglich eine Ausgabe auslsen. Sie knnen sich an folgendes Beispiel halten:  \n\n\nDie Textverarbeitungssoftware Office wird gestartet.  \nDie Textverarbeitungssoftware Office schreibt...  \nDas Computerspiel Cyberpunk 2077 wird gestartet.  \nDas Computerspiel Cyberpunk 2077 wird gespielt...  \n"
    }
   ]
  },
  {
   "artifact_name": "m.100",
   "versions": [
    {
     "start_checkpoint": 1622450204455,
     "markdown": "### Aufgabe - Generische Liste\n\nImplementieren Sie eine generische, einfach verkettete Liste `Liste`, die neue Elemente vorne hinzufgt und entnimmt. Die Liste speichert als einzigstes das erste Element. In einer privaten Klasse `Element` soll der Wert und eine Referenz auf das nchste Element zu finden sein. "
    }
   ]
  },
  {
   "artifact_name": "m.101",
   "versions": [
    {
     "start_checkpoint": 1622460905154,
     "markdown": "### Aufgabe - Generische Liste\n\nImplementieren Sie eine generische, einfach verkettete Liste `Liste`, die neue Elemente vorne hinzufgt (`hinzufuegen`) und entnimmt (`entfernen`). `hinzufuegen()` bekommt den Wert des Elements bergeben. Falls die Operation fehlschlgt, soll `false` zurckgegeben werden. Entfernen gibt den Wert des entfernten Elements oder `null` zurck. Die Liste speichert als einziges das erste Element. In einer privaten Klasse `Element` soll der Wert und eine Referenz auf das nchste Element zu finden sein. "
    }
   ]
  },
  {
   "artifact_name": "m.102",
   "versions": [
    {
     "start_checkpoint": 1622461792805,
     "markdown": "### Aufgabe - Schnittstelle fr eine Liste\nIn Konzepte der Programmierung wurde die einfach verkettete Liste intensiv behandelt. Implementieren Sie eine Schnittstelle, die eine solche Liste von `Int`s vorgibt. Es soll ein erstes Element und zwei Methoden, die Elemente hinzufgt und entfernt. Whlen Sie einen passenden Variablentyp, Parameter und Rckgaben. Da eine Schnittstelle schwer zu berprfen ist, gibt es zu dieser Aufgabe keinen Test."
    }
   ]
  },
  {
   "artifact_name": "m.103",
   "versions": [
    {
     "start_checkpoint": 1622461989425,
     "markdown": "### Aufgabe - Schnittstelle fr eine Liste\nIn Konzepte der Programmierung wurde die einfach verkettete Liste intensiv behandelt. Implementieren Sie eine Schnittstelle `Liste`, die eine solche Liste von Elemente vorgibt. Es soll ein erstes Element und zwei Methoden, die Elemente hinzufgt und entfernt. Whlen Sie einen passenden Variablentyp, Parameter und Rckgaben. Da eine Schnittstelle schwer zu berprfen ist, gibt es zu dieser Aufgabe keinen Test."
    }
   ]
  },
  {
   "artifact_name": "m.104",
   "versions": [
    {
     "start_checkpoint": 1622462864423,
     "markdown": "### Aufgabe - Parkplatzverwaltung mit Ausnahmen\nIn Lektion 1 wurde eine Parkplatzverwaltung implementiert. Erweitern Sie ihre Lsung oder die Musterlsung insoweit ab, dass die Methode `einparken()` `Unit` zurckgibt und bei Fehlschlag einen eigens definierten Fehler `ParkplatzVoll` wirft. Diesem soll die Nummer des Parkplatzes bergeben werden, aus der eine schne Fehlermeldung generiert werden soll. Schreiben Sie zustzlich ein Hauptprogramm, in dem Sie einen Fehler absichtlich auslsen und abfangen. Mit diesem knnen Sie ihre Lsung testen."
    }
   ]
  },
  {
   "artifact_name": "m.105",
   "versions": [
    {
     "start_checkpoint": 1622557421858,
     "markdown": "Werden die Methoden hndisch implementiert, knnen diesen aber abweichende Sichtbarkeiten zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.106",
   "versions": [
    {
     "start_checkpoint": 1622557838870,
     "markdown": "Werden die Methoden hndisch implementiert, knnen diesen teilweise abweichende Sichtbarkeiten zugewiesen werden. Der Getter muss den identischen Sichtbarkeitstyp aufweisen. Im Gegensatz dazu kann dem Setter die gleich oder eine *engere* Sichtbarkeit zugewiesen werden."
    }
   ]
  },
  {
   "artifact_name": "m.107",
   "versions": [
    {
     "start_checkpoint": 1622557863403,
     "markdown": "Werden die Methoden hndisch implementiert, knnen diesen teilweise abweichende Sichtbarkeiten zugewiesen werden. Der Getter muss den identischen Sichtbarkeitstyp aufweisen. Im Gegensatz dazu kann dem Setter die gleich oder eine *engere* Sichtbarkeit vorangestellt werden."
    }
   ]
  },
  {
   "artifact_name": "m.108",
   "versions": [
    {
     "start_checkpoint": 1622558305043,
     "markdown": "Im Folgenden werden alle Klassen, Felder und Methoden in der Regel ffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als `public` verlangt. Sie knnen aber natrlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen auf die Getter und Setter implementieren."
    }
   ]
  },
  {
   "artifact_name": "m.109",
   "versions": [
    {
     "start_checkpoint": 1622558336335,
     "markdown": "<div class=\"alert alert-block alert-info\">\n<b>TODO</b> Sichtbarkeiten im Code???\n</div>\n\nIm Folgenden werden alle Klassen, Felder und Methoden in der Regel ffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als `public` verlangt. Sie knnen aber natrlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen auf die Getter und Setter implementieren."
    }
   ]
  },
  {
   "artifact_name": "m.110",
   "versions": [
    {
     "start_checkpoint": 1622558346077,
     "markdown": "<div class=\"alert alert-block alert-info\">\nIm Folgenden werden alle Klassen, Felder und Methoden in der Regel ffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als `public` verlangt. Sie knnen aber natrlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen auf die Getter und Setter implementieren.\n</div>\n\n"
    }
   ]
  },
  {
   "artifact_name": "m.111",
   "versions": [
    {
     "start_checkpoint": 1622558366022,
     "markdown": "<div class=\"alert alert-block alert-info\">\nIm Folgenden werden alle Klassen, Felder und Methoden in der Regel ffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als <code>public</code> verlangt. Sie knnen aber natrlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen auf die Getter und Setter implementieren.\n</div>\n\n"
    }
   ]
  },
  {
   "artifact_name": "m.112",
   "versions": [
    {
     "start_checkpoint": 1622558394999,
     "markdown": "<div class=\"alert alert-block alert-info\">\nIm Folgenden werden alle Klassen, Felder und Methoden in der Regel ffentlich implementiert. Auch wird in den kurzen Aufgaben dieses Abschnitts keine Verwendung einer anderen Sichtbarkeit als <code>public</code> verlangt. Sie knnen aber natrlich gerne optional in den Aufgaben die Zugriffe mit passenden Berechtigungen fr die Getter und Setter beschrnken.\n</div>"
    }
   ]
  }
 ],
 "rawCells": [],
 "snippets": [],
 "output": [
  {
   "artifact_name": "o.0",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.1.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_6.jupyter.kts (4:57 - 62) Cannot access 'alter': it is private in 'Person'"
      }
     ]
    },
    {
     "start_checkpoint": 1619166409884,
     "parent": "c.1.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Person 1, Line_0_jupyter$Person@642b2176: \nName: Max Mustermann, Alter: 21\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.1",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.2.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Marke von a1: BMW, Farbe von a1: Gelb.\nFarbe von a1 nach Umlackierung: Rot.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.2",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.3.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Marke von c1: Fuhitsu, ist c1 an?: false.\nist c1 an?: true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.3",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.4.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Die Flasche mit der Farbe Grau ist zu 20% gefllt.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.4",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.5.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Bett b1: Lnge 160, Breite 200, belegt false\nBett b2: Lnge 0, Breite 50, belegt true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.5",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.6.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Tisch t1: Lnge 100, Breite 100, Farbe Braun\nTisch t2: Lnge 0, Breite 50, Farbe Wei\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.6",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.7.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Stuhl s1: Lnge 20, Breite 20, belegt true\nStuhl s2: Lnge 0, Breite 30, belegt false\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.7",
   "versions": [
    {
     "start_checkpoint": 1619166384323,
     "parent": "c.8.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Konstruktor eines normalen Fensters\nFenster fensterNormal: Lnge 50, Breite 0, Zustand Gebraucht \n\nKonstruktor eines quadratischen Fensters\nFenster fensterQuadrat: Lnge 60, Breite 60, Zustand Schmutzig \n\nKonstruktor eines neuen Fensters\nFenster fensterNeu: Lnge 100, Breite 120, Zustand Neu\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.8",
   "versions": [
    {
     "start_checkpoint": 1619167416345,
     "parent": "c.12.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Batterie eigeneBatterie: Kapazitt 2000, Wiederaufladbar true, Ladezyklen 42, Status Gebraucht\nBatterie neueBatterie: Kapazitt 3000, Wiederaufladbar false, Ladezyklen 0, Status Neu\nBatterie BBBatterie: Kapazitt 2400, Wiederaufladbar false, Ladezyklen 0, Status Neu\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.9",
   "versions": [
    {
     "start_checkpoint": 1619167469117,
     "parent": "c.12.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Batterie eigeneBatterie: Kapazitt 2000, Wiederaufladbar true, Ladezyklen 42, Status Gebraucht\nBatterie neueBatterie: Kapazitt 3000, Wiederaufladbar false, Ladezyklen 0, Status Neu\nBatterie BBBatterie: Kapazitt 2400, Wiederaufladbar false, Ladezyklen 0, Status Neu\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.10",
   "versions": [
    {
     "start_checkpoint": 1619167525913,
     "parent": "c.12.4",
     "raw": [
      {
       "name": "stdout",
       "text": "Batterie eigeneBatterie: Kapazitt 2000, Wiederaufladbar true, Ladezyklen 42, Status Gebraucht.\nBatterie neueBatterie: Kapazitt 3000, Wiederaufladbar false, Ladezyklen 0, Status Neu.\nBatterie BBBatterie: Kapazitt 2400, Wiederaufladbar false, Ladezyklen 0, Status Neu.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.11",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.13.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Person p1, Line_0_jupyter$Person@642b2176: \nName: Max Mustermann, Alter: 21\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.12",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.14.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Batterie eigeneBatterie: Kapazitt 2000, Wiederaufladbar true, Ladezyklen 42, Status Gebraucht\nBatterie neueBatterie: Kapazitt 3000, Wiederaufladbar false, Ladezyklen 0, Status Neu\nBatterie BBBatterie: Kapazitt 2400, Wiederaufladbar false, Ladezyklen 0, Status Neu\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.13",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.15.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_11.jupyter.kts (5:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (10:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (15:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (20:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (25:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (30:13 - 18) Unresolved reference: Pizza\nLine_11.jupyter.kts (35:13 - 18) Unresolved reference: Pizza"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.14",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.16.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_21.jupyter.kts (50:13 - 18) None of the following functions can be called with the arguments supplied: \npublic constructor Pizza(groee: Int) defined in Line_21_jupyter.Pizza\npublic constructor Pizza(groee: Int, belaege: List<String>, geschnitten: Boolean) defined in Line_21_jupyter.Pizza"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.15",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.17.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Person p1: Name: Max Mustermann, Alter -1\nPerson p1: Name: Max Mustermann, Alter 21\nPerson p1: Name: Max Mustermann, Alter 21\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.16",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.18.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Person p1: Name: Max Mustermann, Alter 21, Volljhrig true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.17",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.19.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Volljhrigkeit wird berechnet...\ntrue\ntrue\n"
      }
     ]
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.19.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Wird berechnet...\ntrue\ntrue\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.18",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.20.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Volljhrig\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.19",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.21.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "false\ntrue\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.20",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.22.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Vor Geburtstag: Max Mustermann ist 30 Jahre alt.\nNach Geburtstag: Max Mustermann ist 31 Jahre alt.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.21",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.23.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt p1: Punkt(x=0, y=0, z=0)\np1 und p2 sind ungleich.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.22",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.24.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: 2\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.23",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.25.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "p1: Punkt(x=0, y=1, z=2)\np2: Punkt(x=0, y=1, z=2)\np3: Punkt(x=4, y=1, z=2)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.24",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.26.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt p1 ist im Ursprung: true, Punkt(x=0, y=0, z=0)\nPunkt p2 ist im Ursprung: false, Punkt(x=1, y=1, z=1)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.25",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.27.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Kotlin\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.26",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.28.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Berechnung ohne Singleton: 15\nSingleton Rechner wurde erzeugt.\nBerechnung mit Singleton: 15\nZufallszahl des Singletons: 4\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.27",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.29.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Die Marikelnummer von Max ist 0.\nDie Marikelnummer von Anna ist 1.\nDie Marikelnummer von Simon ist 2.\nDie Marikelnummer von Sophie ist 3.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.28",
   "versions": [
    {
     "start_checkpoint": 1619273398309,
     "parent": "c.30.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Die Nummer des Standard Companion Objects ist 1.\nDie Nummer des Companion Objects Zwei ist 2.\nDie Nummer des Companion Objects Drei ist 3.\nEs ist aktuell 15:48:34.186670 Uhr.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.29",
   "versions": [
    {
     "start_checkpoint": 1619273462931,
     "parent": "c.32.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Marikelnummer von Max ist 0.\nDie Marikelnummer von Anna ist 1.\nDie Marikelnummer von Simon ist 2.\nDie Marikelnummer von Sophie ist 3.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.30",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.33.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Alle Tests bestanden!\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.31",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.34.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Alle Tests bestanden!\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.32",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.35.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Der Name von montag ist MONTAG\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.33",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.36.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Alle Eintrge des Enums: MONTAG, DIENSTAG, MITTWOCH, DONNERSTAG, FREITAG, SAMSTAG, SONNTAG, \nVollstndiger Name von FREITAG: FREITAG\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.34",
   "versions": [
    {
     "start_checkpoint": 1619344122936,
     "parent": "c.37.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Montag ist ein Tag des Wochenendes: false, Nummer des Tags: 1, Zufallszahl: 8\nSamstag ist ein Tag des Wochenendes: true, Nummer des Tags: 6, Zufallszahl: 8\n"
      }
     ]
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.37.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Montag ist ein Tag des Wochenendes: false, Nummer des Tags: 1, Zufallszahl: 3\nSamstag ist ein Tag des Wochenendes: true, Nummer des Tags: 6, Zufallszahl: 3\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.35",
   "versions": [
    {
     "start_checkpoint": 1619344965296,
     "parent": "c.40.5",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Line_6_jupyter$Person@6c6fdf5d\ns1: Line_6_jupyter$Student@187c8f96\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.36",
   "versions": [
    {
     "start_checkpoint": 1619344997121,
     "parent": "c.40.6",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Line_7_jupyter$Person@25e9f5e6\ns1: Line_7_jupyter$Student@512319dc\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.37",
   "versions": [
    {
     "start_checkpoint": 1619345039116,
     "parent": "c.40.7",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt.\ns1: Ich bin Erika Mustermann und bin 21 Jahre alt.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.38",
   "versions": [
    {
     "start_checkpoint": 1619345077293,
     "parent": "c.40.8",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt.\ns1: Ich bin Erika Mustermann, bin 21 Jahre alt und besitze die Matrikelnummer matrikelnummer.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.39",
   "versions": [
    {
     "start_checkpoint": 1619345085096,
     "parent": "c.40.9",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt.\ns1: Ich bin Erika Mustermann, bin 21 Jahre alt und besitze die Matrikelnummer 0.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.40",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.45.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt. Fr die Horde!\nMax Mustermann hat Geburtstag. Alles Gute!\np1: Ich bin Max Mustermann und bin 26 Jahre alt. Fr die Horde!\ns1: Ich bin Erika Mustermann, bin 21 Jahre alt und habe die Matrikelnummer 0. Fr die Allianz! Oder vielleicht doch: Fr die Horde!?\nErika Mustermann hat Geburtstag. Alles Gute!\ns1: Ich bin Erika Mustermann, bin 20 Jahre alt und habe die Matrikelnummer 0. Fr die Allianz! Oder vielleicht doch: Fr die Horde!?\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.41",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.46.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt p1: x: 4, y: 2, z: 8\nPunkt p2: x: 0, y: 0, z: 0\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.42",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.47.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Laptop wurde eingeschalten.\nStandcomputer wurde eingeschalten.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.43",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.48.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_13.jupyter.kts (2:41 - 47) Cannot access '<init>': it is private in 'Fehler'\nLine_13.jupyter.kts (2:41 - 47) This type is sealed, so it can be inherited by only its own nested classes or objects\nLine_13.jupyter.kts (3:27 - 29) Data class must have at least one primary constructor parameter\nLine_13.jupyter.kts (3:32 - 38) Cannot access '<init>': it is private in 'Fehler'\nLine_13.jupyter.kts (3:32 - 38) This type is sealed, so it can be inherited by only its own nested classes or objects\nLine_13.jupyter.kts (4:26 - 28) Data class must have at least one primary constructor parameter\nLine_13.jupyter.kts (4:31 - 37) Cannot access '<init>': it is private in 'Fehler'\nLine_13.jupyter.kts (4:31 - 37) This type is sealed, so it can be inherited by only its own nested classes or objects\nLine_13.jupyter.kts (9:8 - 22) Incompatible types: Line_13_jupyter.Laufzeitfehler and Line_13_jupyter.Kompilierfehler\nLine_13.jupyter.kts (10:5 - 23) Check for instance is always 'true'\nLine_13.jupyter.kts (11:8 - 22) Incompatible types: Line_13_jupyter.Referenzfehler and Line_13_jupyter.Kompilierfehler"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.44",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.49.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "rechner.dieZahl: 42\nrechner.add2(5,3): 8\nrechner.add3(5,9,3): 17\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.45",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.50.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "s1: Speicher(platz1=1, platz2=2, platz3=3)\ns2: Speicher(platz1=[1, 2, 3], platz2=[1, 2, 3], platz3=[1, 2, 3])\ns3: Speicher(platz1=Kotlin, platz2=Java, platz3=C)\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.46",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.51.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "gleichheitstestInt.istGleich(3,3): true\ngleichheitstestInt.istGleich(10,3): false\ngleichheitstestString.istGleich('Kotlin','Kotlin'): true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.47",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.52.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "istGleich(3,3): true\nistGleich('Kotlin','Kotlin'): true\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.48",
   "versions": [
    {
     "start_checkpoint": 1619427664533,
     "parent": "c.53.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Entferntes Element: 1\nliste: [3, 6, 8, 10]\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.49",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "c.57.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Punkt p1: Punkt(x=0, y=0, z=0)\nPunkt p2: Punkt(x=1, y=1, z=1)\np1 und p2 sind ungleich.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.50",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "c.58.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Line_23.jupyter.kts (3:31 - 38) Unresolved reference: Abstand\nLine_23.jupyter.kts (6:26 - 34) Unresolved reference: Position\nLine_23.jupyter.kts (6:41 - 49) Unresolved reference: Position\nLine_23.jupyter.kts (6:56 - 64) Unresolved reference: Position\nLine_23.jupyter.kts (6:71 - 79) Unresolved reference: Position\nLine_23.jupyter.kts (7:26 - 34) Unresolved reference: Position\nLine_23.jupyter.kts (7:41 - 49) Unresolved reference: Position\nLine_23.jupyter.kts (7:57 - 65) Unresolved reference: Position\nLine_23.jupyter.kts (7:72 - 80) Unresolved reference: Position\nLine_23.jupyter.kts (10:9 - 24) Unresolved reference: berechneAbstand\nLine_23.jupyter.kts (13:19 - 21) Unresolved reference: it"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.51",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "c.59.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Alle Tests bestanden!\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.52",
   "versions": [
    {
     "start_checkpoint": 1622203535195,
     "parent": "c.61.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Es ist ein Laufzeitfehler aufgetreten.\n"
      }
     ]
    },
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.61.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Es ist ein Referenzfehler aufgetreten.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.53",
   "versions": [
    {
     "start_checkpoint": 1622203944610,
     "parent": "c.13.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Person p1: Line_0$Person@61ec3f97\nName: Max Mustermann, Alter: 21\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.54",
   "versions": [
    {
     "start_checkpoint": 1622204008193,
     "parent": "c.13.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Person p1: Line_1$Person@653ab1f7\nName: Max Mustermann, Alter: 21\n",
       "output_type": "stream"
      }
     ]
    },
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.13.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Person p1: Line_0$Person@1be52985\nName: Max Mustermann, Alter: 21\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.55",
   "versions": [
    {
     "start_checkpoint": 1622204182191,
     "parent": "c.3.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Marke von c1: Fuhitsu, ist c1 an?: false.\nIst c1 an?: true\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.56",
   "versions": [
    {
     "start_checkpoint": 1622204907095,
     "parent": "c.8.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Konstruktion eines normalen Fensters\nFenster fensterNormal: Lnge 50, Breite 0, Zustand Gebraucht \n\nKonstruktion eines quadratischen Fensters\nFenster fensterQuadrat: Lnge 60, Breite 60, Zustand Schmutzig \n\nKonstruktion eines neuen Fensters\nFenster fensterNeu: Lnge 100, Breite 120, Zustand Neu\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.57",
   "versions": [
    {
     "start_checkpoint": 1622208996780,
     "parent": "c.66.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Alle Tests bestanden!\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.58",
   "versions": [
    {
     "start_checkpoint": 1622209406266,
     "parent": "c.21.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Versuch 1: false\nVersuch 2: true\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.59",
   "versions": [
    {
     "start_checkpoint": 1622209870934,
     "parent": "c.24.1",
     "raw": [
      {
       "name": "stdout",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: 2, 3\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.60",
   "versions": [
    {
     "start_checkpoint": 1622210144419,
     "parent": "c.24.2",
     "raw": [
      {
       "name": "stdout",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: 2\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.61",
   "versions": [
    {
     "start_checkpoint": 1622210151826,
     "parent": "c.24.3",
     "raw": [
      {
       "name": "stdout",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: z\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.62",
   "versions": [
    {
     "start_checkpoint": 1622210205883,
     "parent": "c.24.4",
     "raw": [
      {
       "name": "stdout",
       "text": "p1.component1(): 0\nx: 0, y: 1, z: 2\na: 0, b: 1\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.63",
   "versions": [
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.3.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Marke von c1: Fuhitsu, ist c1 an?: false.\nIst c1 an?: true\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.64",
   "versions": [
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.7.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Stuhl s1: Lnge 20, Breite 20, belegt true\nStuhl s2: Lnge 0, Breite 30, belegt false\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.65",
   "versions": [
    {
     "start_checkpoint": 1622210797522,
     "parent": "c.25.1",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Punkt(x=0, y=1, z=2)\np2: Punkt(x=0, y=1, z=2)\np3: Punkt(x=4, y=1, z=2)\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.66",
   "versions": [
    {
     "start_checkpoint": 1622211105740,
     "parent": "c.30.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Nummer des Standard Companion Objects ist 1.\nDie Nummer des Companion Objects Zwei ist 2.\nDie Nummer des Companion Objects Drei ist 3.\nEs ist aktuell 16:16:29.853940 Uhr.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.67",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.62.0",
     "raw": [
      {
       "execution_count": 14,
       "output_type": "execute_result",
       "data": {
        "text/plain": "63"
       },
       "metadata": {}
      }
     ]
    },
    {
     "start_checkpoint": 1622290272824,
     "parent": "c.62.0",
     "raw": [
      {
       "execution_count": 41,
       "output_type": "execute_result",
       "data": {
        "text/plain": "66"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.68",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.63.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Zeichenkette Kotlin kann nicht in eine ganze Zahl umgewandelt werden.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.69",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.64.0",
     "raw": [
      {
       "execution_count": 16,
       "output_type": "execute_result",
       "data": {
        "text/plain": "17"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.70",
   "versions": [
    {
     "start_checkpoint": 1622285607950,
     "parent": "c.35.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Der Name von montag ist MONTAG.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.71",
   "versions": [
    {
     "start_checkpoint": 1622286007574,
     "parent": "c.40.10",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Ich bin Max Mustermann und bin 25 Jahre alt.\ns1: Mein Name ist Erika Mustermann, ich bin 21 Jahre alt und besitze die Matrikelnummer 0.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.72",
   "versions": [
    {
     "start_checkpoint": 1622286066819,
     "parent": "c.40.11",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Mein Name ist Max Mustermann und ich bin 25 Jahre alt.\ns1: Mein Name ist Erika Mustermann, ich bin 21 Jahre alt und besitze die Matrikelnummer 0.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.73",
   "versions": [
    {
     "start_checkpoint": 1622286097813,
     "parent": "c.45.1",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Mein Name ist Max Mustermann und ich bin 25 Jahre alt. Fr die Horde!\nMax Mustermann hat Geburtstag. Alles Gute!\np1: Mein Name ist Max Mustermann und ich bin 26 Jahre alt. Fr die Horde!\ns1: Mein Name ist Erika Mustermann, ich bin 21 Jahre alt und habe die Matrikelnummer 0. Fr die Allianz! Oder vielleicht doch: Fr die Horde!?\nErika Mustermann hat Geburtstag. Alles Gute!\ns1: Mein Name ist Erika Mustermann, ich bin 20 Jahre alt und habe die Matrikelnummer 0. Fr die Allianz! Oder vielleicht doch: Fr die Horde!?\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.74",
   "versions": [
    {
     "start_checkpoint": 1622286553284,
     "parent": "c.45.3",
     "raw": [
      {
       "name": "stdout",
       "text": "p1: Mein Name ist Max Mustermann und ich bin 25 Jahre alt. Fr die Horde!\nMax Mustermann hat Geburtstag. Alles Gute!\np1: Mein Name ist Max Mustermann und ich bin 26 Jahre alt. Fr die Horde!\ns1: Mein Name ist Erika Mustermann, ich bin 21 Jahre alt und habe die Matrikelnummer 0. Fr die Allianz! Oder vielleicht doch: Fr die Horde!?\nErika Mustermann hat Geburtstag. Alles Gute!\ns1: Mein Name ist Erika Mustermann, ich bin 20 Jahre alt und habe die Matrikelnummer 0. Fr die Allianz! Oder vielleicht doch: Fr die Horde!?\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.75",
   "versions": [
    {
     "start_checkpoint": 1622286910420,
     "parent": "c.61.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Es ist ein Kompilierfehler aufgetreten.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.76",
   "versions": [
    {
     "start_checkpoint": 1622286961921,
     "parent": "c.61.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Es ist ein Referenzfehler aufgetreten.\n",
       "output_type": "stream"
      }
     ]
    },
    {
     "start_checkpoint": 1622286964294,
     "parent": "c.61.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Laufzeitfehler(f=2)\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.77",
   "versions": [
    {
     "start_checkpoint": 1622287051823,
     "parent": "c.61.3",
     "raw": [
      {
       "name": "stdout",
       "text": "Es ist ein Kompilierfehler Kompilierfehler(fehlercode=42) aufgetreten.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.78",
   "versions": [
    {
     "start_checkpoint": 1622290123775,
     "parent": "c.53.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Entferntes Element: 1\nlisteq: [3, 6, 8, 10]\nEntferntes Element: e\nlistew: [f, w, t, q]\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.79",
   "versions": [
    {
     "start_checkpoint": 1622290183581,
     "parent": "c.53.2",
     "raw": [
      {
       "name": "stdout",
       "text": "Entferntes Element: 1\nlisteq: [3, 6, 8, 10]\nEntferntes Element: e\nliste2: [f, w, t, q]\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.80",
   "versions": [
    {
     "start_checkpoint": 1622290193733,
     "parent": "c.53.3",
     "raw": [
      {
       "name": "stdout",
       "text": "Entferntes Element von liste1: 1\nlisteq: [3, 6, 8, 10]\nEntferntes Element von liste2: e\nliste2: [f, w, t, q]\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.81",
   "versions": [
    {
     "start_checkpoint": 1622290204256,
     "parent": "c.53.5",
     "raw": [
      {
       "name": "stdout",
       "text": "Entferntes Element von liste1: 1\nlisteq: [3, 6, 8, 10]\nEntferntes Element von liste2: e\nliste2: [f, w, t, q]\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.82",
   "versions": [
    {
     "start_checkpoint": 1622290304056,
     "parent": "c.62.1",
     "raw": [
      {
       "execution_count": 45,
       "output_type": "execute_result",
       "data": {
        "text/plain": "35"
       },
       "metadata": {}
      }
     ]
    },
    {
     "start_checkpoint": 1622290305955,
     "parent": "c.62.1",
     "raw": [
      {
       "execution_count": 46,
       "output_type": "execute_result",
       "data": {
        "text/plain": "7"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.83",
   "versions": [
    {
     "start_checkpoint": 1622290337397,
     "parent": "c.62.2",
     "raw": [
      {
       "execution_count": 47,
       "output_type": "execute_result",
       "data": {
        "text/plain": "53"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.84",
   "versions": [
    {
     "start_checkpoint": 1622290370267,
     "parent": "c.62.3",
     "raw": [
      {
       "name": "stdout",
       "text": "Int\n",
       "output_type": "stream"
      },
      {
       "execution_count": 50,
       "output_type": "execute_result",
       "data": {
        "text/plain": "95"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.85",
   "versions": [
    {
     "start_checkpoint": 1622290408459,
     "parent": "c.62.4",
     "raw": [
      {
       "execution_count": 53,
       "output_type": "execute_result",
       "data": {
        "text/plain": "27"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.86",
   "versions": [
    {
     "start_checkpoint": 1622290541161,
     "parent": "c.63.1",
     "raw": [
      {
       "execution_count": 57,
       "output_type": "execute_result",
       "data": {
        "text/plain": "231"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.87",
   "versions": [
    {
     "start_checkpoint": 1622290562913,
     "parent": "c.63.3",
     "raw": [
      {
       "execution_count": 59,
       "output_type": "execute_result",
       "data": {
        "text/plain": "231"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.88",
   "versions": [
    {
     "start_checkpoint": 1622290572241,
     "parent": "c.63.4",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Zeichenkette Kotlin kann nicht in eine ganze Zahl umgewandelt werden.\njava.lang.NumberFormatException: For input string: \"Kotlin\"\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.89",
   "versions": [
    {
     "start_checkpoint": 1622290587221,
     "parent": "c.63.5",
     "raw": [
      {
       "execution_count": 61,
       "output_type": "execute_result",
       "data": {
        "text/plain": "231"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.90",
   "versions": [
    {
     "start_checkpoint": 1622290655058,
     "parent": "c.63.7",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Zeichenkette Kotlin kann nicht in eine ganze Zahl umgewandelt werden.\njava.lang.NumberFormatException: For input string: \"Kotlin\"\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.91",
   "versions": [
    {
     "start_checkpoint": 1622291067351,
     "parent": "c.73.2",
     "raw": [
      {
       "execution_count": 69,
       "output_type": "execute_result",
       "data": {
        "text/plain": "2"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.92",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "c.74.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Laptop wurde eingeschalten.\nStandcomputer wurde eingeschalten.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.93",
   "versions": [
    {
     "start_checkpoint": 1622312494538,
     "parent": "c.75.0",
     "raw": [
      {
       "name": "stderr",
       "output_type": "stream",
       "text": "Der Parameter muss zwischen 0 und 100 sein, ist aber -57\nLine_66$KeineProzentzahl: Der Parameter muss zwischen 0 und 100 sein, ist aber -57\norg.jetbrains.kotlinx.jupyter.ReplEvalRuntimeException: Der Parameter muss zwischen 0 und 100 sein, ist aber -57\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.InternalEvaluatorImpl.eval(InternalEvaluatorImpl.kt:91)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.CellExecutorImpl$execute$1$result$1.invoke(CellExecutorImpl.kt:63)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.CellExecutorImpl$execute$1$result$1.invoke(CellExecutorImpl.kt:62)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.withHost(repl.kt:536)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.CellExecutorImpl.execute(CellExecutorImpl.kt:62)\n\tat org.jetbrains.kotlinx.jupyter.repl.CellExecutor$DefaultImpls.execute$default(CellExecutor.kt:13)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl$eval$1.invoke(repl.kt:371)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl$eval$1.invoke(repl.kt:361)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.withEvalContext(repl.kt:346)\n\tat org.jetbrains.kotlinx.jupyter.ReplForJupyterImpl.eval(repl.kt:361)\n\tat org.jetbrains.kotlinx.jupyter.ProtocolKt$shellMessagesHandler$res$1.invoke(protocol.kt:291)\n\tat org.jetbrains.kotlinx.jupyter.ProtocolKt$shellMessagesHandler$res$1.invoke(protocol.kt:290)\n\tat org.jetbrains.kotlinx.jupyter.JupyterConnection$runExecution$execThread$1.invoke(connection.kt:162)\n\tat org.jetbrains.kotlinx.jupyter.JupyterConnection$runExecution$execThread$1.invoke(connection.kt:160)\n\tat kotlin.concurrent.ThreadsKt$thread$thread$1.run(Thread.kt:30)\nCaused by: Line_66$KeineProzentzahl: Der Parameter muss zwischen 0 und 100 sein, ist aber -57\n\tat Line_66.<init>(Line_66.jupyter-kts:8)\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:64)\n\tat java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat java.base/java.lang.reflect.Constructor.newInstanceWithCaller(Constructor.java:500)\n\tat java.base/java.lang.reflect.Constructor.newInstance(Constructor.java:481)\n\tat kotlin.script.experimental.jvm.BasicJvmScriptEvaluator.evalWithConfigAndOtherScriptsResults(BasicJvmScriptEvaluator.kt:96)\n\tat kotlin.script.experimental.jvm.BasicJvmScriptEvaluator.invoke$suspendImpl(BasicJvmScriptEvaluator.kt:41)\n\tat kotlin.script.experimental.jvm.BasicJvmScriptEvaluator.invoke(BasicJvmScriptEvaluator.kt)\n\tat kotlin.script.experimental.jvm.BasicJvmReplEvaluator.eval(BasicJvmReplEvaluator.kt:51)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.InternalEvaluatorImpl$eval$resultWithDiagnostics$1.invokeSuspend(InternalEvaluatorImpl.kt:84)\n\tat kotlin.coroutines.jvm.internal.BaseContinuationImpl.resumeWith(ContinuationImpl.kt:33)\n\tat kotlinx.coroutines.DispatchedTask.run(DispatchedTask.kt:106)\n\tat kotlinx.coroutines.EventLoopImplBase.processNextEvent(EventLoop.common.kt:274)\n\tat kotlinx.coroutines.BlockingCoroutine.joinBlocking(Builders.kt:84)\n\tat kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking(Builders.kt:59)\n\tat kotlinx.coroutines.BuildersKt.runBlocking(Unknown Source)\n\tat kotlinx.coroutines.BuildersKt__BuildersKt.runBlocking$default(Builders.kt:38)\n\tat kotlinx.coroutines.BuildersKt.runBlocking$default(Unknown Source)\n\tat org.jetbrains.kotlinx.jupyter.repl.impl.InternalEvaluatorImpl.eval(InternalEvaluatorImpl.kt:84)\n\t... 14 more\n\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.94",
   "versions": [
    {
     "start_checkpoint": 1622445305424,
     "parent": "c.78.0",
     "raw": [
      {
       "name": "stdout",
       "output_type": "stream",
       "text": "Super! Es konnten keine zwei Autos mit dem gleichen Nummernschild gefunden werden.\n"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.95",
   "versions": [
    {
     "start_checkpoint": 1622445448043,
     "parent": "c.78.1",
     "raw": [
      {
       "name": "stdout",
       "text": "Super! Alle Nummernschilder sind einzigartig.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.96",
   "versions": [
    {
     "start_checkpoint": 1622445629223,
     "parent": "c.81.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Super! Alle Nummernschilder sind einzigartig.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.97",
   "versions": [
    {
     "start_checkpoint": 1622446438359,
     "parent": "c.84.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Richtig! Es traten keine Fehler auf.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.98",
   "versions": [
    {
     "start_checkpoint": 1622448670796,
     "parent": "c.87.0",
     "raw": [
      {
       "execution_count": 29,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Office"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.99",
   "versions": [
    {
     "start_checkpoint": 1622448728040,
     "parent": "c.88.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.100",
   "versions": [
    {
     "start_checkpoint": 1622448767131,
     "parent": "c.89.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.101",
   "versions": [
    {
     "start_checkpoint": 1622448836926,
     "parent": "c.90.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.102",
   "versions": [
    {
     "start_checkpoint": 1622448873498,
     "parent": "c.91.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      },
      {
       "execution_count": 35,
       "output_type": "execute_result",
       "data": {
        "text/plain": "[Line_39.Software]"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.103",
   "versions": [
    {
     "start_checkpoint": 1622448912229,
     "parent": "c.92.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.104",
   "versions": [
    {
     "start_checkpoint": 1622448923282,
     "parent": "c.93.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.105",
   "versions": [
    {
     "start_checkpoint": 1622448961246,
     "parent": "c.94.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.106",
   "versions": [
    {
     "start_checkpoint": 1622448968685,
     "parent": "c.95.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\nFehler\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.107",
   "versions": [
    {
     "start_checkpoint": 1622449325160,
     "parent": "c.96.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\nFehler\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.108",
   "versions": [
    {
     "start_checkpoint": 1622449328804,
     "parent": "c.97.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.109",
   "versions": [
    {
     "start_checkpoint": 1622449386830,
     "parent": "c.98.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.110",
   "versions": [
    {
     "start_checkpoint": 1622449412581,
     "parent": "c.99.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.111",
   "versions": [
    {
     "start_checkpoint": 1622449427152,
     "parent": "c.100.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.112",
   "versions": [
    {
     "start_checkpoint": 1622449455419,
     "parent": "c.101.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.113",
   "versions": [
    {
     "start_checkpoint": 1622449459194,
     "parent": "c.102.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\nFehler! java.lang.Exception: Test\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.114",
   "versions": [
    {
     "start_checkpoint": 1622449563208,
     "parent": "c.103.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.115",
   "versions": [
    {
     "start_checkpoint": 1622449581627,
     "parent": "c.104.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Die Textverarbeitungssoftware Office wird gestartet.\nDie Textverarbeitungssoftware Office schreibt...\nDas Computerspiel Cyberpunk 2077 wird gestartet.\nDas Computerspiel Cyberpunk 2077 wird gespielt...\nSuper! Ihre Lsung ist richtig.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.116",
   "versions": [
    {
     "start_checkpoint": 1622461253120,
     "parent": "c.105.0",
     "raw": [
      {
       "execution_count": 86,
       "output_type": "execute_result",
       "data": {
        "text/plain": "[]"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.117",
   "versions": [
    {
     "start_checkpoint": 1622461274695,
     "parent": "c.106.0",
     "raw": [
      {
       "execution_count": 87,
       "output_type": "execute_result",
       "data": {
        "text/plain": "[kotlin.Any]"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.118",
   "versions": [
    {
     "start_checkpoint": 1622462409997,
     "parent": "c.111.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Line_112$ParkplatzVoll: Der Parkplatz 2 ist belegt.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.119",
   "versions": [
    {
     "start_checkpoint": 1622462466361,
     "parent": "c.112.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Line_113$ParkplatzVoll: Der Parkplatz 2 ist belegt.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.120",
   "versions": [
    {
     "start_checkpoint": 1622462480225,
     "parent": "c.113.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Line_114$ParkplatzVoll: Der Parkplatz 2 ist belegt.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.121",
   "versions": [
    {
     "start_checkpoint": 1622554526806,
     "parent": "c.114.0",
     "raw": [
      {
       "execution_count": 101,
       "output_type": "execute_result",
       "data": {
        "text/plain": "3"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.122",
   "versions": [
    {
     "start_checkpoint": 1622554535077,
     "parent": "c.115.0",
     "raw": [
      {
       "execution_count": 102,
       "output_type": "execute_result",
       "data": {
        "text/plain": "3"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.123",
   "versions": [
    {
     "start_checkpoint": 1622554558291,
     "parent": "c.116.0",
     "raw": [
      {
       "execution_count": 103,
       "output_type": "execute_result",
       "data": {
        "text/plain": "3"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.124",
   "versions": [
    {
     "start_checkpoint": 1622554574252,
     "parent": "c.117.0",
     "raw": [
      {
       "execution_count": 104,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=2, naechster=Element(wert=1, naechster=null))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.125",
   "versions": [
    {
     "start_checkpoint": 1622554722608,
     "parent": "c.118.0",
     "raw": [
      {
       "execution_count": 105,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=2, naechster=Element(wert=1, naechster=null))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.126",
   "versions": [
    {
     "start_checkpoint": 1622554905062,
     "parent": "c.119.0",
     "raw": [
      {
       "execution_count": 106,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=3, naechstes=null)"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.127",
   "versions": [
    {
     "start_checkpoint": 1622554928149,
     "parent": "c.122.0",
     "raw": [
      {
       "execution_count": 109,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=1, naechstes=null)"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.128",
   "versions": [
    {
     "start_checkpoint": 1622554936285,
     "parent": "c.123.0",
     "raw": [
      {
       "execution_count": 110,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=2, naechstes=null)"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.129",
   "versions": [
    {
     "start_checkpoint": 1622555013679,
     "parent": "c.124.0",
     "raw": [
      {
       "execution_count": 111,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=2, naechstes=Element(wert=1, naechstes=null))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.130",
   "versions": [
    {
     "start_checkpoint": 1622555057935,
     "parent": "c.125.0",
     "raw": [
      {
       "execution_count": 112,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=10, naechstes=Element(wert=9, naechstes=Element(wert=8, naechstes=Element(wert=7, naechstes=Element(wert=6, naechstes=Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))))))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.131",
   "versions": [
    {
     "start_checkpoint": 1622555146041,
     "parent": "c.126.0",
     "raw": [
      {
       "execution_count": 114,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=10, naechstes=Element(wert=9, naechstes=Element(wert=8, naechstes=Element(wert=7, naechstes=Element(wert=6, naechstes=Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))))))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.132",
   "versions": [
    {
     "start_checkpoint": 1622555280381,
     "parent": "c.127.0",
     "raw": [
      {
       "execution_count": 115,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=10, naechstes=Element(wert=9, naechstes=Element(wert=8, naechstes=Element(wert=7, naechstes=Element(wert=6, naechstes=Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))))))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.133",
   "versions": [
    {
     "start_checkpoint": 1622555291808,
     "parent": "c.128.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Der Wert des ersten Elements sollte 10 sein, ist aber 5\nFehler! Der Wert des zweiten Elements sollte 10 sein, ist aber 4\n",
       "output_type": "stream"
      },
      {
       "execution_count": 116,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.134",
   "versions": [
    {
     "start_checkpoint": 1622555329392,
     "parent": "c.129.0",
     "raw": [
      {
       "execution_count": 117,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.135",
   "versions": [
    {
     "start_checkpoint": 1622555376241,
     "parent": "c.130.0",
     "raw": [
      {
       "execution_count": 118,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.136",
   "versions": [
    {
     "start_checkpoint": 1622555441324,
     "parent": "c.131.0",
     "raw": [
      {
       "execution_count": 119,
       "output_type": "execute_result",
       "data": {
        "text/plain": "Element(wert=5, naechstes=Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))))"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.137",
   "versions": [
    {
     "start_checkpoint": 1622555549197,
     "parent": "c.134.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Das Element mit dem Wert 5 konnte nicht enfernt werden. Line_142$Liste@1948a75e\nFehler! Das Element mit dem Wert 4 konnte nicht enfernt werden. Line_142$Liste@1948a75e\nFehler! Das Element mit dem Wert 3 konnte nicht enfernt werden. Line_142$Liste@1948a75e\nFehler! Das Element mit dem Wert 2 konnte nicht enfernt werden. Line_142$Liste@1948a75e\nFehler! Das Element mit dem Wert 1 konnte nicht enfernt werden. Line_142$Liste@1948a75e\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.138",
   "versions": [
    {
     "start_checkpoint": 1622555562967,
     "parent": "c.135.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Das Element mit dem Wert 5 konnte nicht enfernt werden. Line_144$Liste@74226377\nFehler! Das Element mit dem Wert 4 konnte nicht enfernt werden. Line_144$Liste@74226377\nFehler! Das Element mit dem Wert 3 konnte nicht enfernt werden. Line_144$Liste@74226377\nFehler! Das Element mit dem Wert 2 konnte nicht enfernt werden. Line_144$Liste@74226377\nFehler! Das Element mit dem Wert 1 konnte nicht enfernt werden. Line_144$Liste@74226377\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.139",
   "versions": [
    {
     "start_checkpoint": 1622555573766,
     "parent": "c.136.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Das Element mit dem Wert 5 konnte nicht enfernt werden. Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))\nFehler! Das Element mit dem Wert 4 konnte nicht enfernt werden. Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))\nFehler! Das Element mit dem Wert 3 konnte nicht enfernt werden. Element(wert=2, naechstes=Element(wert=1, naechstes=null))\nFehler! Das Element mit dem Wert 2 konnte nicht enfernt werden. Element(wert=1, naechstes=null)\nFehler! Das Element mit dem Wert 1 konnte nicht enfernt werden. null\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.140",
   "versions": [
    {
     "start_checkpoint": 1622555585074,
     "parent": "c.137.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Fehler! Das Element mit dem Wert 5 konnte nicht enfernt werden. Element(wert=4, naechstes=Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null))))\nFehler! Das Element mit dem Wert 4 konnte nicht enfernt werden. Element(wert=3, naechstes=Element(wert=2, naechstes=Element(wert=1, naechstes=null)))\nFehler! Das Element mit dem Wert 3 konnte nicht enfernt werden. Element(wert=2, naechstes=Element(wert=1, naechstes=null))\nFehler! Das Element mit dem Wert 2 konnte nicht enfernt werden. Element(wert=1, naechstes=null)\nFehler! Das Element mit dem Wert 1 konnte nicht enfernt werden. null\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.141",
   "versions": [
    {
     "start_checkpoint": 1622555767250,
     "parent": "c.139.0",
     "raw": [
      {
       "name": "stdout",
       "text": "Super! Ihre Lsung hat alle Tests bestanden.\n",
       "output_type": "stream"
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.142",
   "versions": [
    {
     "start_checkpoint": 1622557161983,
     "parent": "c.140.0",
     "raw": [
      {
       "execution_count": 136,
       "output_type": "execute_result",
       "data": {
        "text/plain": "test"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.143",
   "versions": [
    {
     "start_checkpoint": 1622557178954,
     "parent": "c.141.0",
     "raw": [
      {
       "execution_count": 139,
       "output_type": "execute_result",
       "data": {
        "text/plain": "test"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.144",
   "versions": [
    {
     "start_checkpoint": 1622557527039,
     "parent": "c.142.0",
     "raw": [
      {
       "execution_count": 143,
       "output_type": "execute_result",
       "data": {
        "text/plain": "test"
       },
       "metadata": {}
      }
     ]
    }
   ]
  },
  {
   "artifact_name": "o.145",
   "versions": [
    {
     "start_checkpoint": 1622557707412,
     "parent": "c.143.0",
     "raw": [
      {
       "execution_count": 146,
       "output_type": "execute_result",
       "data": {
        "text/plain": "test"
       },
       "metadata": {}
      }
     ]
    }
   ]
  }
 ]
}